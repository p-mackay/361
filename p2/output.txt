b'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'eled\n   and referenced in Appendix B, which summarizes implementation\n   requirements.\n\n   Sentences using "MUST" are labeled as "MUST-X" with X being a numeric\n   identifier enabling the requirement to be located easily when\n   referenced from Appendix B.\n\n   Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY"\n   with "MAY-X", and "RECOMMENDED" with "REC-X".\n\n   For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are\n   labeled the same as "SHOULD" and "MUST" instances.\n\n2.2.  Key TCP Concepts\n\n   TCP provides a reliable, in-order, byte-stream service to\n   applications.\n\n   The application byte-stream is conveyed over the network via TCP\n   segments, with each TCP segment sent as an Internet Protocol (IP)\n   datagram.\n\n   TCP reliability consists of detecting packet losses (via sequence\n   numbers) and errors (via per-segment checksums), as well as\n   correction via retransmission.\n\n   TCP supports unicast delivery ofb' use TCP without modifications,\n   though there is some risk of instability due to changes of lower-\n   layer forwarding behavior [46].\n\n   TCP is connection oriented, though it does not inherently include a\n   liveness detection capability.\n\n   Data flow is supported bidirectionally over TCP connections, though\n   applications are free to send data only unidirectionally, if they so\n   choose.\n\n   TCP uses port numbers to identify application services and to\n   multiplex distinct flows between hosts.\n\n   A more detailed description of TCP features compared to other\n   transport protocols can be found in Section 3.1 of [52].  Further\n   description of the motivations for developing TCP and its role in the\n   Internet protocol stack can be found in Section 2 of [16] and earlier\n   versions of the TCP specification.\n\n3.  Functional Specification\n\n3.1.  Header Format\n\n   TCP segments are sent as internet datagrams.  The Internet Protocol\n   (IP) header b'nd destination host addresses [1] [13].  A TCP header follows the IP\n   headers, supplying information specific to TCP.  This division allows\n   for the existence of host-level protocols other than TCP.  In the\n   early development of the Internet suite of protocols, the IP header\n   fields had been a part of TCP.\n\n   This document describes TCP, which uses TCP headers.\n\n   A TCP header, followed by any user data in the segment, is formatted\n   as follows, using the style from [66]:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |          Source Port          |       Destination Port        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                        Sequence Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-b'dgment Number                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |  Data |       |C|E|U|A|P|R|S|F|                               |\n      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |\n      |       |       |R|E|G|K|H|T|N|N|                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Checksum            |         Urgent Pointer        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                           [Options]                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               :\n      :                             Data                              :\n      :                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\b'e bit position.\n\n                        Figure 1: TCP Header Format\n\n   where:\n\n   Source Port:  16 bits\n\n     The source port number.\n\n   Destination Port:  16 bits\n\n     The destination port number.\n\n   Sequence Number:  32 bits\n\n     The sequence number of the first data octet in this segment (except\n     when the SYN flag is set).  If SYN is set, the sequence number is\n     the initial sequence number (ISN) and the first data octet is\n     ISN+1.\n\n   Acknowledgment Number:  32 bits\n\n     If the ACK control bit is set, this field contains the value of the\n     next sequence number the sender of the segment is expecting to\n     receive.  Once a connection is established, this is always sent.\n\n   Data Offset (DOffset):  4 bits\n\n     The number of 32-bit words in the TCP header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integer multiple of 32 bits long.\n\n   Reserved (Rsrvd):  4 bits\b'\n     generated segments and must be ignored in received segments if the\n     corresponding future features are not implemented by the sending or\n     receiving host.\n\n   Control bits:  The control bits are also known as "flags".\n     Assignment is managed by IANA from the "TCP Header Flags" registry\n     [62].  The currently assigned control bits are CWR, ECE, URG, ACK,\n     PSH, RST, SYN, and FIN.\n\n     CWR:  1 bit\n\n         Congestion Window Reduced (see [6]).\n\n     ECE:  1 bit\n\n         ECN-Echo (see [6]).\n\n     URG:  1 bit\n\n         Urgent pointer field is significant.\n\n     ACK:  1 bit\n\n         Acknowledgment field is significant.\n\n     PSH:  1 bit\n\n         Push function (see the Send Call description in Section 3.9.1).\n\n     RST:  1 bit\n\n         Reset the connection.\n\n     SYN:  1 bit\n\n         Synchronize sequence numbers.\n\n     FIN:  1 bit\n\n         No more data from sender.\n\n   Window:  16 bits\n\n     The number of datb"the sender of this segment is willing to\n     accept.  The value is shifted when the window scaling extension is\n     used [47].\n\n     The window size MUST be treated as an unsigned number, or else\n     large window sizes will appear like negative windows and TCP will\n     not work (MUST-1).  It is RECOMMENDED that implementations will\n     reserve 32-bit fields for the send and receive window sizes in the\n     connection record and do all window computations with 32 bits (REC-\n     1).\n\n   Checksum:  16 bits\n\n     The checksum field is the 16-bit ones' complement of the ones'\n     complement sum of all 16-bit words in the header and text.  The\n     checksum computation needs to ensure the 16-bit alignment of the\n     data being summed.  If a segment contains an odd number of header\n     and text octets, alignment can be achieved by padding the last\n     octet with zeros on its right to form a 16-bit word for checksum\n     purposes.  The pad is not transmb'checksum, the checksum field itself is replaced\n     with zeros.\n\n     The checksum also covers a pseudo-header (Figure 2) conceptually\n     prefixed to the TCP header.  The pseudo-header is 96 bits for IPv4\n     and 320 bits for IPv6.  Including the pseudo-header in the checksum\n     gives the TCP connection protection against misrouted segments.\n     This information is carried in IP headers and is transferred across\n     the TCP/network interface in the arguments or results of calls by\n     the TCP implementation on the IP layer.\n\n                     +--------+--------+--------+--------+\n                     |           Source Address          |\n                     +--------+--------+--------+--------+\n                     |         Destination Address       |\n                     +--------+--------+--------+--------+\n                     |  zero  |  PTCL  |    TCP Length   |\n                     +--------+--------+--------+--------+\n\n               b'der components for IPv4:\n       Source Address:  the IPv4 source address in network byte order\n\n       Destination Address:  the IPv4 destination address in network\n          byte order\n\n       zero:  bits set to zero\n\n       PTCL:  the protocol number from the IP header\n\n       TCP Length:  the TCP header length plus the data length in octets\n          (this is not an explicitly transmitted quantity but is\n          computed), and it does not count the 12 octets of the pseudo-\n          header.\n\n     For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200\n     [13] and contains the IPv6 Source Address and Destination Address,\n     an Upper-Layer Packet Length (a 32-bit value otherwise equivalent\n     to TCP Length in the IPv4 pseudo-header), three bytes of zero\n     padding, and a Next Header value, which differs from the IPv6\n     header value if there are extension headers present between IPv6\n     and TCP.\n\n     The TCP checksum is neverb'he receiver MUST check it (MUST-3).\n\n   Urgent Pointer:  16 bits\n\n     This field communicates the current value of the urgent pointer as\n     a positive offset from the sequence number in this segment.  The\n     urgent pointer points to the sequence number of the octet following\n     the urgent data.  This field is only to be interpreted in segments\n     with the URG control bit set.\n\n   Options:  [TCP Option]; size(Options) == (DOffset-5)*32; present only\n     when DOffset > 5.  Note that this size expression also includes any\n     padding trailing the actual options present.\n\n     Options may occupy space at the end of the TCP header and are a\n     multiple of 8 bits in length.  All options are included in the\n     checksum.  An option may begin on any octet boundary.  There are\n     two cases for the format of an option:\n\n     Case 1:  A single octet of option-kind.\n\n     Case 2:  An octet of option-kind (Kind), an octet of option-length,\n        ab'counts the two octets of option-kind and option-\n     length as well as the option-data octets.\n\n     Note that the list of options may be shorter than the Data Offset\n     field might imply.  The content of the header beyond the End of\n     Option List Option MUST be header padding of zeros (MUST-69).\n\n     The list of all currently defined options is managed by IANA [62],\n     and each option is defined in other RFCs, as indicated there.  That\n     set includes experimental options that can be extended to support\n     multiple concurrent usages [45].\n\n     A given TCP implementation can support any currently defined\n     options, but the following options MUST be supported (MUST-4 --\n     note Maximum Segment Size Option support is also part of MUST-14 in\n     Section 3.7.1):\n\n               +======+========+============================+\n               | Kind | Length | Meaning                    |\n               +======+========+=======================b'ist Option. |\n               +------+--------+----------------------------+\n               | 1    | -      | No-Operation.              |\n               +------+--------+----------------------------+\n               | 2    | 4      | Maximum Segment Size.      |\n               +------+--------+----------------------------+\n\n                       Table 1: Mandatory Option Set\n\n     These options are specified in detail in Section 3.2.\n\n     A TCP implementation MUST be able to receive a TCP Option in any\n     segment (MUST-5).\n\n     A TCP implementation MUST (MUST-6) ignore without error any TCP\n     Option it does not implement, assuming that the option has a length\n     field.  All TCP Options except End of Option List Option (EOL) and\n     No-Operation (NOP) MUST have length fields, including all future\n     options (MUST-68).  TCP implementations MUST be prepared to handle\n     an illegal option length (e.g., zero); a suggested procedure is to\n     reb'   Note: There is ongoing work to extend the space available for TCP\n     Options, such as [65].\n\n   Data:  variable length\n\n     User data carried by the TCP segment.\n\n3.2.  Specific Option Definitions\n\n   A TCP Option, in the mandatory option set, is one of an End of Option\n   List Option, a No-Operation Option, or a Maximum Segment Size Option.\n\n   An End of Option List Option is formatted as follows:\n\n       0\n       0 1 2 3 4 5 6 7\n      +-+-+-+-+-+-+-+-+\n      |       0       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 0.\n\n     This option code indicates the end of the option list.  This might\n     not coincide with the end of the TCP header according to the Data\n     Offset field.  This is used at the end of all options, not the end\n     of each option, and need only be used if the end of the options\n     would not otherwise coincide with the end of the TCP header.\n\n   A No-Operation Option is formatted as follows:\n\b'   1       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 1.\n\n     This option code can be used between options, for example, to align\n     the beginning of a subsequent option on a word boundary.  There is\n     no guarantee that senders will use this option, so receivers MUST\n     be prepared to process options even if they do not begin on a word\n     boundary (MUST-64).\n\n   A Maximum Segment Size Option is formatted as follows:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |       2       |     Length    |   Maximum Segment Size (MSS)  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 2.\n\n     If this option is present, then it communicates the maximum receive\n     segment size at the TCP endpoint tb'reassembly limit.  This field may be\n     sent in the initial connection request (i.e., in segments with the\n     SYN control bit set) and MUST NOT be sent in other segments (MUST-\n     65).  If this option is not used, any segment size is allowed.  A\n     more complete description of this option is provided in\n     Section 3.7.1.\n\n   Length:  1 byte; Length == 4.\n\n     Length of the option in bytes.\n\n   Maximum Segment Size (MSS):  2 bytes.\n\n     The maximum receive segment size at the TCP endpoint that sends\n     this segment.\n\n3.2.1.  Other Common Options\n\n   Additional RFCs define some other commonly used options that are\n   recommended to implement for high performance but are not necessary\n   for basic TCP interoperability.  These are the TCP Selective\n   Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option\n   [47], and TCP Window Scale (WS) Option [47].\n\n3.2.2.  Experimental TCP Options\n\n   Experimental TCP Option values are defb"age for these experimental\n   values.\n\n3.3.  TCP Terminology Overview\n\n   This section includes an overview of key terms needed to understand\n   the detailed protocol operation in the rest of the document.  There\n   is a glossary of terms in Section 4.\n\n3.3.1.  Key Connection State Variables\n\n   Before we can discuss the operation of the TCP implementation in\n   detail, we need to introduce some detailed terminology.  The\n   maintenance of a TCP connection requires maintaining state for\n   several variables.  We conceive of these variables being stored in a\n   connection record called a Transmission Control Block or TCB.  Among\n   the variables stored in the TCB are the local and remote IP addresses\n   and port numbers, the IP security level, and compartment of the\n   connection (see Appendix A.1), pointers to the user's send and\n   receive buffers, pointers to the retransmit queue and to the current\n   segment.  In addition, several variables relating tb' the TCB.\n\n    +==========+=====================================================+\n    | Variable | Description                                         |\n    +==========+=====================================================+\n    | SND.UNA  | send unacknowledged                                 |\n    +----------+-----------------------------------------------------+\n    | SND.NXT  | send next                                           |\n    +----------+-----------------------------------------------------+\n    | SND.WND  | send window                                         |\n    +----------+-----------------------------------------------------+\n    | SND.UP   | send urgent pointer                                 |\n    +----------+-----------------------------------------------------+\n    | SND.WL1  | segment sequence number used for last window update |\n    +----------+-----------------------------------------------------+\n    | SND.WL2  | segment acknowledgmentb'date                                              |\n    +----------+-----------------------------------------------------+\n    | ISS      | initial send sequence number                        |\n    +----------+-----------------------------------------------------+\n\n                     Table 2: Send Sequence Variables\n\n              +==========+=================================+\n              | Variable | Description                     |\n              +==========+=================================+\n              | RCV.NXT  | receive next                    |\n              +----------+---------------------------------+\n              | RCV.WND  | receive window                  |\n              +----------+---------------------------------+\n              | RCV.UP   | receive urgent pointer          |\n              +----------+---------------------------------+\n              | IRS      | initial receive sequence number |\n              +----------+--------------b'eive Sequence Variables\n\n   The following diagrams may help to relate some of these variables to\n   the sequence space.\n\n                      1         2          3          4\n                 ----------|----------|----------|----------\n                        SND.UNA    SND.NXT    SND.UNA\n                                             +SND.WND\n\n           1 - old sequence numbers that have been acknowledged\n           2 - sequence numbers of unacknowledged data\n           3 - sequence numbers allowed for new data transmission\n           4 - future sequence numbers that are not yet allowed\n\n                       Figure 3: Send Sequence Space\n\n   The send window is the portion of the sequence space labeled 3 in\n   Figure 3.\n\n                          1          2          3\n                      ----------|----------|----------\n                             RCV.NXT    RCV.NXT\n                                       +RCV.WND\n\n           1 - old sequenceb'numbers allowed for new reception\n           3 - future sequence numbers that are not yet allowed\n\n                      Figure 4: Receive Sequence Space\n\n   The receive window is the portion of the sequence space labeled 2 in\n   Figure 4.\n\n   There are also some variables used frequently in the discussion that\n   take their values from the fields of the current segment.\n\n               +==========+===============================+\n               | Variable | Description                   |\n               +==========+===============================+\n               | SEG.SEQ  | segment sequence number       |\n               +----------+-------------------------------+\n               | SEG.ACK  | segment acknowledgment number |\n               +----------+-------------------------------+\n               | SEG.LEN  | segment length                |\n               +----------+-------------------------------+\n               | SEG.WND  | segment window           b'---------+\n               | SEG.UP   | segment urgent pointer        |\n               +----------+-------------------------------+\n\n                    Table 4: Current Segment Variables\n\n3.3.2.  State Machine Overview\n\n   A connection progresses through a series of states during its\n   lifetime.  The states are: LISTEN, SYN-SENT, SYN-RECEIVED,\n   ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,\n   TIME-WAIT, and the fictional state CLOSED.  CLOSED is fictional\n   because it represents the state when there is no TCB, and therefore,\n   no connection.  Briefly the meanings of the states are:\n\n   LISTEN -  represents waiting for a connection request from any remote\n      TCP peer and port.\n\n   SYN-SENT -  represents waiting for a matching connection request\n      after having sent a connection request.\n\n   SYN-RECEIVED -  represents waiting for a confirming connection\n      request acknowledgment after having both received and sent a\n b'pen connection, data received can be\n      delivered to the user.  The normal state for the data transfer\n      phase of the connection.\n\n   FIN-WAIT-1 -  represents waiting for a connection termination request\n      from the remote TCP peer, or an acknowledgment of the connection\n      termination request previously sent.\n\n   FIN-WAIT-2 -  represents waiting for a connection termination request\n      from the remote TCP peer.\n\n   CLOSE-WAIT -  represents waiting for a connection termination request\n      from the local user.\n\n   CLOSING -  represents waiting for a connection termination request\n      acknowledgment from the remote TCP peer.\n\n   LAST-ACK -  represents waiting for an acknowledgment of the\n      connection termination request previously sent to the remote TCP\n      peer (this termination request sent to the remote TCP peer already\n      included an acknowledgment of the termination request sent from\n      the remote TCP peer).\n\n   TIME-b're\n      the remote TCP peer received the acknowledgment of its connection\n      termination request and to avoid new connections being impacted by\n      delayed segments from previous connections.\n\n   CLOSED -  represents no connection state at all.\n\n   A TCP connection progresses from one state to another in response to\n   events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,\n   ABORT, and STATUS; the incoming segments, particularly those\n   containing the SYN, ACK, RST, and FIN flags; and timeouts.\n\n   The OPEN call specifies whether connection establishment is to be\n   actively pursued, or to be passively waited for.\n\n   A passive OPEN request means that the process wants to accept\n   incoming connection requests, in contrast to an active OPEN\n   attempting to initiate a connection.\n\n   The state diagram in Figure 5 illustrates only state changes,\n   together with the causing events and resulting actions, but addresses\n   neither errorb'ate changes.  In a later section, more detail is offered with\n   respect to the reaction of the TCP implementation to events.  Some\n   state names are abbreviated or hyphenated differently in the diagram\n   from how they appear elsewhere in the document.\n\n   NOTA BENE:  This diagram is only a summary and must not be taken as\n      the total specification.  Many details are not included.\n\n                               +---------+ ---------\\      active OPEN\n                               |  CLOSED |            \\    -----------\n                               +---------+<---------\\   \\   create TCB\n                                 |     ^              \\   \\  snd SYN\n                    passive OPEN |     |   CLOSE        \\   \\\n                    ------------ |     | ----------       \\   \\\n                     create TCB  |     | delete TCB         \\   \\\n                                 V     |                      \\   \\\n             rcv RST (notb'--------->|  LISTEN |          ---------- |     |\n         /                     +---------+          delete TCB |     |\n        /           rcv SYN      |     |     SEND              |     |\n       /           -----------   |     |    -------            |     V\n   +--------+      snd SYN,ACK  /       \\   snd SYN          +--------+\n   |        |<-----------------           ------------------>|        |\n   |  SYN   |                    rcv SYN                     |  SYN   |\n   |  RCVD  |<-----------------------------------------------|  SENT  |\n   |        |                  snd SYN,ACK                   |        |\n   |        |------------------           -------------------|        |\n   +--------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +--------+\n      |         --------------   |     |   -----------\n      |                x         |     |     snd ACK\n      |                          V     V\n      |  CLOSE                 +---------+\n      | ----b'         +---------+\n      |                 CLOSE    |     |    rcv FIN\n      V                -------   |     |    -------\n   +---------+         snd FIN  /       \\   snd ACK         +---------+\n   |  FIN    |<----------------          ------------------>|  CLOSE  |\n   | WAIT-1  |------------------                            |   WAIT  |\n   +---------+          rcv FIN  \\                          +---------+\n     | rcv ACK of FIN   -------   |                          CLOSE  |\n     | --------------   snd ACK   |                         ------- |\n     V        x                   V                         snd FIN V\n   +---------+               +---------+                    +---------+\n   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|\n   +---------+               +---------+                    +---------+\n     |              rcv ACK of FIN |                 rcv ACK of FIN |\n     |  rcv FIN     -------------- |    Timeout=2MSL ----------b'-------        x       V\n      \\ snd ACK              +---------+delete TCB          +---------+\n        -------------------->|TIME-WAIT|------------------->| CLOSED  |\n                             +---------+                    +---------+\n\n                   Figure 5: TCP Connection State Diagram\n\n   The following notes apply to Figure 5:\n\n   Note 1:  The transition from SYN-RECEIVED to LISTEN on receiving a\n      RST is conditional on having reached SYN-RECEIVED after a passive\n      OPEN.\n\n   Note 2:  The figure omits a transition from FIN-WAIT-1 to TIME-WAIT\n      if a FIN is received and the local FIN is also acknowledged.\n\n   Note 3:  A RST can be sent from any state with a corresponding\n      transition to TIME-WAIT (see [70] for rationale).  These\n      transitions are not explicitly shown; otherwise, the diagram would\n      become very difficult to read.  Similarly, receipt of a RST from\n      any state results in a transition to LISTEN or CLOb'or legibility.\n\n3.4.  Sequence Numbers\n\n   A fundamental notion in the design is that every octet of data sent\n   over a TCP connection has a sequence number.  Since every octet is\n   sequenced, each of them can be acknowledged.  The acknowledgment\n   mechanism employed is cumulative so that an acknowledgment of\n   sequence number X indicates that all octets up to but not including X\n   have been received.  This mechanism allows for straightforward\n   duplicate detection in the presence of retransmission.  The numbering\n   scheme of octets within a segment is as follows: the first data octet\n   immediately following the header is the lowest numbered, and the\n   following octets are numbered consecutively.\n\n   It is essential to remember that the actual sequence number space is\n   finite, though large.  This space ranges from 0 to 2^32 - 1.  Since\n   the space is finite, all arithmetic dealing with sequence numbers\n   must be performed modulo 2^32.  This unb'uence numbers as they cycle from 2^32 - 1 to 0\n   again.  There are some subtleties to computer modulo arithmetic, so\n   great care should be taken in programming the comparison of such\n   values.  The symbol "=<" means "less than or equal" (modulo 2^32).\n\n   The typical kinds of sequence number comparisons that the TCP\n   implementation must perform include:\n\n   (a)  Determining that an acknowledgment refers to some sequence\n        number sent but not yet acknowledged.\n\n   (b)  Determining that all sequence numbers occupied by a segment have\n        been acknowledged (e.g., to remove the segment from a\n        retransmission queue).\n\n   (c)  Determining that an incoming segment contains sequence numbers\n        that are expected (i.e., that the segment "overlaps" the receive\n        window).\n\n   In response to sending data, the TCP endpoint will receive\n   acknowledgments.  The following comparisons are needed to process the\n   acknowledgments:\n\n   b'ND.NXT = next sequence number to be sent\n\n      SEG.ACK = acknowledgment from the receiving TCP peer (next\n      sequence number expected by the receiving TCP peer)\n\n      SEG.SEQ = first sequence number of a segment\n\n      SEG.LEN = the number of octets occupied by the data in the segment\n      (counting SYN and FIN)\n\n      SEG.SEQ+SEG.LEN-1 = last sequence number of a segment\n\n   A new acknowledgment (called an "acceptable ack") is one for which\n   the inequality below holds:\n\n      SND.UNA < SEG.ACK =< SND.NXT\n\n   A segment on the retransmission queue is fully acknowledged if the\n   sum of its sequence number and length is less than or equal to the\n   acknowledgment value in the incoming segment.\n\n   When data is received, the following comparisons are needed:\n\n      RCV.NXT = next sequence number expected on an incoming segment,\n      and is the left or lower edge of the receive window\n\n      RCV.NXT+RCV.WND-1 = last sequence number expected onb'the receive window\n\n      SEG.SEQ = first sequence number occupied by the incoming segment\n\n      SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming\n      segment\n\n   A segment is judged to occupy a portion of valid receive sequence\n   space if\n\n      RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n\n   or\n\n      RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND\n\n   The first part of this test checks to see if the beginning of the\n   segment falls in the window, the second part of the test checks to\n   see if the end of the segment falls in the window; if the segment\n   passes either part of the test, it contains data in the window.\n\n   Actually, it is a little more complicated than this.  Due to zero\n   windows and zero-length segments, we have four cases for the\n   acceptability of an incoming segment:\n\n       +=========+=========+======================================+\n       | Segment | Receive | Test                                 |\n       |b'    +=========+=========+======================================+\n       | 0       | 0       | SEG.SEQ = RCV.NXT                    |\n       +---------+---------+--------------------------------------+\n       | 0       | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |\n       +---------+---------+--------------------------------------+\n       | >0      | 0       | not acceptable                       |\n       +---------+---------+--------------------------------------+\n       | >0      | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |\n       |         |         |                                      |\n       |         |         | or                                   |\n       |         |         |                                      |\n       |         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1 <       |\n       |         |         | RCV.NXT+RCV.WND                      |\n       +---------+---------+--------------------------------------+\n\n                   Tablb' the receive window is zero no segments should be\n   acceptable except ACK segments.  Thus, it is possible for a TCP\n   implementation to maintain a zero receive window while transmitting\n   data and receiving ACKs.  A TCP receiver MUST process the RST and URG\n   fields of all incoming segments, even when the receive window is zero\n   (MUST-66).\n\n   We have taken advantage of the numbering scheme to protect certain\n   control information as well.  This is achieved by implicitly\n   including some control flags in the sequence space so they can be\n   retransmitted and acknowledged without confusion (i.e., one and only\n   one copy of the control will be acted upon).  Control information is\n   not physically carried in the segment data space.  Consequently, we\n   must adopt rules for implicitly assigning sequence numbers to\n   control.  The SYN and FIN are the only controls requiring this\n   protection, and these controls are used only at connection opening\n   ab's considered to\n   occur before the first actual data octet of the segment in which it\n   occurs, while the FIN is considered to occur after the last actual\n   data octet in a segment in which it occurs.  The segment length\n   (SEG.LEN) includes both data and sequence space-occupying controls.\n   When a SYN is present, then SEG.SEQ is the sequence number of the\n   SYN.\n\n3.4.1.  Initial Sequence Number Selection\n\n   A connection is defined by a pair of sockets.  Connections can be\n   reused.  New instances of a connection will be referred to as\n   incarnations of the connection.  The problem that arises from this is\n   -- "how does the TCP implementation identify duplicate segments from\n   previous incarnations of the connection?"  This problem becomes\n   apparent if the connection is being opened and closed in quick\n   succession, or if the connection breaks with loss of memory and is\n   then reestablished.  To support this, the TIME-WAIT state limits the\nb'e number selection\n   described below further protects against ambiguity about which\n   incarnation of a connection an incoming packet corresponds to.\n\n   To avoid confusion, we must prevent segments from one incarnation of\n   a connection from being used while the same sequence numbers may\n   still be present in the network from an earlier incarnation.  We want\n   to assure this even if a TCP endpoint loses all knowledge of the\n   sequence numbers it has been using.  When new connections are\n   created, an initial sequence number (ISN) generator is employed that\n   selects a new 32-bit ISN.  There are security issues that result if\n   an off-path attacker is able to predict or guess ISN values [42].\n\n   TCP initial sequence numbers are generated from a number sequence\n   that monotonically increases until it wraps, known loosely as a\n   "clock".  This clock is a 32-bit counter that typically increments at\n   least once every roughly 4 microseconds, althoughb', and need not persist across\n   reboots.  The clock component is intended to ensure that with a\n   Maximum Segment Lifetime (MSL), generated ISNs will be unique since\n   it cycles approximately every 4.55 hours, which is much longer than\n   the MSL.  Please note that for modern networks that support high data\n   rates where the connection might start and quickly advance sequence\n   numbers to overlap within the MSL, it is recommended to implement the\n   Timestamp Option as mentioned later in Section 3.4.3.\n\n   A TCP implementation MUST use the above type of "clock" for clock-\n   driven selection of initial sequence numbers (MUST-8), and SHOULD\n   generate its initial sequence numbers with the expression:\n\n   ISN = M + F(localip, localport, remoteip, remoteport, secretkey)\n\n   where M is the 4 microsecond timer, and F() is a pseudorandom\n   function (PRF) of the connection\'s identifying parameters ("localip,\n   localport, remoteip, remoteport") and a secreb'utable from the outside (MUST-9), or\n   an attacker could still guess at sequence numbers from the ISN used\n   for some other connection.  The PRF could be implemented as a\n   cryptographic hash of the concatenation of the TCP connection\n   parameters and some secret data.  For discussion of the selection of\n   a specific hash algorithm and management of the secret key data,\n   please see Section 3 of [42].\n\n   For each connection there is a send sequence number and a receive\n   sequence number.  The initial send sequence number (ISS) is chosen by\n   the data sending TCP peer, and the initial receive sequence number\n   (IRS) is learned during the connection-establishing procedure.\n\n   For a connection to be established or initialized, the two TCP peers\n   must synchronize on each other\'s initial sequence numbers.  This is\n   done in an exchange of connection-establishing segments carrying a\n   control bit called "SYN" (for synchronize) and the initial sequeb'e SYN bit are also\n   called "SYNs".  Hence, the solution requires a suitable mechanism for\n   picking an initial sequence number and a slightly involved handshake\n   to exchange the ISNs.\n\n   The synchronization requires each side to send its own initial\n   sequence number and to receive a confirmation of it in acknowledgment\n   from the remote TCP peer.  Each side must also receive the remote\n   peer\'s initial sequence number and send a confirming acknowledgment.\n\n       1) A --> B  SYN my sequence number is X\n       2) A <-- B  ACK your sequence number is X\n       3) A <-- B  SYN my sequence number is Y\n       4) A --> B  ACK your sequence number is Y\n\n   Because steps 2 and 3 can be combined in a single message this is\n   called the three-way (or three message) handshake (3WHS).\n\n   A 3WHS is necessary because sequence numbers are not tied to a global\n   clock in the network, and TCP implementations may have different\n   mechanisms for picking the Ib'ing whether the segment was an old one or not, unless\n   it remembers the last sequence number used on the connection (which\n   is not always possible), and so it must ask the sender to verify this\n   SYN.  The three-way handshake and the advantages of a clock-driven\n   scheme for ISN selection are discussed in [69].\n\n3.4.2.  Knowing When to Keep Quiet\n\n   A theoretical problem exists where data could be corrupted due to\n   confusion between old segments in the network and new ones after a\n   host reboots if the same port numbers and sequence space are reused.\n   The "quiet time" concept discussed below addresses this, and the\n   discussion of it is included for situations where it might be\n   relevant, although it is not felt to be necessary in most current\n   implementations.  The problem was more relevant earlier in the\n   history of TCP.  In practical use on the Internet today, the error-\n   prone conditions are sufficiently unlikely that it is safe to ib'(a) ISS and ephemeral port\n   randomization have reduced likelihood of reuse of port numbers and\n   sequence numbers after reboots, (b) the effective MSL of the Internet\n   has declined as links have become faster, and (c) reboots often\n   taking longer than an MSL anyways.\n\n   To be sure that a TCP implementation does not create a segment\n   carrying a sequence number that may be duplicated by an old segment\n   remaining in the network, the TCP endpoint must keep quiet for an MSL\n   before assigning any sequence numbers upon starting up or recovering\n   from a situation where memory of sequence numbers in use was lost.\n   For this specification the MSL is taken to be 2 minutes.  This is an\n   engineering choice, and may be changed if experience indicates it is\n   desirable to do so.  Note that if a TCP endpoint is reinitialized in\n   some sense, yet retains its memory of sequence numbers in use, then\n   it need not wait at all; it must only be sure to use seb'\n3.4.3.  The TCP Quiet Time Concept\n\n   Hosts that for any reason lose knowledge of the last sequence numbers\n   transmitted on each active (i.e., not closed) connection shall delay\n   emitting any TCP segments for at least the agreed MSL in the internet\n   system that the host is a part of.  In the paragraphs below, an\n   explanation for this specification is given.  TCP implementers may\n   violate the "quiet time" restriction, but only at the risk of causing\n   some old data to be accepted as new or new data rejected as old\n   duplicated data by some receivers in the internet system.\n\n   TCP endpoints consume sequence number space each time a segment is\n   formed and entered into the network output queue at a source host.\n   The duplicate detection and sequencing algorithm in TCP relies on the\n   unique binding of segment data to sequence space to the extent that\n   sequence numbers will not cycle through all 2^32 values before the\n   segment data bound tb'knowledged by the receiver and all duplicate copies of the segments\n   have "drained" from the internet.  Without such an assumption, two\n   distinct TCP segments could conceivably be assigned the same or\n   overlapping sequence numbers, causing confusion at the receiver as to\n   which data is new and which is old.  Remember that each segment is\n   bound to as many consecutive sequence numbers as there are octets of\n   data and SYN or FIN flags in the segment.\n\n   Under normal conditions, TCP implementations keep track of the next\n   sequence number to emit and the oldest awaiting acknowledgment so as\n   to avoid mistakenly reusing a sequence number before its first use\n   has been acknowledged.  This alone does not guarantee that old\n   duplicate data is drained from the net, so the sequence space has\n   been made large to reduce the probability that a wandering duplicate\n   will cause trouble upon arrival.  At 2 megabits/sec., it takes 4.5\n   hours to use ub'\n   segment lifetime in the net is not likely to exceed a few tens of\n   seconds, this is deemed ample protection for foreseeable nets, even\n   if data rates escalate to 10s of megabits/sec.  At 100 megabits/sec.,\n   the cycle time is 5.4 minutes, which may be a little short but still\n   within reason.  Much higher data rates are possible today, with\n   implications described in the final paragraph of this subsection.\n\n   The basic duplicate detection and sequencing algorithm in TCP can be\n   defeated, however, if a source TCP endpoint does not have any memory\n   of the sequence numbers it last used on a given connection.  For\n   example, if the TCP implementation were to start all connections with\n   sequence number 0, then upon the host rebooting, a TCP peer might re-\n   form an earlier connection (possibly after half-open connection\n   resolution) and emit packets with sequence numbers identical to or\n   overlapping with packets still in the network, whichb'ame connection.  In the absence of\n   knowledge about the sequence numbers used on a particular connection,\n   the TCP specification recommends that the source delay for MSL\n   seconds before emitting segments on the connection, to allow time for\n   segments from the earlier connection incarnation to drain from the\n   system.\n\n   Even hosts that can remember the time of day and use it to select\n   initial sequence number values are not immune from this problem\n   (i.e., even if time of day is used to select an initial sequence\n   number for each new connection incarnation).\n\n   Suppose, for example, that a connection is opened starting with\n   sequence number S.  Suppose that this connection is not used much and\n   that eventually the initial sequence number function (ISN(t)) takes\n   on a value equal to the sequence number, say S1, of the last segment\n   sent by this TCP endpoint on a particular connection.  Now suppose,\n   at this instant, the host rebootb'ion.  The initial sequence number chosen is S1 = ISN(t)\n   -- last used sequence number on old incarnation of connection!  If\n   the recovery occurs quickly enough, any old duplicates in the net\n   bearing sequence numbers in the neighborhood of S1 may arrive and be\n   treated as new packets by the receiver of the new incarnation of the\n   connection.\n\n   The problem is that the recovering host may not know for how long it\n   was down between rebooting nor does it know whether there are still\n   old duplicates in the system from earlier connection incarnations.\n\n   One way to deal with this problem is to deliberately delay emitting\n   segments for one MSL after recovery from a reboot -- this is the\n   "quiet time" specification.  Hosts that prefer to avoid waiting and\n   are willing to risk possible confusion of old and new packets at a\n   given destination may choose not to wait for the "quiet time".\n   Implementers may provide TCP users with the ability tob'er to wait after a reboot, or may\n   informally implement the "quiet time" for all connections.\n   Obviously, even where a user selects to "wait", this is not necessary\n   after the host has been "up" for at least MSL seconds.\n\n   To summarize: every segment emitted occupies one or more sequence\n   numbers in the sequence space, and the numbers occupied by a segment\n   are "busy" or "in use" until MSL seconds have passed.  Upon\n   rebooting, a block of space-time is occupied by the octets and SYN or\n   FIN flags of any potentially still in-flight segments.  If a new\n   connection is started too soon and uses any of the sequence numbers\n   in the space-time footprint of those potentially still in-flight\n   segments of the previous connection incarnation, there is a potential\n   sequence number overlap area that could cause confusion at the\n   receiver.\n\n   High-performance cases will have shorter cycle times than those in\n   the megabits per second that the b'bps, the cycle time is 34 seconds, only 3 seconds\n   at 10 Gbps, and around a third of a second at 100 Gbps.  In these\n   higher-performance cases, TCP Timestamp Options and Protection\n   Against Wrapped Sequences (PAWS) [47] provide the needed capability\n   to detect and discard old duplicates.\n\n3.5.  Establishing a Connection\n\n   The "three-way handshake" is the procedure used to establish a\n   connection.  This procedure normally is initiated by one TCP peer and\n   responded to by another TCP peer.  The procedure also works if two\n   TCP peers simultaneously initiate the procedure.  When simultaneous\n   open occurs, each TCP peer receives a SYN segment that carries no\n   acknowledgment after it has sent a SYN.  Of course, the arrival of an\n   old duplicate SYN segment can potentially make it appear, to the\n   recipient, that a simultaneous connection initiation is in progress.\n   Proper use of "reset" segments can disambiguate these cases.\n\n   Several eb"se\n   examples do not show connection synchronization using data-carrying\n   segments, this is perfectly legitimate, so long as the receiving TCP\n   endpoint doesn't deliver the data to the user until it is clear the\n   data is valid (e.g., the data is buffered at the receiver until the\n   connection reaches the ESTABLISHED state, given that the three-way\n   handshake reduces the possibility of false connections).  It is a\n   trade-off between memory and messages to provide information for this\n   checking.\n\n   The simplest 3WHS is shown in Figure 6.  The figures should be\n   interpreted in the following way.  Each line is numbered for\n   reference purposes.  Right arrows (-->) indicate departure of a TCP\n   segment from TCP Peer A to TCP Peer B or arrival of a segment at B\n   from A.  Left arrows (<--) indicate the reverse.  Ellipses (...)\n   indicate a segment that is still in the network (delayed).  Comments\n   appear in parentheses.  TCP connection stateb'val of the segment (whose contents are\n   shown in the center of each line).  Segment contents are shown in\n   abbreviated form, with sequence number, control flags, and ACK field.\n   Other fields such as window, addresses, lengths, and text have been\n   left out in the interest of clarity.\n\n       TCP Peer A                                           TCP Peer B\n\n   1.  CLOSED                                               LISTEN\n\n   2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n\n   3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n   4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED\n\n   5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED\n\n     Figure 6: Basic Three-Way Handshake for Connection Synchronization\n\n   In line 2 of Figure 6, TCP Peer A begins by sending a SYN segment\n   indicating that it will use sequence numbers starting with sequence\n   number 100.  In line b"eceived from TCP Peer A.  Note that the acknowledgment field\n   indicates TCP Peer B is now expecting to hear sequence 101,\n   acknowledging the SYN that occupied sequence 100.\n\n   At line 4, TCP Peer A responds with an empty segment containing an\n   ACK for TCP Peer B's SYN; and in line 5, TCP Peer A sends some data.\n   Note that the sequence number of the segment in line 5 is the same as\n   in line 4 because the ACK does not occupy sequence number space (if\n   it did, we would wind up ACKing ACKs!).\n\n   Simultaneous initiation is only slightly more complex, as is shown in\n   Figure 7.  Each TCP peer's connection state cycles from CLOSED to\n   SYN-SENT to SYN-RECEIVED to ESTABLISHED.\n\n       TCP Peer A                                       TCP Peer B\n\n   1.  CLOSED                                           CLOSED\n\n   2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...\n\n   3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT\n\n   4.   b'CEIVED\n\n   5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...\n\n   6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED\n\n   7.               ... <SEQ=100><ACK=301><CTL=SYN,ACK> --> ESTABLISHED\n\n             Figure 7: Simultaneous Connection Synchronization\n\n   A TCP implementation MUST support simultaneous open attempts (MUST-\n   10).\n\n   Note that a TCP implementation MUST keep track of whether a\n   connection has reached SYN-RECEIVED state as the result of a passive\n   OPEN or an active OPEN (MUST-11).\n\n   The principal reason for the three-way handshake is to prevent old\n   duplicate connection initiations from causing confusion.  To deal\n   with this, a special control message, reset, is specified.  If the\n   receiving TCP peer is in a non-synchronized state (i.e., SYN-SENT,\n   SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.\n   If the TCP peer is in one of the synchronized states (ESTABLISHED,\n   FIN-WAIb' it\n   aborts the connection and informs its user.  We discuss this latter\n   case under "half-open" connections below.\n\n       TCP Peer A                                           TCP Peer B\n\n   1.  CLOSED                                               LISTEN\n\n   2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...\n\n   3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED\n\n   4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n   5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN\n\n   6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n\n   7.  ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n   8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED\n\n                 Figure 8: Recovery from Old Duplicate SYN\n\n   As a simple example of recovery from old duplicates, consider\n   Figure 8.  At line 3, an old duplicate SYN arrives at TCP Peer B.\n   TCP Peer b' normally (line 4).  TCP Peer A detects that the ACK field is\n   incorrect and returns a RST (reset) with its SEQ field selected to\n   make the segment believable.  TCP Peer B, on receiving the RST,\n   returns to the LISTEN state.  When the original SYN finally arrives\n   at line 6, the synchronization proceeds normally.  If the SYN at line\n   6 had arrived before the RST, a more complex exchange might have\n   occurred with RSTs sent in both directions.\n\n3.5.1.  Half-Open Connections and Other Anomalies\n\n   An established connection is said to be "half-open" if one of the TCP\n   peers has closed or aborted the connection at its end without the\n   knowledge of the other, or if the two ends of the connection have\n   become desynchronized owing to a failure or reboot that resulted in\n   loss of memory.  Such connections will automatically become reset if\n   an attempt is made to send data in either direction.  However, half-\n   open connections are expected to b'r exists, then an attempt by the\n   user at site B to send any data on it will result in the site B TCP\n   endpoint receiving a reset control message.  Such a message indicates\n   to the site B TCP endpoint that something is wrong, and it is\n   expected to abort the connection.\n\n   Assume that two user processes A and B are communicating with one\n   another when a failure or reboot occurs causing loss of memory to A\'s\n   TCP implementation.  Depending on the operating system supporting A\'s\n   TCP implementation, it is likely that some error recovery mechanism\n   exists.  When the TCP endpoint is up again, A is likely to start\n   again from the beginning or from a recovery point.  As a result, A\n   will probably try to OPEN the connection again or try to SEND on the\n   connection it believes open.  In the latter case, it receives the\n   error message "connection not open" from the local (A\'s) TCP\n   implementation.  In an attempt to establish the connectionb'ning SYN.  This scenario\n   leads to the example shown in Figure 9.  After TCP Peer A reboots,\n   the user attempts to reopen the connection.  TCP Peer B, in the\n   meantime, thinks the connection is open.\n\n         TCP Peer A                                      TCP Peer B\n\n     1.  (REBOOT)                              (send 300,receive 100)\n\n     2.  CLOSED                                           ESTABLISHED\n\n     3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)\n\n     4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED\n\n     5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)\n\n     6.  SYN-SENT                                         CLOSED\n\n     7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->\n\n                  Figure 9: Half-Open Connection Discovery\n\n   When the SYN arrives at line 3, TCP Peer B, being in a synchronized\n   state, and the incoming segment outside the window, responds with an\n   acknowledgb' 100).  TCP Peer A sees that this segment does not acknowledge\n   anything it sent and, being unsynchronized, sends a reset (RST)\n   because it has detected a half-open connection.  TCP Peer B aborts at\n   line 5.  TCP Peer A will continue to try to establish the connection;\n   the problem is now reduced to the basic three-way handshake of\n   Figure 6.\n\n   An interesting alternative case occurs when TCP Peer A reboots and\n   TCP Peer B tries to send data on what it thinks is a synchronized\n   connection.  This is illustrated in Figure 10.  In this case, the\n   data arriving at TCP Peer A from TCP Peer B (line 2) is unacceptable\n   because no such connection exists, so TCP Peer A sends a RST.  The\n   RST is acceptable so TCP Peer B processes it and aborts the\n   connection.\n\n         TCP Peer A                                         TCP Peer B\n\n   1.  (REBOOT)                                  (send 300,receive 100)\n\n   2.  (??)    <-- <SEQ=300><ACK=100><Db'EQ=100><CTL=RST>                   --> (ABORT!!)\n\n        Figure 10: Active Side Causes Half-Open Connection Discovery\n\n   In Figure 11, two TCP Peers A and B with passive connections waiting\n   for SYN are depicted.  An old duplicate arriving at TCP Peer B (line\n   2) stirs B into action.  A SYN-ACK is returned (line 3) and causes\n   TCP A to generate a RST (the ACK in line 3 is not acceptable).  TCP\n   Peer B accepts the reset and returns to its passive LISTEN state.\n\n       TCP Peer A                                    TCP Peer B\n\n   1.  LISTEN                                        LISTEN\n\n   2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED\n\n   3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED\n\n   4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)\n\n   5.  LISTEN                                        LISTEN\n\n   Figure 11: Old Duplicate SYN Initiates a Reset on Two Passive Sockets\n\n   A variety of otheb'he following rules for RST generation and processing.\n\n3.5.2.  Reset Generation\n\n   A TCP user or application can issue a reset on a connection at any\n   time, though reset events are also generated by the protocol itself\n   when various error conditions occur, as described below.  The side of\n   a connection issuing a reset should enter the TIME-WAIT state, as\n   this generally helps to reduce the load on busy servers for reasons\n   described in [70].\n\n   As a general rule, reset (RST) is sent whenever a segment arrives\n   that apparently is not intended for the current connection.  A reset\n   must not be sent if it is not clear that this is the case.\n\n   There are three groups of states:\n\n   1.  If the connection does not exist (CLOSED), then a reset is sent\n       in response to any incoming segment except another reset.  A SYN\n       segment that does not match an existing connection is rejected by\n       this means.\n\n       If the incoming segmentb'number from the ACK field of the segment; otherwise, the\n       reset has sequence number zero and the ACK field is set to the\n       sum of the sequence number and segment length of the incoming\n       segment.  The connection remains in the CLOSED state.\n\n   2.  If the connection is in any non-synchronized state (LISTEN, SYN-\n       SENT, SYN-RECEIVED), and the incoming segment acknowledges\n       something not yet sent (the segment carries an unacceptable ACK),\n       or if an incoming segment has a security level or compartment\n       (Appendix A.1) that does not exactly match the level and\n       compartment requested for the connection, a reset is sent.\n\n       If the incoming segment has an ACK field, the reset takes its\n       sequence number from the ACK field of the segment; otherwise, the\n       reset has sequence number zero and the ACK field is set to the\n       sum of the sequence number and segment length of the incoming\n       segment.  The cb'connection is in a synchronized state (ESTABLISHED, FIN-\n       WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),\n       any unacceptable segment (out-of-window sequence number or\n       unacceptable acknowledgment number) must be responded to with an\n       empty acknowledgment segment (without any user data) containing\n       the current send sequence number and an acknowledgment indicating\n       the next sequence number expected to be received, and the\n       connection remains in the same state.\n\n       If an incoming segment has a security level or compartment that\n       does not exactly match the level and compartment requested for\n       the connection, a reset is sent and the connection goes to the\n       CLOSED state.  The reset takes its sequence number from the ACK\n       field of the incoming segment.\n\n3.5.3.  Reset Processing\n\n   In all states except SYN-SENT, all reset (RST) segments are validated\n   by checking their SEQ fieldb'he window.  In the SYN-SENT state (a RST received in\n   response to an initial SYN), the RST is acceptable if the ACK field\n   acknowledges the SYN.\n\n   The receiver of a RST first validates it, then changes state.  If the\n   receiver was in the LISTEN state, it ignores it.  If the receiver was\n   in SYN-RECEIVED state and had previously been in the LISTEN state,\n   then the receiver returns to the LISTEN state; otherwise, the\n   receiver aborts the connection and goes to the CLOSED state.  If the\n   receiver was in any other state, it aborts the connection and advises\n   the user and goes to the CLOSED state.\n\n   TCP implementations SHOULD allow a received RST segment to include\n   data (SHLD-2).  It has been suggested that a RST segment could\n   contain diagnostic data that explains the cause of the RST.  No\n   standard has yet been established for such data.\n\n3.6.  Closing a Connection\n\n   CLOSE is an operation meaning "I have no more data to send."  Tb'ject to ambiguous\n   interpretation, of course, since it may not be obvious how to treat\n   the receiving side of the connection.  We have chosen to treat CLOSE\n   in a simplex fashion.  The user who CLOSEs may continue to RECEIVE\n   until the TCP receiver is told that the remote peer has CLOSED also.\n   Thus, a program could initiate several SENDs followed by a CLOSE, and\n   then continue to RECEIVE until signaled that a RECEIVE failed because\n   the remote peer has CLOSED.  The TCP implementation will signal a\n   user, even if no RECEIVEs are outstanding, that the remote peer has\n   closed, so the user can terminate their side gracefully.  A TCP\n   implementation will reliably deliver all buffers SENT before the\n   connection was CLOSED so a user who expects no data in return need\n   only wait to hear the connection was CLOSED successfully to know that\n   all their data was received at the destination TCP endpoint.  Users\n   must keep reading connections theb'n indicates there is no more data.\n\n   There are essentially three cases:\n\n   1)  The user initiates by telling the TCP implementation to CLOSE the\n       connection (TCP Peer A in Figure 12).\n\n   2)  The remote TCP endpoint initiates by sending a FIN control signal\n       (TCP Peer B in Figure 12).\n\n   3)  Both users CLOSE simultaneously (Figure 13).\n\n   Case 1:  Local user initiates the close\n\n      In this case, a FIN segment can be constructed and placed on the\n      outgoing segment queue.  No further SENDs from the user will be\n      accepted by the TCP implementation, and it enters the FIN-WAIT-1\n      state.  RECEIVEs are allowed in this state.  All segments\n      preceding and including FIN will be retransmitted until\n      acknowledged.  When the other TCP peer has both acknowledged the\n      FIN and sent a FIN of its own, the first TCP peer can ACK this\n      FIN.  Note that a TCP endpoint receiving a FIN will ACK but not\n      send its own b'e 2:  TCP endpoint receives a FIN from the network\n\n      If an unsolicited FIN arrives from the network, the receiving TCP\n      endpoint can ACK it and tell the user that the connection is\n      closing.  The user will respond with a CLOSE, upon which the TCP\n      endpoint can send a FIN to the other TCP peer after sending any\n      remaining data.  The TCP endpoint then waits until its own FIN is\n      acknowledged whereupon it deletes the connection.  If an ACK is\n      not forthcoming, after the user timeout the connection is aborted\n      and the user is told.\n\n   Case 3:  Both users close simultaneously\n\n      A simultaneous CLOSE by users at both ends of a connection causes\n      FIN segments to be exchanged (Figure 13).  When all segments\n      preceding the FINs have been processed and acknowledged, each TCP\n      peer can ACK the FIN it has received.  Both will, upon receiving\n      these ACKs, delete the connection.\n\n       TCP Peer A        b'STABLISHED                                          ESTABLISHED\n\n   2.  (Close)\n       FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT\n\n   3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT\n\n   4.                                                       (Close)\n       TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK\n\n   5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED\n\n   6.  (2 MSL)\n       CLOSED\n\n                      Figure 12: Normal Close Sequence\n\n       TCP Peer A                                           TCP Peer B\n\n   1.  ESTABLISHED                                          ESTABLISHED\n\n   2.  (Close)                                              (Close)\n       FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1\n                   <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--\n                   ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->\n\n   3.  CLOSING     --> <SEQ=101><ACK=301>b'K=101><CTL=ACK>      <--\n                   ... <SEQ=101><ACK=301><CTL=ACK>      -->\n\n   4.  TIME-WAIT                                            TIME-WAIT\n       (2 MSL)                                              (2 MSL)\n       CLOSED                                               CLOSED\n\n                   Figure 13: Simultaneous Close Sequence\n\n   A TCP connection may terminate in two ways: (1) the normal TCP close\n   sequence using a FIN handshake (Figure 12), and (2) an "abort" in\n   which one or more RST segments are sent and the connection state is\n   immediately discarded.  If the local TCP connection is closed by the\n   remote side due to a FIN or RST received from the remote side, then\n   the local application MUST be informed whether it closed normally or\n   was aborted (MUST-12).\n\n\n3.6.1.  Half-Closed Connections\n\n   The normal TCP close sequence delivers buffered data reliably in both\n   directions.  Since the two directions of a TCP conneb'onnection to be "half closed",\n   i.e., closed in only one direction, and a host is permitted to\n   continue sending data in the open direction on a half-closed\n   connection.\n\n   A host MAY implement a "half-duplex" TCP close sequence, so that an\n   application that has called CLOSE cannot continue to read data from\n   the connection (MAY-1).  If such a host issues a CLOSE call while\n   received data is still pending in the TCP connection, or if new data\n   is received after CLOSE is called, its TCP implementation SHOULD send\n   a RST to show that data was lost (SHLD-3).  See [23], Section 2.17\n   for discussion.\n\n   When a connection is closed actively, it MUST linger in the TIME-WAIT\n   state for a time 2xMSL (Maximum Segment Lifetime) (MUST-13).\n   However, it MAY accept a new SYN from the remote TCP endpoint to\n   reopen the connection directly from TIME-WAIT state (MAY-2), if it:\n\n   (1)  assigns its initial sequence number for the new connection to b'used on the previous\n        connection incarnation, and\n\n   (2)  returns to TIME-WAIT state if the SYN turns out to be an old\n        duplicate.\n\n   When the TCP Timestamp Options are available, an improved algorithm\n   is described in [40] in order to support higher connection\n   establishment rates.  This algorithm for reducing TIME-WAIT is a Best\n   Current Practice that SHOULD be implemented since Timestamp Options\n   are commonly used, and using them to reduce TIME-WAIT provides\n   benefits for busy Internet servers (SHLD-4).\n\n3.7.  Segmentation\n\n   The term "segmentation" refers to the activity TCP performs when\n   ingesting a stream of bytes from a sending application and\n   packetizing that stream of bytes into TCP segments.  Individual TCP\n   segments often do not correspond one-for-one to individual send (or\n   socket write) calls from the application.  Applications may perform\n   writes at the granularity of messages in the upper-layer protocb'ndaries of TCP\n   segments sent and received and the boundaries of the read or write\n   buffers of user application data.  In some specific protocols, such\n   as Remote Direct Memory Access (RDMA) using Direct Data Placement\n   (DDP) and Marker PDU Aligned Framing (MPA) [34], there are\n   performance optimizations possible when the relation between TCP\n   segments and application data units can be controlled, and MPA\n   includes a specific mechanism for detecting and verifying this\n   relationship between TCP segments and application message data\n   structures, but this is specific to applications like RDMA.  In\n   general, multiple goals influence the sizing of TCP segments created\n   by a TCP implementation.\n\n   Goals driving the sending of larger segments include:\n\n   *  Reducing the number of packets in flight within the network.\n\n   *  Increasing processing efficiency and potential performance by\n      enabling a smaller number of interrupts and interb'd of TCP headers.\n\n   Note that the performance benefits of sending larger segments may\n   decrease as the size increases, and there may be boundaries where\n   advantages are reversed.  For instance, on some implementation\n   architectures, 1025 bytes within a segment could lead to worse\n   performance than 1024 bytes, due purely to data alignment on copy\n   operations.\n\n   Goals driving the sending of smaller segments include:\n\n   *  Avoiding sending a TCP segment that would result in an IP datagram\n      larger than the smallest MTU along an IP network path because this\n      results in either packet loss or packet fragmentation.  Making\n      matters worse, some firewalls or middleboxes may drop fragmented\n      packets or ICMP messages related to fragmentation.\n\n   *  Preventing delays to the application data stream, especially when\n      TCP is waiting on the application to generate more data, or when\n      the application is waiting on an event or ib'.\n\n   *  Enabling "fate sharing" between TCP segments and lower-layer data\n      units (e.g., below IP, for links with cell or frame sizes smaller\n      than the IP MTU).\n\n   Towards meeting these competing sets of goals, TCP includes several\n   mechanisms, including the Maximum Segment Size Option, Path MTU\n   Discovery, the Nagle algorithm, and support for IPv6 Jumbograms, as\n   discussed in the following subsections.\n\n3.7.1.  Maximum Segment Size Option\n\n   TCP endpoints MUST implement both sending and receiving the MSS\n   Option (MUST-14).\n\n   TCP implementations SHOULD send an MSS Option in every SYN segment\n   when its receive MSS differs from the default 536 for IPv4 or 1220\n   for IPv6 (SHLD-5), and MAY send it always (MAY-3).\n\n   If an MSS Option is not received at connection setup, TCP\n   implementations MUST assume a default send MSS of 536 (576 - 40) for\n   IPv4 or 1220 (1280 - 60) for IPv6 (MUST-15).\n\n   The maximum size of a segment thab'MUST be the smaller (MUST-16) of the send MSS\n   (that reflects the available reassembly buffer size at the remote\n   host, the EMTU_R [19]) and the largest transmission size permitted by\n   the IP layer (EMTU_S [19]):\n\n   Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize\n\n   where:\n\n   *  SendMSS is the MSS value received from the remote host, or the\n      default 536 for IPv4 or 1220 for IPv6, if no MSS Option is\n      received.\n\n   *  MMS_S is the maximum size for a transport-layer message that TCP\n      may send.\n\n   *  TCPhdrsize is the size of the fixed TCP header and any options.\n      This is 20 in the (rare) case that no options are present but may\n      be larger if TCP Options are to be sent.  Note that some options\n      might not be included on all segments, but that for each segment\n      sent, the sender should adjust the data length accordingly, within\n      the Eff.snd.MSS.\n\n   *  IPoptionsize is the size of any IPv4 opb' connection.  Note that some options\n      or extension headers might not be included on all packets, but\n      that for each segment sent, the sender should adjust the data\n      length accordingly, within the Eff.snd.MSS.\n\n   The MSS value to be sent in an MSS Option should be equal to the\n   effective MTU minus the fixed IP and TCP headers.  By ignoring both\n   IP and TCP Options when calculating the value for the MSS Option, if\n   there are any IP or TCP Options to be sent in a packet, then the\n   sender must decrease the size of the TCP data accordingly.  RFC 6691\n   [43] discusses this in greater detail.\n\n   The MSS value to be sent in an MSS Option must be less than or equal\n   to:\n\n      MMS_R - 20\n\n   where MMS_R is the maximum size for a transport-layer message that\n   can be received (and reassembled at the IP layer) (MUST-67).  TCP\n   obtains MMS_R and MMS_S from the IP layer; see the generic call\n   GET_MAXSIZES in Section 3.4 of RFC 1122.  b's, EMTU_R and EMTU_S [19].\n\n   When TCP is used in a situation where either the IP or TCP headers\n   are not fixed, the sender must reduce the amount of TCP data in any\n   given packet by the number of octets used by the IP and TCP options.\n   This has been a point of confusion historically, as explained in RFC\n   6691, Section 3.1.\n\n3.7.2.  Path MTU Discovery\n\n   A TCP implementation may be aware of the MTU on directly connected\n   links, but will rarely have insight about MTUs across an entire\n   network path.  For IPv4, RFC 1122 recommends an IP-layer default\n   effective MTU of less than or equal to 576 for destinations not\n   directly connected, and for IPv6 this would be 1280.  Using these\n   fixed values limits TCP connection performance and efficiency.\n   Instead, implementation of Path MTU Discovery (PMTUD) and\n   Packetization Layer Path MTU Discovery (PLPMTUD) is strongly\n   recommended in order for TCP to improve segmentation decisions.  Both\nb" avoid both on-\n   path (for IPv4) and source fragmentation (IPv4 and IPv6).\n\n   PMTUD for IPv4 [2] or IPv6 [14] is implemented in conjunction between\n   TCP, IP, and ICMP.  It relies both on avoiding source fragmentation\n   and setting the IPv4 DF (don't fragment) flag, the latter to inhibit\n   on-path fragmentation.  It relies on ICMP errors from routers along\n   the path whenever a segment is too large to traverse a link.  Several\n   adjustments to a TCP implementation with PMTUD are described in RFC\n   2923 in order to deal with problems experienced in practice [27].\n   PLPMTUD [31] is a Standards Track improvement to PMTUD that relaxes\n   the requirement for ICMP support across a path, and improves\n   performance in cases where ICMP is not consistently conveyed, but\n   still tries to avoid source fragmentation.  The mechanisms in all\n   four of these RFCs are recommended to be included in TCP\n   implementations.\n\n   The TCP MSS Option specifies an uppeb'ed (see [43]).  Hence, setting the value in the MSS\n   Option too small can impact the ability for PMTUD or PLPMTUD to find\n   a larger path MTU.  RFC 1191 discusses this implication of many older\n   TCP implementations setting the TCP MSS to 536 (corresponding to the\n   IPv4 576 byte default MTU) for non-local destinations, rather than\n   deriving it from the MTUs of connected interfaces as recommended.\n\n3.7.3.  Interfaces with Variable MTU Values\n\n   The effective MTU can sometimes vary, as when used with variable\n   compression, e.g., RObust Header Compression (ROHC) [37].  It is\n   tempting for a TCP implementation to advertise the largest possible\n   MSS, to support the most efficient use of compressed payloads.\n   Unfortunately, some compression schemes occasionally need to transmit\n   full headers (and thus smaller payloads) to resynchronize state at\n   their endpoint compressors/decompressors.  If the largest MTU is used\n   to calculate the value to b'ay interfere with compressor resynchronization.\n\n   As a result, when the effective MTU of an interface varies packet-to-\n   packet, TCP implementations SHOULD use the smallest effective MTU of\n   the interface to calculate the value to advertise in the MSS Option\n   (SHLD-6).\n\n3.7.4.  Nagle Algorithm\n\n   The "Nagle algorithm" was described in RFC 896 [17] and was\n   recommended in RFC 1122 [19] for mitigation of an early problem of\n   too many small packets being generated.  It has been implemented in\n   most current TCP code bases, sometimes with minor variations (see\n   Appendix A.3).\n\n   If there is unacknowledged data (i.e., SND.NXT > SND.UNA), then the\n   sending TCP endpoint buffers all user data (regardless of the PSH\n   bit) until the outstanding data has been acknowledged or until the\n   TCP endpoint can send a full-sized segment (Eff.snd.MSS bytes).\n\n   A TCP implementation SHOULD implement the Nagle algorithm to coalesce\n   short segments (Sb'on to disable the Nagle algorithm on an individual\n   connection (MUST-17).  In all cases, sending data is also subject to\n   the limitation imposed by the slow start algorithm [8].\n\n   Since there can be problematic interactions between the Nagle\n   algorithm and delayed acknowledgments, some implementations use minor\n   variations of the Nagle algorithm, such as the one described in\n   Appendix A.3.\n\n3.7.5.  IPv6 Jumbograms\n\n   In order to support TCP over IPv6 Jumbograms, implementations need to\n   be able to send TCP segments larger than the 64-KB limit that the MSS\n   Option can convey.  RFC 2675 [24] defines that an MSS value of 65,535\n   bytes is to be treated as infinity, and Path MTU Discovery [14] is\n   used to determine the actual MSS.\n\n   The Jumbo Payload Option need not be implemented or understood by\n   IPv6 nodes that do not support attachment to links with an MTU\n   greater than 65,575 [24], and the present IPv6 Node Requirements does\n  b'mmunication\n\n   Once the connection is established, data is communicated by the\n   exchange of segments.  Because segments may be lost due to errors\n   (checksum test failure) or network congestion, TCP uses\n   retransmission to ensure delivery of every segment.  Duplicate\n   segments may arrive due to network or TCP retransmission.  As\n   discussed in the section on sequence numbers (Section 3.4), the TCP\n   implementation performs certain tests on the sequence and\n   acknowledgment numbers in the segments to verify their acceptability.\n\n   The sender of data keeps track of the next sequence number to use in\n   the variable SND.NXT.  The receiver of data keeps track of the next\n   sequence number to expect in the variable RCV.NXT.  The sender of\n   data keeps track of the oldest unacknowledged sequence number in the\n   variable SND.UNA.  If the data flow is momentarily idle and all data\n   sent has been acknowledged, then the three variables will be equal.\b"it, the sender\n   advances SND.NXT.  When the receiver accepts a segment, it advances\n   RCV.NXT and sends an acknowledgment.  When the data sender receives\n   an acknowledgment, it advances SND.UNA.  The extent to which the\n   values of these variables differ is a measure of the delay in the\n   communication.  The amount by which the variables are advanced is the\n   length of the data and SYN or FIN flags in the segment.  Note that,\n   once in the ESTABLISHED state, all segments must carry current\n   acknowledgment information.\n\n   The CLOSE user call implies a push function (see Section 3.9.1), as\n   does the FIN control flag in an incoming segment.\n\n3.8.1.  Retransmission Timeout\n\n   Because of the variability of the networks that compose an\n   internetwork system and the wide range of uses of TCP connections,\n   the retransmission timeout (RTO) must be dynamically determined.\n\n   The RTO MUST be computed according to the algorithm in [10],\n   includib'  RFC 793 contains an early example procedure for computing the RTO,\n   based on work mentioned in IEN 177 [71].  This was then replaced by\n   the algorithm described in RFC 1122, which was subsequently updated\n   in RFC 2988 and then again in RFC 6298.\n\n   RFC 1122 allows that if a retransmitted packet is identical to the\n   original packet (which implies not only that the data boundaries have\n   not changed, but also that none of the headers have changed), then\n   the same IPv4 Identification field MAY be used (see Section 3.2.1.5\n   of RFC 1122) (MAY-4).  The same IP Identification field may be reused\n   anyways since it is only meaningful when a datagram is fragmented\n   [44].  TCP implementations should not rely on or typically interact\n   with this IPv4 header field in any way.  It is not a reasonable way\n   to indicate duplicate sent segments nor to identify duplicate\n   received segments.\n\n3.8.2.  TCP Congestion Control\n\n   RFC 2914 [5] explains thb".\n\n   RFC 1122 required implementation of Van Jacobson's congestion control\n   algorithms slow start and congestion avoidance together with\n   exponential backoff for successive RTO values for the same segment.\n   RFC 2581 provided IETF Standards Track description of slow start and\n   congestion avoidance, along with fast retransmit and fast recovery.\n   RFC 5681 is the current description of these algorithms and is the\n   current Standards Track specification providing guidelines for TCP\n   congestion control.  RFC 6298 describes exponential backoff of RTO\n   values, including keeping the backed-off value until a subsequent\n   segment with new data has been sent and acknowledged without\n   retransmission.\n\n   A TCP endpoint MUST implement the basic congestion control algorithms\n   slow start, congestion avoidance, and exponential backoff of RTO to\n   avoid creating congestion collapse conditions (MUST-19).  RFC 5681\n   and RFC 6298 describe the basic algorb' applicable.  Multiple other suitable\n   algorithms exist and have been widely used.  Many TCP implementations\n   support a set of alternative algorithms that can be configured for\n   use on the endpoint.  An endpoint MAY implement such alternative\n   algorithms provided that the algorithms are conformant with the TCP\n   specifications from the IETF Standards Track as described in RFC\n   2914, RFC 5033 [7], and RFC 8961 [15] (MAY-18).\n\n   Explicit Congestion Notification (ECN) was defined in RFC 3168 and is\n   an IETF Standards Track enhancement that has many benefits [51].\n\n   A TCP endpoint SHOULD implement ECN as described in RFC 3168 (SHLD-\n   8).\n\n3.8.3.  TCP Connection Failures\n\n   Excessive retransmission of the same segment by a TCP endpoint\n   indicates some failure of the remote host or the internetwork path.\n   This failure may be of short or long duration.  The following\n   procedure MUST be used to handle excessive retransmissions of data\n  b'1 and R2 measuring the amount of\n        retransmission that has occurred for the same segment.  R1 and\n        R2 might be measured in time units or as a count of\n        retransmissions (with the current RTO and corresponding backoffs\n        as a conversion factor, if needed).\n\n   (b)  When the number of transmissions of the same segment reaches or\n        exceeds threshold R1, pass negative advice (see Section 3.3.1.4\n        of [19]) to the IP layer, to trigger dead-gateway diagnosis.\n\n   (c)  When the number of transmissions of the same segment reaches a\n        threshold R2 greater than R1, close the connection.\n\n   (d)  An application MUST (MUST-21) be able to set the value for R2\n        for a particular connection.  For example, an interactive\n        application might set R2 to "infinity", giving the user control\n        over when to disconnect.\n\n   (e)  TCP implementations SHOULD inform the application of the\n        delivery problem (unless sb'ation; see the "Asynchronous Reports" section\n        (Section 3.9.1.8)), when R1 is reached and before R2 (SHLD-9).\n        This will allow a remote login application program to inform the\n        user, for example.\n\n   The value of R1 SHOULD correspond to at least 3 retransmissions, at\n   the current RTO (SHLD-10).  The value of R2 SHOULD correspond to at\n   least 100 seconds (SHLD-11).\n\n   An attempt to open a TCP connection could fail with excessive\n   retransmissions of the SYN segment or by receipt of a RST segment or\n   an ICMP Port Unreachable.  SYN retransmissions MUST be handled in the\n   general way just described for data retransmissions, including\n   notification of the application layer.\n\n   However, the values of R1 and R2 may be different for SYN and data\n   segments.  In particular, R2 for a SYN segment MUST be set large\n   enough to provide retransmission of the segment for at least 3\n   minutes (MUST-23).  The application can close the cb'r, of course.\n\n3.8.4.  TCP Keep-Alives\n\n   A TCP connection is said to be "idle" if for some long amount of time\n   there have been no incoming segments received and there is no new or\n   unacknowledged data to be sent.\n\n   Implementers MAY include "keep-alives" in their TCP implementations\n   (MAY-5), although this practice is not universally accepted.  Some\n   TCP implementations, however, have included a keep-alive mechanism.\n   To confirm that an idle connection is still active, these\n   implementations send a probe segment designed to elicit a response\n   from the TCP peer.  Such a segment generally contains SEG.SEQ =\n   SND.NXT-1 and may or may not contain one garbage octet of data.  If\n   keep-alives are included, the application MUST be able to turn them\n   on or off for each TCP connection (MUST-24), and they MUST default to\n   off (MUST-25).\n\n   Keep-alive packets MUST only be sent when no sent data is\n   outstanding, and no data or acknowledgb'hin an interval (MUST-26).  This interval MUST\n   be configurable (MUST-27) and MUST default to no less than two hours\n   (MUST-28).\n\n   It is extremely important to remember that ACK segments that contain\n   no data are not reliably transmitted by TCP.  Consequently, if a\n   keep-alive mechanism is implemented it MUST NOT interpret failure to\n   respond to any specific probe as a dead connection (MUST-29).\n\n   An implementation SHOULD send a keep-alive segment with no data\n   (SHLD-12); however, it MAY be configurable to send a keep-alive\n   segment containing one garbage octet (MAY-6), for compatibility with\n   erroneous TCP implementations.\n\n3.8.5.  The Communication of Urgent Information\n\n   As a result of implementation differences and middlebox interactions,\n   new applications SHOULD NOT employ the TCP urgent mechanism (SHLD-\n   13).  However, TCP implementations MUST still include support for the\n   urgent mechanism (MUST-30).  Information on howb'r can be found in RFC 6093\n   [39].\n\n   The objective of the TCP urgent mechanism is to allow the sending\n   user to stimulate the receiving user to accept some urgent data and\n   to permit the receiving TCP endpoint to indicate to the receiving\n   user when all the currently known urgent data has been received by\n   the user.\n\n   This mechanism permits a point in the data stream to be designated as\n   the end of urgent information.  Whenever this point is in advance of\n   the receive sequence number (RCV.NXT) at the receiving TCP endpoint,\n   then the TCP implementation must tell the user to go into "urgent\n   mode"; when the receive sequence number catches up to the urgent\n   pointer, the TCP implementation must tell user to go into "normal\n   mode".  If the urgent pointer is updated while the user is in "urgent\n   mode", the update will be invisible to the user.\n\n   The method employs an urgent field that is carried in all segments\n   transmitted.  Thb' meaningful and must be added to the segment sequence number to yield\n   the urgent pointer.  The absence of this flag indicates that there is\n   no urgent data outstanding.\n\n   To send an urgent indication, the user must also send at least one\n   data octet.  If the sending user also indicates a push, timely\n   delivery of the urgent information to the destination process is\n   enhanced.  Note that because changes in the urgent pointer correspond\n   to data being written by a sending application, the urgent pointer\n   cannot "recede" in the sequence space, but a TCP receiver should be\n   robust to invalid urgent pointer values.\n\n   A TCP implementation MUST support a sequence of urgent data of any\n   length (MUST-31) [19].\n\n   The urgent pointer MUST point to the sequence number of the octet\n   following the urgent data (MUST-62).\n\n   A TCP implementation MUST (MUST-32) inform the application layer\n   asynchronously whenever it receives an urgent pointeb' whenever the urgent pointer\n   advances in the data stream.  The TCP implementation MUST (MUST-33)\n   provide a way for the application to learn how much urgent data\n   remains to be read from the connection, or at least to determine\n   whether more urgent data remains to be read [19].\n\n3.8.6.  Managing the Window\n\n   The window sent in each segment indicates the range of sequence\n   numbers the sender of the window (the data receiver) is currently\n   prepared to accept.  There is an assumption that this is related to\n   the data buffer space currently available for this connection.\n\n   The sending TCP endpoint packages the data to be transmitted into\n   segments that fit the current window, and may repackage segments on\n   the retransmission queue.  Such repackaging is not required but may\n   be helpful.\n\n   In a connection with a one-way data flow, the window information will\n   be carried in acknowledgment segments that all have the same sequence\n  b'arrive out of\n   order.  This is not a serious problem, but it will allow the window\n   information to be on occasion temporarily based on old reports from\n   the data receiver.  A refinement to avoid this problem is to act on\n   the window information from segments that carry the highest\n   acknowledgment number (that is, segments with an acknowledgment\n   number equal to or greater than the highest previously received).\n\n   Indicating a large window encourages transmissions.  If more data\n   arrives than can be accepted, it will be discarded.  This will result\n   in excessive retransmissions, adding unnecessarily to the load on the\n   network and the TCP endpoints.  Indicating a small window may\n   restrict the transmission of data to the point of introducing a\n   round-trip delay between each new segment transmitted.\n\n   The mechanisms provided allow a TCP endpoint to advertise a large\n   window and to subsequently advertise a much smaller window withoutb'shrinking the\n   window" is strongly discouraged.  The robustness principle [19]\n   dictates that TCP peers will not shrink the window themselves, but\n   will be prepared for such behavior on the part of other TCP peers.\n\n   A TCP receiver SHOULD NOT shrink the window, i.e., move the right\n   window edge to the left (SHLD-14).  However, a sending TCP peer MUST\n   be robust against window shrinking, which may cause the "usable\n   window" (see Section 3.8.6.2.1) to become negative (MUST-34).\n\n   If this happens, the sender SHOULD NOT send new data (SHLD-15), but\n   SHOULD retransmit normally the old unacknowledged data between\n   SND.UNA and SND.UNA+SND.WND (SHLD-16).  The sender MAY also\n   retransmit old data beyond SND.UNA+SND.WND (MAY-7), but SHOULD NOT\n   time out the connection if data beyond the right window edge is not\n   acknowledged (SHLD-17).  If the window shrinks to zero, the TCP\n   implementation MUST probe it in the standard way (described belob'he sending TCP peer must regularly transmit at least one octet of\n   new data (if available), or retransmit to the receiving TCP peer even\n   if the send window is zero, in order to "probe" the window.  This\n   retransmission is essential to guarantee that when either TCP peer\n   has a zero window the reopening of the window will be reliably\n   reported to the other.  This is referred to as Zero-Window Probing\n   (ZWP) in other documents.\n\n   Probing of zero (offered) windows MUST be supported (MUST-36).\n\n   A TCP implementation MAY keep its offered receive window closed\n   indefinitely (MAY-8).  As long as the receiving TCP peer continues to\n   send acknowledgments in response to the probe segments, the sending\n   TCP peer MUST allow the connection to stay open (MUST-37).  This\n   enables TCP to function in scenarios such as the "printer ran out of\n   paper" situation described in Section 4.2.2.17 of [19].  The behavior\n   is subject to the implementation\b'\n   When the receiving TCP peer has a zero window and a segment arrives,\n   it must still send an acknowledgment showing its next expected\n   sequence number and current window (zero).\n\n   The transmitting host SHOULD send the first zero-window probe when a\n   zero window has existed for the retransmission timeout period (SHLD-\n   29) (Section 3.8.1), and SHOULD increase exponentially the interval\n   between successive probes (SHLD-30).\n\n3.8.6.2.  Silly Window Syndrome Avoidance\n\n   The "Silly Window Syndrome" (SWS) is a stable pattern of small\n   incremental window movements resulting in extremely poor TCP\n   performance.  Algorithms to avoid SWS are described below for both\n   the sending side and the receiving side.  RFC 1122 contains more\n   detailed discussion of the SWS problem.  Note that the Nagle\n   algorithm and the sender SWS avoidance algorithm play complementary\n   roles in improving performance.  The Nagle algorithm discourages\n   sending tb"\n   increments, while the SWS avoidance algorithm discourages small\n   segments resulting from the right window edge advancing in small\n   increments.\n\n3.8.6.2.1.  Sender's Algorithm -- When to Send Data\n\n   A TCP implementation MUST include a SWS avoidance algorithm in the\n   sender (MUST-38).\n\n   The Nagle algorithm from Section 3.7.4 additionally describes how to\n   coalesce short segments.\n\n   The sender's SWS avoidance algorithm is more difficult than the\n   receiver's because the sender does not know (directly) the receiver's\n   total buffer space (RCV.BUFF).  An approach that has been found to\n   work well is for the sender to calculate Max(SND.WND), which is the\n   maximum send window it has seen so far on the connection, and to use\n   this value as an estimate of RCV.BUFF.  Unfortunately, this can only\n   be an estimate; the receiver may at any time reduce the size of\n   RCV.BUFF.  To avoid a resulting deadlock, it is necessary to have a\n   tib'oidance\n   algorithm.  In practice, this timeout should seldom occur.\n\n   The "usable window" is:\n\n      U = SND.UNA + SND.WND - SND.NXT\n\n   i.e., the offered window less the amount of data sent but not\n   acknowledged.  If D is the amount of data queued in the sending TCP\n   endpoint but not yet sent, then the following set of rules is\n   recommended.\n\n   Send data:\n\n   (1)  if a maximum-sized segment can be sent, i.e., if:\n\n           min(D,U) >= Eff.snd.MSS;\n\n   (2)  or if the data is pushed and all queued data can be sent now,\n        i.e., if:\n\n           [SND.NXT = SND.UNA and] PUSHed and D <= U\n\n        (the bracketed condition is imposed by the Nagle algorithm);\n\n   (3)  or if at least a fraction Fs of the maximum window can be sent,\n        i.e., if:\n\n           [SND.NXT = SND.UNA and]\n\n              min(D,U) >= Fs * Max(SND.WND);\n\n   (4)  or if the override timeout occurs.\n\n   Here Fs is a fraction whose recommended value is 1/2.b' may be\n   convenient to combine this timer with the timer used to probe zero\n   windows (Section 3.8.6.1).\n\n3.8.6.2.2.  Receiver\'s Algorithm -- When to Send a Window Update\n\n   A TCP implementation MUST include a SWS avoidance algorithm in the\n   receiver (MUST-39).\n\n   The receiver\'s SWS avoidance algorithm determines when the right\n   window edge may be advanced; this is customarily known as "updating\n   the window".  This algorithm combines with the delayed ACK algorithm\n   (Section 3.8.6.3) to determine when an ACK segment containing the\n   current window will really be sent to the receiver.\n\n   The solution to receiver SWS is to avoid advancing the right window\n   edge RCV.NXT+RCV.WND in small increments, even if data is received\n   from the network in small segments.\n\n   Suppose the total receive buffer space is RCV.BUFF.  At any given\n   moment, RCV.USER octets of this total may be tied up with data that\n   has been received and acknowledged b' connection is quiescent, RCV.WND = RCV.BUFF\n   and RCV.USER = 0.\n\n   Keeping the right window edge fixed as data arrives and is\n   acknowledged requires that the receiver offer less than its full\n   buffer space, i.e., the receiver must specify a RCV.WND that keeps\n   RCV.NXT+RCV.WND constant as RCV.NXT increases.  Thus, the total\n   buffer space RCV.BUFF is generally divided into three parts:\n\n                  |<------- RCV.BUFF ---------------->|\n                       1             2            3\n              ----|---------|------------------|------|----\n                         RCV.NXT               ^\n                                            (Fixed)\n\n              1 - RCV.USER =  data received but not yet consumed;\n              2 - RCV.WND =   space advertised to sender;\n              3 - Reduction = space available but not yet\n                              advertised.\n\n   The suggested SWS avoidance algorithm for the receiver is to keep\n   b'            RCV.BUFF - RCV.USER - RCV.WND  >=\n\n                       min( Fr * RCV.BUFF, Eff.snd.MSS )\n\n   where Fr is a fraction whose recommended value is 1/2, and\n   Eff.snd.MSS is the effective send MSS for the connection (see\n   Section 3.7.1).  When the inequality is satisfied, RCV.WND is set to\n   RCV.BUFF-RCV.USER.\n\n   Note that the general effect of this algorithm is to advance RCV.WND\n   in increments of Eff.snd.MSS (for realistic receive buffers:\n   Eff.snd.MSS < RCV.BUFF/2).  Note also that the receiver must use its\n   own Eff.snd.MSS, making the assumption that it is the same as the\n   sender\'s.\n\n3.8.6.3.  Delayed Acknowledgments -- When to Send an ACK Segment\n\n   A host that is receiving a stream of TCP data segments can increase\n   efficiency in both the network and the hosts by sending fewer than\n   one ACK (acknowledgment) segment per data segment received; this is\n   known as a "delayed ACK".\n\n   A TCP endpoint SHOULD implement a db'y delayed; in particular, the delay MUST be\n   less than 0.5 seconds (MUST-40).  An ACK SHOULD be generated for at\n   least every second full-sized segment or 2*RMSS bytes of new data\n   (where RMSS is the MSS specified by the TCP endpoint receiving the\n   segments to be acknowledged, or the default value if not specified)\n   (SHLD-19).  Excessive delays on ACKs can disturb the round-trip\n   timing and packet "clocking" algorithms.  More complete discussion of\n   delayed ACK behavior is in Section 4.2 of RFC 5681 [8], including\n   recommendations to immediately acknowledge out-of-order segments,\n   segments above a gap in sequence space, or segments that fill all or\n   part of a gap, in order to accelerate loss recovery.\n\n   Note that there are several current practices that further lead to a\n   reduced number of ACKs, including generic receive offload (GRO) [72],\n   ACK compression, and ACK decimation [28].\n\n3.9.  Interfaces\n\n   There are of course two ib' TCP/lower-level interface.  We have a fairly elaborate model\n   of the user/TCP interface, but the interface to the lower-level\n   protocol module is left unspecified here since it will be specified\n   in detail by the specification of the lower-level protocol.  For the\n   case that the lower level is IP, we note some of the parameter values\n   that TCP implementations might use.\n\n3.9.1.  User/TCP Interface\n\n   The following functional description of user commands to the TCP\n   implementation is, at best, fictional, since every operating system\n   will have different facilities.  Consequently, we must warn readers\n   that different TCP implementations may have different user\n   interfaces.  However, all TCP implementations must provide a certain\n   minimum set of services to guarantee that all TCP implementations can\n   support the same protocol hierarchy.  This section specifies the\n   functional interfaces required of all TCP implementations.\n\n   Sectib'CP and\n   could be used as an additional reference for implementers.\n\n   The following sections functionally characterize a user/TCP\n   interface.  The notation used is similar to most procedure or\n   function calls in high-level languages, but this usage is not meant\n   to rule out trap-type service calls.\n\n   The user commands described below specify the basic functions the TCP\n   implementation must perform to support interprocess communication.\n   Individual implementations must define their own exact format and may\n   provide combinations or subsets of the basic functions in single\n   calls.  In particular, some implementations may wish to automatically\n   OPEN a connection on the first SEND or RECEIVE issued by the user for\n   a given connection.\n\n   In providing interprocess communication facilities, the TCP\n   implementation must not only accept commands, but must also return\n   information to the processes it serves.  The latter consists of:\n\n b'rrupts, remote\n        close, binding of unspecified remote socket).\n\n   (b)  replies to specific user commands indicating success or various\n        types of failure.\n\n3.9.1.1.  Open\n\n   Format: OPEN (local port, remote socket, active/passive [, timeout]\n   [, Diffserv field] [, security/compartment] [, local IP address] [,\n   options]) -> local connection name\n\n   If the active/passive flag is set to passive, then this is a call to\n   LISTEN for an incoming connection.  A passive OPEN may have either a\n   fully specified remote socket to wait for a particular connection or\n   an unspecified remote socket to wait for any call.  A fully specified\n   passive call can be made active by the subsequent execution of a\n   SEND.\n\n   A transmission control block (TCB) is created and partially filled in\n   with data from the OPEN command parameters.\n\n   Every passive OPEN call either creates a new connection record in\n   LISTEN state, or it returns an error; b"rd (MUST-41).\n\n   A TCP implementation that supports multiple concurrent connections\n   MUST provide an OPEN call that will functionally allow an application\n   to LISTEN on a port while a connection block with the same local port\n   is in SYN-SENT or SYN-RECEIVED state (MUST-42).\n\n   On an active OPEN command, the TCP endpoint will begin the procedure\n   to synchronize (i.e., establish) the connection at once.\n\n   The timeout, if present, permits the caller to set up a timeout for\n   all data submitted to TCP.  If data is not successfully delivered to\n   the destination within the timeout period, the TCP endpoint will\n   abort the connection.  The present global default is five minutes.\n\n   The TCP implementation or some component of the operating system will\n   verify the user's authority to open a connection with the specified\n   Diffserv field value or security/compartment.  The absence of a\n   Diffserv field value or security/compartment specificatiob' be used.\n\n   TCP will accept incoming requests as matching only if the security/\n   compartment information is exactly the same as that requested in the\n   OPEN call.\n\n   The Diffserv field value indicated by the user only impacts outgoing\n   packets, may be altered en route through the network, and has no\n   direct bearing or relation to received packets.\n\n   A local connection name will be returned to the user by the TCP\n   implementation.  The local connection name can then be used as a\n   shorthand term for the connection defined by the <local socket,\n   remote socket> pair.\n\n   The optional "local IP address" parameter MUST be supported to allow\n   the specification of the local IP address (MUST-43).  This enables\n   applications that need to select the local IP address used when\n   multihoming is present.\n\n   A passive OPEN call with a specified "local IP address" parameter\n   will await an incoming connection request to that address.  If the\n b'coming\n   connection request to any local IP address and then bind the local IP\n   address of the connection to the particular address that is used.\n\n   For an active OPEN call, a specified "local IP address" parameter\n   will be used for opening the connection.  If the parameter is\n   unspecified, the host will choose an appropriate local IP address\n   (see RFC 1122, Section 3.3.4.2).\n\n   If an application on a multihomed host does not specify the local IP\n   address when actively opening a TCP connection, then the TCP\n   implementation MUST ask the IP layer to select a local IP address\n   before sending the (first) SYN (MUST-44).  See the function\n   GET_SRCADDR() in Section 3.4 of RFC 1122.\n\n   At all other times, a previous segment has either been sent or\n   received on this connection, and TCP implementations MUST use the\n   same local address that was used in those previous segments (MUST-\n   45).\n\n   A TCP implementation MUST reject as an error ab'., a broadcast or multicast address)\n   (MUST-46).\n\n3.9.1.2.  Send\n\n   Format: SEND (local connection name, buffer address, byte count,\n   URGENT flag [, PUSH flag] [, timeout])\n\n   This call causes the data contained in the indicated user buffer to\n   be sent on the indicated connection.  If the connection has not been\n   opened, the SEND is considered an error.  Some implementations may\n   allow users to SEND first; in which case, an automatic OPEN would be\n   done.  For example, this might be one way for application data to be\n   included in SYN segments.  If the calling process is not authorized\n   to use this connection, an error is returned.\n\n   A TCP endpoint MAY implement PUSH flags on SEND calls (MAY-15).  If\n   PUSH flags are not implemented, then the sending TCP peer: (1) MUST\n   NOT buffer data indefinitely (MUST-60), and (2) MUST set the PSH bit\n   in the last buffered segment (i.e., when there is no more queued data\n   to be sent) (MUST-61b'lag is supported on SEND calls.\n\n   If the PUSH flag is set, the application intends the data to be\n   transmitted promptly to the receiver, and the PSH bit will be set in\n   the last TCP segment created from the buffer.\n\n   The PSH bit is not a record marker and is independent of segment\n   boundaries.  The transmitter SHOULD collapse successive bits when it\n   packetizes data, to send the largest possible segment (SHLD-27).\n\n   If the PUSH flag is not set, the data may be combined with data from\n   subsequent SENDs for transmission efficiency.  When an application\n   issues a series of SEND calls without setting the PUSH flag, the TCP\n   implementation MAY aggregate the data internally without sending it\n   (MAY-16).  Note that when the Nagle algorithm is in use, TCP\n   implementations may buffer the data before sending, without regard to\n   the PUSH flag (see Section 3.7.4).\n\n   An application program is logically required to set the PUSH flag in\n   ab"ta to avoid\n   a communication deadlock.  However, a TCP implementation SHOULD send\n   a maximum-sized segment whenever possible (SHLD-28) to improve\n   performance (see Section 3.8.6.2.1).\n\n   New applications SHOULD NOT set the URGENT flag [39] due to\n   implementation differences and middlebox issues (SHLD-13).\n\n   If the URGENT flag is set, segments sent to the destination TCP peer\n   will have the urgent pointer set.  The receiving TCP peer will signal\n   the urgent condition to the receiving process if the urgent pointer\n   indicates that data preceding the urgent pointer has not been\n   consumed by the receiving process.  The purpose of the URGENT flag is\n   to stimulate the receiver to process the urgent data and to indicate\n   to the receiver when all the currently known urgent data has been\n   received.  The number of times the sending user's TCP implementation\n   signals urgent will not necessarily be equal to the number of times\n   the receivinb'.\n\n   If no remote socket was specified in the OPEN, but the connection is\n   established (e.g., because a LISTENing connection has become specific\n   due to a remote segment arriving for the local socket), then the\n   designated buffer is sent to the implied remote socket.  Users who\n   make use of OPEN with an unspecified remote socket can make use of\n   SEND without ever explicitly knowing the remote socket address.\n\n   However, if a SEND is attempted before the remote socket becomes\n   specified, an error will be returned.  Users can use the STATUS call\n   to determine the status of the connection.  Some TCP implementations\n   may notify the user when an unspecified socket is bound.\n\n   If a timeout is specified, the current user timeout for this\n   connection is changed to the new one.\n\n   In the simplest implementation, SEND would not return control to the\n   sending process until either the transmission was complete or the\n   timeout had been exceb' deadlocks (for example, both sides of the connection might\n   try to do SENDs before doing any RECEIVEs) and offers poor\n   performance, so it is not recommended.  A more sophisticated\n   implementation would return immediately to allow the process to run\n   concurrently with network I/O, and, furthermore, to allow multiple\n   SENDs to be in progress.  Multiple SENDs are served in first come,\n   first served order, so the TCP endpoint will queue those it cannot\n   service immediately.\n\n   We have implicitly assumed an asynchronous user interface in which a\n   SEND later elicits some kind of SIGNAL or pseudo-interrupt from the\n   serving TCP endpoint.  An alternative is to return a response\n   immediately.  For instance, SENDs might return immediate local\n   acknowledgment, even if the segment sent had not been acknowledged by\n   the distant TCP endpoint.  We could optimistically assume eventual\n   success.  If we are wrong, the connection will close anyway b'ind (synchronous), there\n   will still be some asynchronous signals, but these will deal with the\n   connection itself, and not with specific segments or buffers.\n\n   In order for the process to distinguish among error or success\n   indications for different SENDs, it might be appropriate for the\n   buffer address to be returned along with the coded response to the\n   SEND request.  TCP-to-user signals are discussed below, indicating\n   the information that should be returned to the calling process.\n\n3.9.1.3.  Receive\n\n   Format: RECEIVE (local connection name, buffer address, byte count)\n   -> byte count, URGENT flag [, PUSH flag]\n\n   This command allocates a receiving buffer associated with the\n   specified connection.  If no OPEN precedes this command or the\n   calling process is not authorized to use this connection, an error is\n   returned.\n\n   In the simplest implementation, control would not return to the\n   calling program until either the buffb's highly subject to deadlocks.  A more\n   sophisticated implementation would permit several RECEIVEs to be\n   outstanding at once.  These would be filled as segments arrive.  This\n   strategy permits increased throughput at the cost of a more elaborate\n   scheme (possibly asynchronous) to notify the calling program that a\n   PUSH has been seen or a buffer filled.\n\n   A TCP receiver MAY pass a received PSH bit to the application layer\n   via the PUSH flag in the interface (MAY-17), but it is not required\n   (this was clarified in RFC 1122, Section 4.2.2.2).  The remainder of\n   text describing the RECEIVE call below assumes that passing the PUSH\n   indication is supported.\n\n   If enough data arrive to fill the buffer before a PUSH is seen, the\n   PUSH flag will not be set in the response to the RECEIVE.  The buffer\n   will be filled with as much data as it can hold.  If a PUSH is seen\n   before the buffer is filled, the buffer will be returned partially\n   b', the user will have been informed as soon as\n   it arrived via a TCP-to-user signal.  The receiving user should thus\n   be in "urgent mode".  If the URGENT flag is on, additional urgent\n   data remains.  If the URGENT flag is off, this call to RECEIVE has\n   returned all the urgent data, and the user may now leave "urgent\n   mode".  Note that data following the urgent pointer (non-urgent data)\n   cannot be delivered to the user in the same buffer with preceding\n   urgent data unless the boundary is clearly marked for the user.\n\n   To distinguish among several outstanding RECEIVEs and to take care of\n   the case that a buffer is not completely filled, the return code is\n   accompanied by both a buffer pointer and a byte count indicating the\n   actual length of the data received.\n\n   Alternative implementations of RECEIVE might have the TCP endpoint\n   allocate buffer storage, or the TCP endpoint might share a ring\n   buffer with the user.\n\n3.9.1.4.  Closeb'mand causes the connection specified to be closed.  If the\n   connection is not open or the calling process is not authorized to\n   use this connection, an error is returned.  Closing connections is\n   intended to be a graceful operation in the sense that outstanding\n   SENDs will be transmitted (and retransmitted), as flow control\n   permits, until all have been serviced.  Thus, it should be acceptable\n   to make several SEND calls, followed by a CLOSE, and expect all the\n   data to be sent to the destination.  It should also be clear that\n   users should continue to RECEIVE on CLOSING connections since the\n   remote peer may be trying to transmit the last of its data.  Thus,\n   CLOSE means "I have no more to send" but does not mean "I will not\n   receive any more."  It may happen (if the user-level protocol is not\n   well thought out) that the closing side is unable to get rid of all\n   its data before timing out.  In this event, CLOSE turns into ABORT,\n   b' CLOSE the connection at any time on their own\n   initiative, or in response to various prompts from the TCP\n   implementation (e.g., remote close executed, transmission timeout\n   exceeded, destination inaccessible).\n\n   Because closing a connection requires communication with the remote\n   TCP peer, connections may remain in the closing state for a short\n   time.  Attempts to reopen the connection before the TCP peer replies\n   to the CLOSE command will result in error responses.\n\n   Close also implies push function.\n\n3.9.1.5.  Status\n\n   Format: STATUS (local connection name) -> status data\n\n   This is an implementation-dependent user command and could be\n   excluded without adverse effect.  Information returned would\n   typically come from the TCB associated with the connection.\n\n   This command returns a data block containing the following\n   information:\n\n      local socket,\n\n      remote socket,\n\n      local connection name,\n\n      receib'ber of buffers awaiting acknowledgment,\n\n      number of buffers pending receipt,\n\n      urgent state,\n\n      Diffserv field value,\n\n      security/compartment, and\n\n      transmission timeout.\n\n   Depending on the state of the connection, or on the implementation\n   itself, some of this information may not be available or meaningful.\n   If the calling process is not authorized to use this connection, an\n   error is returned.  This prevents unauthorized processes from gaining\n   information about a connection.\n\n3.9.1.6.  Abort\n\n   Format: ABORT (local connection name)\n\n   This command causes all pending SENDs and RECEIVES to be aborted, the\n   TCB to be removed, and a special RST message to be sent to the remote\n   TCP peer of the connection.  Depending on the implementation, users\n   may receive abort indications for each outstanding SEND or RECEIVE,\n   or may simply receive an ABORT-acknowledgment.\n\n3.9.1.7.  Flush\n\n   Some TCP implementatiob'ue of any data that the user has issued SEND calls\n   for but is still to the right of the current send window.  That is,\n   it flushes as much queued send data as possible without losing\n   sequence number synchronization.  The FLUSH call MAY be implemented\n   (MAY-14).\n\n3.9.1.8.  Asynchronous Reports\n\n   There MUST be a mechanism for reporting soft TCP error conditions to\n   the application (MUST-47).  Generically, we assume this takes the\n   form of an application-supplied ERROR_REPORT routine that may be\n   upcalled asynchronously from the transport layer:\n\n      ERROR_REPORT(local connection name, reason, subreason)\n\n   The precise encoding of the reason and subreason parameters is not\n   specified here.  However, the conditions that are reported\n   asynchronously to the application MUST include:\n\n   *  ICMP error message arrived (see Section 3.9.2.2 for description of\n      handling each ICMP message type since some message types need to\n      beb'  *  Excessive retransmissions (see Section 3.8.3)\n\n   *  Urgent pointer advance (see Section 3.8.5)\n\n   However, an application program that does not want to receive such\n   ERROR_REPORT calls SHOULD be able to effectively disable these calls\n   (SHLD-20).\n\n3.9.1.9.  Set Differentiated Services Field (IPv4 TOS or IPv6 Traffic\n          Class)\n\n   The application layer MUST be able to specify the Differentiated\n   Services field for segments that are sent on a connection (MUST-48).\n   The Differentiated Services field includes the 6-bit Differentiated\n   Services Codepoint (DSCP) value.  It is not required, but the\n   application SHOULD be able to change the Differentiated Services\n   field during the connection lifetime (SHLD-21).  TCP implementations\n   SHOULD pass the current Differentiated Services field value without\n   change to the IP layer, when it sends segments on the connection\n   (SHLD-22).\n\n   The Differentiated Services field will be specb', so that the receiver application\n   will specify the Differentiated Services field used for ACK segments.\n\n   TCP implementations MAY pass the most recently received\n   Differentiated Services field up to the application (MAY-9).\n\n3.9.2.  TCP/Lower-Level Interface\n\n   The TCP endpoint calls on a lower-level protocol module to actually\n   send and receive information over a network.  The two current\n   standard Internet Protocol (IP) versions layered below TCP are IPv4\n   [1] and IPv6 [13].\n\n   If the lower-level protocol is IPv4, it provides arguments for a type\n   of service (used within the Differentiated Services field) and for a\n   time to live.  TCP uses the following settings for these parameters:\n\n   Diffserv field:  The IP header value for the Diffserv field is given\n      by the user.  This includes the bits of the Diffserv Codepoint\n      (DSCP).\n\n   Time to Live (TTL):  The TTL value used to send TCP segments MUST be\n      configurable (Mb'60 seconds) as a\n         constant for the TTL because the assumed maximum segment\n         lifetime was two minutes.  This was intended to explicitly ask\n         that a segment be destroyed if it could not be delivered by the\n         internet system within one minute.  RFC 1122 updated RFC 793 to\n         require that the TTL be configurable.\n\n      *  Note that the Diffserv field is permitted to change during a\n         connection (Section 4.2.4.2 of RFC 1122).  However, the\n         application interface might not support this ability, and the\n         application does not have knowledge about individual TCP\n         segments, so this can only be done on a coarse granularity, at\n         best.  This limitation is further discussed in RFC 7657\n         (Sections 5.1, 5.3, and 6) [50].  Generally, an application\n         SHOULD NOT change the Diffserv field value during the course of\n         a connection (SHLD-23).\n\n   Any lower-level protocol will havb's, and protocol fields, and some way to determine\n   the "TCP length", both to provide the functional equivalent service\n   of IP and to be used in the TCP checksum.\n\n   When received options are passed up to TCP from the IP layer, a TCP\n   implementation MUST ignore options that it does not understand (MUST-\n   50).\n\n   A TCP implementation MAY support the Timestamp (MAY-10) and Record\n   Route (MAY-11) Options.\n\n3.9.2.1.  Source Routing\n\n   If the lower level is IP (or other protocol that provides this\n   feature) and source routing is used, the interface must allow the\n   route information to be communicated.  This is especially important\n   so that the source and destination addresses used in the TCP checksum\n   be the originating source and ultimate destination.  It is also\n   important to preserve the return route to answer connection requests.\n\n   An application MUST be able to specify a source route when it\n   actively opens a TCP connection (Mb'ute received in a datagram (MUST-52).\n\n   When a TCP connection is OPENed passively and a packet arrives with a\n   completed IP Source Route Option (containing a return route), TCP\n   implementations MUST save the return route and use it for all\n   segments sent on this connection (MUST-53).  If a different source\n   route arrives in a later segment, the later definition SHOULD\n   override the earlier one (SHLD-24).\n\n3.9.2.2.  ICMP Messages\n\n   TCP implementations MUST act on an ICMP error message passed up from\n   the IP layer, directing it to the connection that created the error\n   (MUST-54).  The necessary demultiplexing information can be found in\n   the IP header contained within the ICMP message.\n\n   This applies to ICMPv6 in addition to IPv4 ICMP.\n\n   [35] contains discussion of specific ICMP and ICMPv6 messages\n   classified as either "soft" or "hard" errors that may bear different\n   responses.  Treatment for classes of ICMP messages is describ'MUST silently discard any received ICMP Source\n     Quench messages (MUST-55).  See [11] for discussion.\n\n   Soft Errors\n     For IPv4 ICMP, these include: Destination Unreachable -- codes 0,\n     1, 5; Time Exceeded -- codes 0, 1; and Parameter Problem.\n\n     For ICMPv6, these include: Destination Unreachable -- codes 0, 3;\n     Time Exceeded -- codes 0, 1; and Parameter Problem -- codes 0, 1,\n     2.\n\n     Since these Unreachable messages indicate soft error conditions, a\n     TCP implementation MUST NOT abort the connection (MUST-56), and it\n     SHOULD make the information available to the application (SHLD-25).\n\n   Hard Errors\n     For ICMP these include Destination Unreachable -- codes 2-4.\n\n     These are hard error conditions, so TCP implementations SHOULD\n     abort the connection (SHLD-26).  [35] notes that some\n     implementations do not abort connections when an ICMP hard error is\n     received for a connection that is in any of the synchrb's widespread implementation\n   behavior that treats soft errors as hard errors during connection\n   establishment.\n\n3.9.2.3.  Source Address Validation\n\n   RFC 1122 requires addresses to be validated in incoming SYN packets:\n\n   |  An incoming SYN with an invalid source address MUST be ignored\n   |  either by TCP or by the IP layer [(MUST-63)] (see\n   |  Section 3.2.1.3).\n   |  \n   |  A TCP implementation MUST silently discard an incoming SYN segment\n   |  that is addressed to a broadcast or multicast address [(MUST-57)].\n\n   This prevents connection state and replies from being erroneously\n   generated, and implementers should note that this guidance is\n   applicable to all incoming segments, not just SYNs, as specifically\n   indicated in RFC 1122.\n\n3.10.  Event Processing\n\n   The processing depicted in this section is an example of one possible\n   implementation.  Other implementations may have slightly different\n   processing sequences, but they b'ot in substance.\n\n   The activity of the TCP endpoint can be characterized as responding\n   to events.  The events that occur can be cast into three categories:\n   user calls, arriving segments, and timeouts.  This section describes\n   the processing the TCP endpoint does in response to each of the\n   events.  In many cases, the processing required depends on the state\n   of the connection.\n\n   Events that occur:\n\n      User Calls\n\n         OPEN\n\n         SEND\n\n         RECEIVE\n\n         CLOSE\n\n         ABORT\n\n         STATUS\n\n      Arriving Segments\n\n         SEGMENT ARRIVES\n\n      Timeouts\n\n         USER TIMEOUT\n\n         RETRANSMISSION TIMEOUT\n\n         TIME-WAIT TIMEOUT\n\n   The model of the TCP/user interface is that user commands receive an\n   immediate return and possibly a delayed response via an event or\n   pseudo-interrupt.  In the following descriptions, the term "signal"\n   means cause a delayed response.\n\n   Error respob' commands referencing connections that do not exist\n   receive "error: connection not open".\n\n   Please note in the following that all arithmetic on sequence numbers,\n   acknowledgment numbers, windows, et cetera, is modulo 2^32 (the size\n   of the sequence number space).  Also note that "=<" means less than\n   or equal to (modulo 2^32).\n\n   A natural way to think about processing incoming segments is to\n   imagine that they are first tested for proper sequence number (i.e.,\n   that their contents lie in the range of the expected "receive window"\n   in the sequence number space) and then that they are generally queued\n   and processed in sequence number order.\n\n   When a segment overlaps other already received segments, we\n   reconstruct the segment to contain just the new data and adjust the\n   header fields to be consistent.\n\n   Note that if no state change is mentioned, the TCP connection stays\n   in the same state.\n\n3.10.1.  OPEN Call\n\n   CLOSED b'ssion control block (TCB) to hold connection\n      state information.  Fill in local socket identifier, remote\n      socket, Diffserv field, security/compartment, and user timeout\n      information.  Note that some parts of the remote socket may be\n      unspecified in a passive OPEN and are to be filled in by the\n      parameters of the incoming SYN segment.  Verify the security and\n      Diffserv value requested are allowed for this user, if not, return\n      "error: Diffserv value not allowed" or "error: security/\n      compartment not allowed".  If passive, enter the LISTEN state and\n      return.  If active and the remote socket is unspecified, return\n      "error: remote socket unspecified"; if active and the remote\n      socket is specified, issue a SYN segment.  An initial send\n      sequence number (ISS) is selected.  A SYN segment of the form\n      <SEQ=ISS><CTL=SYN> is sent.  Set SND.UNA to ISS, SND.NXT to ISS+1,\n      enter SYN-SENT state, and retb'he local socket specified,\n      return "error: connection illegal for this process".  If there is\n      no room to create a new connection, return "error: insufficient\n      resources".\n\n   LISTEN STATE\n\n   *  If the OPEN call is active and the remote socket is specified,\n      then change the connection from passive to active, select an ISS.\n      Send a SYN segment, set SND.UNA to ISS, SND.NXT to ISS+1.  Enter\n      SYN-SENT state.  Data associated with SEND may be sent with SYN\n      segment or queued for transmission after entering ESTABLISHED\n      state.  The urgent bit if requested in the command must be sent\n      with the data segments sent as a result of this command.  If there\n      is no room to queue the request, respond with "error: insufficient\n      resources".  If the remote socket was not specified, then return\n      "error: remote socket unspecified".\n\n   SYN-SENT STATE\n\n   SYN-RECEIVED STATE\n\n   ESTABLISHED STATE\n\n   FIN-WAIT-1 b'TATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Return "error: connection already exists".\n\n3.10.2.  SEND Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user does not have access to such a connection, then return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  If the remote socket is specified, then change the connection from\n      passive to active, select an ISS.  Send a SYN segment, set SND.UNA\n      to ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data associated\n      with SEND may be sent with SYN segment or queued for transmission\n      after entering ESTABLISHED state.  The urgent bit if requested in\n      the command must be sent with the data segments sent as a result\n      of this command.  If there is no room to queue the request,\n      respond with "error: insufficient resources".  If the remote\n      socket was not specified,b'ENT STATE\n\n   SYN-RECEIVED STATE\n\n   *  Queue the data for transmission after entering ESTABLISHED state.\n      If no space to queue, respond with "error: insufficient\n      resources".\n\n   ESTABLISHED STATE\n\n   CLOSE-WAIT STATE\n\n   *  Segmentize the buffer and send it with a piggybacked\n      acknowledgment (acknowledgment value = RCV.NXT).  If there is\n      insufficient space to remember this buffer, simply return "error:\n      insufficient resources".\n\n   *  If the URGENT flag is set, then SND.UP <- SND.NXT and set the\n      urgent pointer in the outgoing segments.\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Return "error: connection closing" and do not service request.\n\n3.10.3.  RECEIVE Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user does not have access to such a connection, return\n      "error: connection illegal for this process".\n\n   *  Otherwisb'STATE\n\n   SYN-RECEIVED STATE\n\n   *  Queue for processing after entering ESTABLISHED state.  If there\n      is no room to queue this request, respond with "error:\n      insufficient resources".\n\n   ESTABLISHED STATE\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   *  If insufficient incoming segments are queued to satisfy the\n      request, queue the request.  If there is no queue space to\n      remember the RECEIVE, respond with "error: insufficient\n      resources".\n\n   *  Reassemble queued incoming segments into receive buffer and return\n      to user.  Mark "push seen" (PUSH) if this is the case.\n\n   *  If RCV.UP is in advance of the data currently being passed to the\n      user, notify the user of the presence of urgent data.\n\n   *  When the TCP endpoint takes responsibility for delivering data to\n      the user, that fact must be communicated to the sender via an\n      acknowledgment.  The formation of such an acknowledgment is\n      describedb'\n\n   CLOSE-WAIT STATE\n\n   *  Since the remote side has already sent FIN, RECEIVEs must be\n      satisfied by data already on hand, but not yet delivered to the\n      user.  If no text is awaiting delivery, the RECEIVE will get an\n      "error: connection closing" response.  Otherwise, any remaining\n      data can be used to satisfy the RECEIVE.\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Return "error: connection closing".\n\n3.10.4.  CLOSE Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user does not have access to such a connection, return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  Any outstanding RECEIVEs are returned with "error: closing"\n      responses.  Delete TCB, enter CLOSED state, and return.\n\n   SYN-SENT STATE\n\n   *  Delete the TCB and return "error: closing" responses to any queued\n      SENDs, or RECb'ere is no pending data to send,\n      then form a FIN segment and send it, and enter FIN-WAIT-1 state;\n      otherwise, queue for processing after entering ESTABLISHED state.\n\n   ESTABLISHED STATE\n\n   *  Queue this until all preceding SENDs have been segmentized, then\n      form a FIN segment and send it.  In any case, enter FIN-WAIT-1\n      state.\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   *  Strictly speaking, this is an error and should receive an "error:\n      connection closing" response.  An "ok" response would be\n      acceptable, too, as long as a second FIN is not emitted (the first\n      FIN may be retransmitted, though).\n\n   CLOSE-WAIT STATE\n\n   *  Queue this request until all preceding SENDs have been\n      segmentized; then send a FIN segment, enter LAST-ACK state.\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Respond with "error: connection closing".\n\n3.10.5.  ABORT Call\n\n   CLOSED STATE (i.e., TCB does nb'n, return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  Any outstanding RECEIVEs should be returned with "error:\n      connection reset" responses.  Delete TCB, enter CLOSED state, and\n      return.\n\n   SYN-SENT STATE\n\n   *  All queued SENDs and RECEIVEs should be given "connection reset"\n      notification.  Delete the TCB, enter CLOSED state, and return.\n\n   SYN-RECEIVED STATE\n\n   ESTABLISHED STATE\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   CLOSE-WAIT STATE\n\n   *  Send a reset segment:\n\n      <SEQ=SND.NXT><CTL=RST>\n\n   *  All queued SENDs and RECEIVEs should be given "connection reset"\n      notification; all segments queued for transmission (except for the\n      RST formed above) or retransmission should be flushed.  Delete the\n      TCB, enter CLOSED state, and return.\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Respb'6.  STATUS Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user should not have access to such a connection, return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  Return "state = LISTEN" and the TCB pointer.\n\n   SYN-SENT STATE\n\n   *  Return "state = SYN-SENT" and the TCB pointer.\n\n   SYN-RECEIVED STATE\n\n   *  Return "state = SYN-RECEIVED" and the TCB pointer.\n\n   ESTABLISHED STATE\n\n   *  Return "state = ESTABLISHED" and the TCB pointer.\n\n   FIN-WAIT-1 STATE\n\n   *  Return "state = FIN-WAIT-1" and the TCB pointer.\n\n   FIN-WAIT-2 STATE\n\n   *  Return "state = FIN-WAIT-2" and the TCB pointer.\n\n   CLOSE-WAIT STATE\n\n   *  Return "state = CLOSE-WAIT" and the TCB pointer.\n\n   CLOSING STATE\n\n   *  Return "state = CLOSING" and the TCB pointer.\n\n   LAST-ACK STATE\n\n   *  Return "state = LAST-ACK" and the TCB pointer.\n\n   TIME-WAIT STATE\nb'.10.7.1.  CLOSED STATE\n\n   If the state is CLOSED (i.e., TCB does not exist), then\n\n      all data in the incoming segment is discarded.  An incoming\n      segment containing a RST is discarded.  An incoming segment not\n      containing a RST causes a RST to be sent in response.  The\n      acknowledgment and sequence field values are selected to make the\n      reset sequence acceptable to the TCP endpoint that sent the\n      offending segment.\n\n      If the ACK bit is off, sequence number zero is used,\n\n         <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\n      If the ACK bit is on,\n\n         <SEQ=SEG.ACK><CTL=RST>\n\n      Return.\n\n3.10.7.2.  LISTEN STATE\n\n   If the state is LISTEN, then\n\n      First, check for a RST:\n\n      -  An incoming RST segment could not be valid since it could not\n         have been sent in response to anything sent by this incarnation\n         of the connection.  An incoming RST should be ignored.  Return.\n\n      Seconb'es on a connection still\n         in the LISTEN state.  An acceptable reset segment should be\n         formed for any arriving ACK-bearing segment.  The RST should be\n         formatted as follows:\n\n            <SEQ=SEG.ACK><CTL=RST>\n\n      -  Return.\n\n      Third, check for a SYN:\n\n      -  If the SYN bit is set, check the security.  If the security/\n         compartment on the incoming segment does not exactly match the\n         security/compartment in the TCB, then send a reset and return.\n\n            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\n      -  Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ, and any other\n         control or text should be queued for processing later.  ISS\n         should be selected and a SYN segment sent of the form:\n\n            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n\n      -  SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection\n         state should be changed to SYN-RECEIVED.  Note that any other\n         incob'      in the SYN-RECEIVED state, but processing of SYN and ACK should\n         not be repeated.  If the listen was not fully specified (i.e.,\n         the remote socket was not fully specified), then the\n         unspecified fields should be filled in now.\n\n      Fourth, other data or control:\n\n      -  This should not be reached.  Drop the segment and return.  Any\n         other control or data-bearing segment (not containing SYN) must\n         have an ACK and thus would have been discarded by the ACK\n         processing in the second step, unless it was first discarded by\n         RST checking in the first step.\n\n3.10.7.3.  SYN-SENT STATE\n\n   If the state is SYN-SENT, then\n\n      First, check the ACK bit:\n\n      -  If the ACK bit is set,\n\n         o  If SEG.ACK =< ISS or SEG.ACK > SND.NXT, send a reset (unless\n            the RST bit is set, if so drop the segment and return)\n\n               <SEQ=SEG.ACK><CTL=RST>\n\n         o  and discard the seb'hen the ACK is acceptable.\n            Some deployed TCP code has used the check SEG.ACK == SND.NXT\n            (using "==" rather than "=<"), but this is not appropriate\n            when the stack is capable of sending data on the SYN because\n            the TCP peer may not accept and acknowledge all of the data\n            on the SYN.\n\n      Second, check the RST bit:\n\n      -  If the RST bit is set,\n\n         o  A potential blind reset attack is described in RFC 5961 [9].\n            The mitigation described in that document has specific\n            applicability explained therein, and is not a substitute for\n            cryptographic protection (e.g., IPsec or TCP-AO).  A TCP\n            implementation that supports the mitigation described in RFC\n            5961 SHOULD first check that the sequence number exactly\n            matches RCV.NXT prior to executing the action in the next\n            paragraph.\n\n         o  If the ACK was acceptable, thb't", drop the segment, enter CLOSED state,\n            delete TCB, and return.  Otherwise (no ACK), drop the\n            segment and return.\n\n      Third, check the security:\n\n      -  If the security/compartment in the segment does not exactly\n         match the security/compartment in the TCB, send a reset:\n\n         o  If there is an ACK,\n\n               <SEQ=SEG.ACK><CTL=RST>\n\n         o  Otherwise,\n\n               <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\n      -  If a reset was sent, discard the segment and return.\n\n      Fourth, check the SYN bit:\n\n      -  This step should be reached only if the ACK is ok, or there is\n         no ACK, and the segment did not contain a RST.\n\n      -  If the SYN bit is on and the security/compartment is\n         acceptable, then RCV.NXT is set to SEG.SEQ+1, IRS is set to\n         SEG.SEQ.  SND.UNA should be advanced to equal SEG.ACK (if there\n         is an ACK), and any segments on the retransmission queueb'  -  If SND.UNA > ISS (our SYN has been ACKed), change the\n         connection state to ESTABLISHED, form an ACK segment\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n      -  and send it.  Data or controls that were queued for\n         transmission MAY be included.  Some TCP implementations\n         suppress sending this segment when the received segment\n         contains data that will anyways generate an acknowledgment in\n         the later processing steps, saving this extra acknowledgment of\n         the SYN from being sent.  If there are other controls or text\n         in the segment, then continue processing at the sixth step\n         under Section 3.10.7.4 where the URG bit is checked; otherwise,\n         return.\n\n      -  Otherwise, enter SYN-RECEIVED, form a SYN,ACK segment\n\n            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n\n      -  and send it.  Set the variables:\n\n            SND.WND <- SEG.WND\n\n            SND.WL1 <- SEG.SEQ\n\n      b' or text in the segment, queue them\n         for processing after the ESTABLISHED state has been reached,\n         return.\n\n      -  Note that it is legal to send and receive application data on\n         SYN segments (this is the "text in the segment" mentioned\n         above).  There has been significant misinformation and\n         misunderstanding of this topic historically.  Some firewalls\n         and security devices consider this suspicious.  However, the\n         capability was used in T/TCP [21] and is used in TCP Fast Open\n         (TFO) [48], so is important for implementations and network\n         devices to permit.\n\n      Fifth, if neither of the SYN or RST bits is set, then drop the\n      segment and return.\n\n3.10.7.4.  Other States\n\n   Otherwise,\n\n      First, check sequence number:\n\n      -  SYN-RECEIVED STATE\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n      -  CLOSE-WAIT STATE\n\n      - b"       o  Segments are processed in sequence.  Initial tests on\n            arrival are used to discard old duplicates, but further\n            processing is done in SEG.SEQ order.  If a segment's\n            contents straddle the boundary between old and new, only the\n            new parts are processed.\n\n         o  In general, the processing of received segments MUST be\n            implemented to aggregate ACK segments whenever possible\n            (MUST-58).  For example, if the TCP endpoint is processing a\n            series of queued segments, it MUST process them all before\n            sending any ACK segments (MUST-59).\n\n         o  There are four cases for the acceptability test for an\n            incoming segment:\n\n            +=========+=========+======================================+\n            | Segment | Receive | Test                                 |\n            | Length  | Window  |                                      |\n            +==b'=+\n            | 0       | 0       | SEG.SEQ = RCV.NXT                    |\n            +---------+---------+--------------------------------------+\n            | 0       | >0      | RCV.NXT =< SEG.SEQ <                 |\n            |         |         | RCV.NXT+RCV.WND                      |\n            +---------+---------+--------------------------------------+\n            | >0      | 0       | not acceptable                       |\n            +---------+---------+--------------------------------------+\n            | >0      | >0      | RCV.NXT =< SEG.SEQ <                 |\n            |         |         | RCV.NXT+RCV.WND                      |\n            |         |         |                                      |\n            |         |         | or                                   |\n            |         |         |                                      |\n            |         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1         |\n            |        b'\n            +---------+---------+--------------------------------------+\n\n                        Table 6: Segment Acceptability Tests\n\n         o  In implementing sequence number validation as described\n            here, please note Appendix A.2.\n\n         o  If the RCV.WND is zero, no segments will be acceptable, but\n            special allowance should be made to accept valid ACKs, URGs,\n            and RSTs.\n\n         o  If an incoming segment is not acceptable, an acknowledgment\n            should be sent in reply (unless the RST bit is set, if so\n            drop the segment and return):\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n         o  After sending the acknowledgment, drop the unacceptable\n            segment and return.\n\n         o  Note that for the TIME-WAIT state, there is an improved\n            algorithm described in [40] for handling incoming SYN\n            segments that utilizes timestamps rather than relying on the\n   b'oved\n            algorithm is implemented, the logic above is not applicable\n            for incoming SYN segments with Timestamp Options, received\n            on a connection in the TIME-WAIT state.\n\n         o  In the following it is assumed that the segment is the\n            idealized segment that begins at RCV.NXT and does not exceed\n            the window.  One could tailor actual segments to fit this\n            assumption by trimming off any portions that lie outside the\n            window (including SYN and FIN) and only processing further\n            if the segment then begins at RCV.NXT.  Segments with higher\n            beginning sequence numbers SHOULD be held for later\n            processing (SHLD-31).\n\n      Second, check the RST bit:\n\n      -  RFC 5961 [9], Section 3 describes a potential blind reset\n         attack and optional mitigation approach.  This does not provide\n         a cryptographic protection (e.g., as in IPsec or TCP-AO) bub' RFC 5961.  For\n         stacks implementing the protection described in RFC 5961, the\n         three checks below apply; otherwise, processing for these\n         states is indicated further below.\n\n         1)  If the RST bit is set and the sequence number is outside\n             the current receive window, silently drop the segment.\n\n         2)  If the RST bit is set and the sequence number exactly\n             matches the next expected sequence number (RCV.NXT), then\n             TCP endpoints MUST reset the connection in the manner\n             prescribed below according to the connection state.\n\n         3)  If the RST bit is set and the sequence number does not\n             exactly match the next expected sequence value, yet is\n             within the current receive window, TCP endpoints MUST send\n             an acknowledgment (challenge ACK):\n\n             <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n             After sending the challenge ACK, TCP eb'and stop processing the incoming\n             packet further.  Note that RFC 5961 and Errata ID 4772 [99]\n             contain additional considerations for ACK throttling in an\n             implementation.\n\n      -  SYN-RECEIVED STATE\n\n         o  If the RST bit is set,\n\n            +  If this connection was initiated with a passive OPEN\n               (i.e., came from the LISTEN state), then return this\n               connection to LISTEN state and return.  The user need not\n               be informed.  If this connection was initiated with an\n               active OPEN (i.e., came from SYN-SENT state), then the\n               connection was refused; signal the user "connection\n               refused".  In either case, the retransmission queue\n               should be flushed.  And in the active OPEN case, enter\n               the CLOSED state and delete the TCB, and return.\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-b'it is set, then any outstanding RECEIVEs and\n            SEND should receive "reset" responses.  All segment queues\n            should be flushed.  Users should also receive an unsolicited\n            general "connection reset" signal.  Enter the CLOSED state,\n            delete the TCB, and return.\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  If the RST bit is set, then enter the CLOSED state, delete\n            the TCB, and return.\n\n      Third, check security:\n\n      -  SYN-RECEIVED STATE\n\n         o  If the security/compartment in the segment does not exactly\n            match the security/compartment in the TCB, then send a reset\n            and return.\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n      -  CLOSE-WAIT STATE\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  If the security/compartment in the segment b'en send a\n            reset; any outstanding RECEIVEs and SEND should receive\n            "reset" responses.  All segment queues should be flushed.\n            Users should also receive an unsolicited general "connection\n            reset" signal.  Enter the CLOSED state, delete the TCB, and\n            return.\n\n      -  Note this check is placed following the sequence check to\n         prevent a segment from an old connection between these port\n         numbers with a different security from causing an abort of the\n         current connection.\n\n      Fourth, check the SYN bit:\n\n      -  SYN-RECEIVED STATE\n\n         o  If the connection was initiated with a passive OPEN, then\n            return this connection to the LISTEN state and return.\n            Otherwise, handle per the directions for synchronized states\n            below.\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n      -  CLOSE-WAIT STATE\n\n    b'ATE\n\n         o  If the SYN bit is set in these synchronized states, it may\n            be either a legitimate new connection attempt (e.g., in the\n            case of TIME-WAIT), an error where the connection should be\n            reset, or the result of an attack attempt, as described in\n            RFC 5961 [9].  For the TIME-WAIT state, new connections can\n            be accepted if the Timestamp Option is used and meets\n            expectations (per [40]).  For all other cases, RFC 5961\n            provides a mitigation with applicability to some situations,\n            though there are also alternatives that offer cryptographic\n            protection (see Section 7).  RFC 5961 recommends that in\n            these synchronized states, if the SYN bit is set,\n            irrespective of the sequence number, TCP endpoints MUST send\n            a "challenge ACK" to the remote peer:\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n         o  After sendib'     drop the unacceptable segment and stop processing further.\n            Note that RFC 5961 and Errata ID 4772 [99] contain\n            additional ACK throttling notes for an implementation.\n\n         o  For implementations that do not follow RFC 5961, the\n            original behavior described in RFC 793 follows in this\n            paragraph.  If the SYN is in the window it is an error: send\n            a reset, any outstanding RECEIVEs and SEND should receive\n            "reset" responses, all segment queues should be flushed, the\n            user should also receive an unsolicited general "connection\n            reset" signal, enter the CLOSED state, delete the TCB, and\n            return.\n\n         o  If the SYN is not in the window, this step would not be\n            reached and an ACK would have been sent in the first step\n            (sequence number check).\n\n      Fifth, check the ACK field:\n\n      -  if the ACK bit is off, drop the segment ab"FC 5961 [9], Section 5 describes a potential blind data\n            injection attack, and mitigation that implementations MAY\n            choose to include (MAY-12).  TCP stacks that implement RFC\n            5961 MUST add an input check that the ACK value is\n            acceptable only if it is in the range of ((SND.UNA -\n            MAX.SND.WND) =< SEG.ACK =< SND.NXT).  All incoming segments\n            whose ACK value doesn't satisfy the above condition MUST be\n            discarded and an ACK sent back.  The new state variable\n            MAX.SND.WND is defined as the largest window that the local\n            sender has ever received from its peer (subject to window\n            scaling) or may be hard-coded to a maximum permissible\n            window value.  When the ACK value is acceptable, the per-\n            state processing below applies:\n\n         o  SYN-RECEIVED STATE\n\n            +  If SND.UNA < SEG.ACK =< SND.NXT, then enter ESTABLISHED\n      b'les below\n               set to:\n\n                  SND.WND <- SEG.WND\n\n                  SND.WL1 <- SEG.SEQ\n\n                  SND.WL2 <- SEG.ACK\n\n            +  If the segment acknowledgment is not acceptable, form a\n               reset segment\n\n                  <SEQ=SEG.ACK><CTL=RST>\n\n            +  and send it.\n\n         o  ESTABLISHED STATE\n\n            +  If SND.UNA < SEG.ACK =< SND.NXT, then set SND.UNA <-\n               SEG.ACK.  Any segments on the retransmission queue that\n               are thereby entirely acknowledged are removed.  Users\n               should receive positive acknowledgments for buffers that\n               have been SENT and fully acknowledged (i.e., SEND buffer\n               should be returned with "ok" response).  If the ACK is a\n               duplicate (SEG.ACK =< SND.UNA), it can be ignored.  If\n               the ACK acks something not yet sent (SEG.ACK > SND.NXT),\n               then send an ACK, drop the seb".NXT, the send window should\n               be updated.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ\n               and SND.WL2 =< SEG.ACK)), set SND.WND <- SEG.WND, set\n               SND.WL1 <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.\n\n            +  Note that SND.WND is an offset from SND.UNA, that SND.WL1\n               records the sequence number of the last segment used to\n               update SND.WND, and that SND.WL2 records the\n               acknowledgment number of the last segment used to update\n               SND.WND.  The check here prevents using old segments to\n               update the window.\n\n         o  FIN-WAIT-1 STATE\n\n            +  In addition to the processing for the ESTABLISHED state,\n               if the FIN segment is now acknowledged, then enter FIN-\n               WAIT-2 and continue processing in that state.\n\n         o  FIN-WAIT-2 STATE\n\n            +  In addition to the processing for the ESTABLISHED state,\n             b'              can be acknowledged ("ok") but do not delete the TCB.\n\n         o  CLOSE-WAIT STATE\n\n            +  Do the same processing as for the ESTABLISHED state.\n\n         o  CLOSING STATE\n\n            +  In addition to the processing for the ESTABLISHED state,\n               if the ACK acknowledges our FIN, then enter the TIME-WAIT\n               state; otherwise, ignore the segment.\n\n         o  LAST-ACK STATE\n\n            +  The only thing that can arrive in this state is an\n               acknowledgment of our FIN.  If our FIN is now\n               acknowledged, delete the TCB, enter the CLOSED state, and\n               return.\n\n         o  TIME-WAIT STATE\n\n            +  The only thing that can arrive in this state is a\n               retransmission of the remote FIN.  Acknowledge it, and\n               restart the 2 MSL timeout.\n\n      Sixth, check the URG bit:\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAb'SEG.UP), and\n            signal the user that the remote side has urgent data if the\n            urgent pointer (RCV.UP) is in advance of the data consumed.\n            If the user has already been signaled (or is still in the\n            "urgent mode") for this continuous sequence of urgent data,\n            do not signal the user again.\n\n      -  CLOSE-WAIT STATE\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  This should not occur since a FIN has been received from the\n            remote side.  Ignore the URG.\n\n      Seventh, process the segment text:\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n         o  Once in the ESTABLISHED state, it is possible to deliver\n            segment data to user RECEIVE buffers.  Data from segments\n            can be moved into buffers until either the buffer is full or\n            the segment is empty.  If the segment empties and b'he buffer is\n            returned, that a PUSH has been received.\n\n         o  When the TCP endpoint takes responsibility for delivering\n            the data to the user, it must also acknowledge the receipt\n            of the data.\n\n         o  Once the TCP endpoint takes responsibility for the data, it\n            advances RCV.NXT over the data accepted, and adjusts RCV.WND\n            as appropriate to the current buffer availability.  The\n            total of RCV.NXT and RCV.WND should not be reduced.\n\n         o  A TCP implementation MAY send an ACK segment acknowledging\n            RCV.NXT when a valid segment arrives that is in the window\n            but not at the left window edge (MAY-13).\n\n         o  Please note the window management suggestions in\n            Section 3.8.\n\n         o  Send an acknowledgment of the form:\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n         o  This acknowledgment should be piggybacked on a segment beib'ue delay.\n\n      -  CLOSE-WAIT STATE\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  This should not occur since a FIN has been received from the\n            remote side.  Ignore the segment text.\n\n      Eighth, check the FIN bit:\n\n      -  Do not process the FIN if the state is CLOSED, LISTEN, or SYN-\n         SENT since the SEG.SEQ cannot be validated; drop the segment\n         and return.\n\n      -  If the FIN bit is set, signal the user "connection closing" and\n         return any pending RECEIVEs with same message, advance RCV.NXT\n         over the FIN, and send an acknowledgment for the FIN.  Note\n         that FIN implies PUSH for any segment text not yet delivered to\n         the user.\n\n         o  SYN-RECEIVED STATE\n\n         o  ESTABLISHED STATE\n\n            +  Enter the CLOSE-WAIT state.\n\n         o  FIN-WAIT-1 STATE\n\n            +  If our FIN has been ACKed (perhaps in this segment), then\nb'\n               other timers; otherwise, enter the CLOSING state.\n\n         o  FIN-WAIT-2 STATE\n\n            +  Enter the TIME-WAIT state.  Start the time-wait timer,\n               turn off the other timers.\n\n         o  CLOSE-WAIT STATE\n\n            +  Remain in the CLOSE-WAIT state.\n\n         o  CLOSING STATE\n\n            +  Remain in the CLOSING state.\n\n         o  LAST-ACK STATE\n\n            +  Remain in the LAST-ACK state.\n\n         o  TIME-WAIT STATE\n\n            +  Remain in the TIME-WAIT state.  Restart the 2 MSL time-\n               wait timeout.\n\n      and return.\n\n3.10.8.  Timeouts\n\n   USER TIMEOUT\n\n   *  For any state if the user timeout expires, flush all queues,\n      signal the user "error: connection aborted due to user timeout" in\n      general and for any outstanding calls, delete the TCB, enter the\n      CLOSED state, and return.\n\n   RETRANSMISSION TIMEOUT\n\n   *  For any state if the retransmission timeout expires ob't of the\n      retransmission queue again, reinitialize the retransmission timer,\n      and return.\n\n   TIME-WAIT TIMEOUT\n\n   *  If the time-wait timeout expires on a connection, delete the TCB,\n      enter the CLOSED state, and return.\n\n4.  Glossary\n\n   ACK    \n           A control bit (acknowledge) occupying no sequence space,\n           which indicates that the acknowledgment field of this segment\n           specifies the next sequence number the sender of this segment\n           is expecting to receive, hence acknowledging receipt of all\n           previous sequence numbers.\n\n   connection\n           A logical communication path identified by a pair of sockets.\n\n   datagram\n           A message sent in a packet-switched computer communications\n           network.\n\n   Destination Address\n           The network-layer address of the endpoint intended to receive\n           a segment.\n\n   FIN    \n           A control bit (finis) occupying one sb'd no more data or control\n           occupying sequence space.\n\n   flush  \n           To remove all of the contents (data or segments) from a store\n           (buffer or queue).\n\n   fragment\n           A portion of a logical unit of data.  In particular, an\n           internet fragment is a portion of an internet datagram.\n\n   header \n           Control information at the beginning of a message, segment,\n           fragment, packet, or block of data.\n\n   host   \n           A computer.  In particular, a source or destination of\n           messages from the point of view of the communication network.\n\n   Identification\n           An Internet Protocol field.  This identifying value assigned\n           by the sender aids in assembling the fragments of a datagram.\n\n   internet address\n           A network-layer address.\n\n   internet datagram\n           A unit of data exchanged between internet hosts, together\n           with the internet header that b'ation.\n\n   internet fragment\n           A portion of the data of an internet datagram with an\n           internet header.\n\n   IP     \n           Internet Protocol.  See [1] and [13].\n\n   IRS    \n           The Initial Receive Sequence number.  The first sequence\n           number used by the sender on a connection.\n\n   ISN    \n           The Initial Sequence Number.  The first sequence number used\n           on a connection (either ISS or IRS).  Selected in a way that\n           is unique within a given period of time and is unpredictable\n           to attackers.\n\n   ISS    \n           The Initial Send Sequence number.  The first sequence number\n           used by the sender on a connection.\n\n   left sequence\n           This is the next sequence number to be acknowledged by the\n           data-receiving TCP endpoint (or the lowest currently\n           unacknowledged sequence number) and is sometimes referred to\n           as the left edge of the b'n software, of a protocol or\n           other procedure.\n\n   MSL    \n           Maximum Segment Lifetime, the time a TCP segment can exist in\n           the internetwork system.  Arbitrarily defined to be 2\n           minutes.\n\n   octet  \n           An eight-bit byte.\n\n   Options\n           An Option field may contain several options, and each option\n           may be several octets in length.\n\n   packet \n           A package of data with a header that may or may not be\n           logically complete.  More often a physical packaging than a\n           logical packaging of data.\n\n   port   \n           The portion of a connection identifier used for\n           demultiplexing connections at an endpoint.\n\n   process\n           A program in execution.  A source or destination of data from\n           the point of view of the TCP endpoint or other host-to-host\n           protocol.\n\n   PUSH   \n           A control bit occupying no sequence space, indicb'd through to the\n           receiving user.\n\n   RCV.NXT\n           receive next sequence number\n\n   RCV.UP \n           receive urgent pointer\n\n   RCV.WND\n           receive window\n\n   receive next sequence number\n           This is the next sequence number the local TCP endpoint is\n           expecting to receive.\n\n   receive window\n           This represents the sequence numbers the local (receiving)\n           TCP endpoint is willing to receive.  Thus, the local TCP\n           endpoint considers that segments overlapping the range\n           RCV.NXT to RCV.NXT + RCV.WND - 1 carry acceptable data or\n           control.  Segments containing sequence numbers entirely\n           outside this range are considered duplicates or injection\n           attacks and discarded.\n\n   RST    \n           A control bit (reset), occupying no sequence space,\n           indicating that the receiver should delete the connection\n           without further interactiob'number and acknowledgment fields of the\n           incoming segment, whether it should honor the reset command\n           or ignore it.  In no case does receipt of a segment\n           containing RST give rise to a RST in response.\n\n   SEG.ACK\n           segment acknowledgment\n\n   SEG.LEN\n           segment length\n\n   SEG.SEQ\n           segment sequence\n\n   SEG.UP \n           segment urgent pointer field\n\n   SEG.WND\n           segment window field\n\n   segment\n           A logical unit of data.  In particular, a TCP segment is the\n           unit of data transferred between a pair of TCP modules.\n\n   segment acknowledgment\n           The sequence number in the acknowledgment field of the\n           arriving segment.\n\n   segment length\n           The amount of sequence number space occupied by a segment,\n           including any controls that occupy sequence space.\n\n   segment sequence\n           The number in the sequence field of the arrivib'ber the local (sending) TCP\n           endpoint will use on the connection.  It is initially\n           selected from an initial sequence number curve (ISN) and is\n           incremented for each octet of data or sequenced control\n           transmitted.\n\n   send window\n           This represents the sequence numbers that the remote\n           (receiving) TCP endpoint is willing to receive.  It is the\n           value of the window field specified in segments from the\n           remote (data-receiving) TCP endpoint.  The range of new\n           sequence numbers that may be emitted by a TCP implementation\n           lies between SND.NXT and SND.UNA + SND.WND - 1.\n           (Retransmissions of sequence numbers between SND.UNA and\n           SND.NXT are expected, of course.)\n\n   SND.NXT\n           send sequence\n\n   SND.UNA\n           left sequence\n\n   SND.UP \n           send urgent pointer\n\n   SND.WL1\n           segment sequence number at last windob't last window update\n\n   SND.WND\n           send window\n\n   socket (or socket number, or socket address, or socket identifier)\n           An address that specifically includes a port identifier, that\n           is, the concatenation of an Internet Address with a TCP port.\n\n   Source Address\n           The network-layer address of the sending endpoint.\n\n   SYN    \n           A control bit in the incoming segment, occupying one sequence\n           number, used at the initiation of a connection to indicate\n           where the sequence numbering will start.\n\n   TCB    \n           Transmission control block, the data structure that records\n           the state of a connection.\n\n   TCP    \n           Transmission Control Protocol: a host-to-host protocol for\n           reliable communication in internetwork environments.\n\n   TOS    \n           Type of Service, an obsoleted IPv4 field.  The same header\n           bits currently are used for the Differeb'ted Services Codepoint (DSCP)\n           value and the 2-bit ECN codepoint [6].\n\n   Type of Service\n           See "TOS".\n\n   URG    \n           A control bit (urgent), occupying no sequence space, used to\n           indicate that the receiving user should be notified to do\n           urgent processing as long as there is data to be consumed\n           with sequence numbers less than the value indicated by the\n           urgent pointer.\n\n   urgent pointer\n           A control field meaningful only when the URG bit is on.  This\n           field communicates the value of the urgent pointer that\n           indicates the data octet associated with the sending user\'s\n           urgent call.\n\n5.  Changes from RFC 793\n\n   This document obsoletes RFC 793 as well as RFCs 6093 and 6528, which\n   updated 793.  In all cases, only the normative protocol specification\n   and requirements have been incorporated into this document, and some\n   informational text wb' The informational content of those documents is still\n   valuable in learning about and understanding TCP, and they are valid\n   Informational references, even though their normative content has\n   been incorporated into this document.\n\n   The main body of this document was adapted from RFC 793\'s Section 3,\n   titled "FUNCTIONAL SPECIFICATION", with an attempt to keep formatting\n   and layout as close as possible.\n\n   The collection of applicable RFC errata that have been reported and\n   either accepted or held for an update to RFC 793 were incorporated\n   (Errata IDs: 573 [73], 574 [74], 700 [75], 701 [76], 1283 [77], 1561\n   [78], 1562 [79], 1564 [80], 1571 [81], 1572 [82], 2297 [83], 2298\n   [84], 2748 [85], 2749 [86], 2934 [87], 3213 [88], 3300 [89], 3301\n   [90], 6222 [91]).  Some errata were not applicable due to other\n   changes (Errata IDs: 572 [92], 575 [93], 1565 [94], 1569 [95], 2296\n   [96], 3305 [97], 3602 [98]).\n\n   Changes to the specificb'122, and 6093 were incorporated.  See RFC 6093 for detailed\n   discussion of why these changes were necessary.\n\n   The discussion of the RTO from RFC 793 was updated to refer to RFC\n   6298.  The text on the RTO in RFC 1122 originally replaced the text\n   in RFC 793; however, RFC 2988 should have updated RFC 1122 and has\n   subsequently been obsoleted by RFC 6298.\n\n   RFC 1011 [18] contains a number of comments about RFC 793, including\n   some needed changes to the TCP specification.  These are expanded in\n   RFC 1122, which contains a collection of other changes and\n   clarifications to RFC 793.  The normative items impacting the\n   protocol have been incorporated here, though some historically useful\n   implementation advice and informative discussion from RFC 1122 is not\n   included here.  The present document, which is now the TCP\n   specification rather than RFC 793, updates RFC 1011, and the comments\n   noted in RFC 1011 have been incorporated.\n\n   b'his document\n   can\'t obsolete RFC 1122 entirely.  It is only marked as "updating"\n   RFC 1122; however, it should be understood to effectively obsolete\n   all of the material on TCP found in RFC 1122.\n\n   The more secure initial sequence number generation algorithm from RFC\n   6528 was incorporated.  See RFC 6528 for discussion of the attacks\n   that this mitigates, as well as advice on selecting PRF algorithms\n   and managing secret key data.\n\n   A note based on RFC 6429 was added to explicitly clarify that system\n   resource management concerns allow connection resources to be\n   reclaimed.  RFC 6429 is obsoleted in the sense that the clarification\n   it describes has been reflected within this base TCP specification.\n\n   The description of congestion control implementation was added based\n   on the set of documents that are IETF BCP or Standards Track on the\n   topic and the current state of common implementations.\n\n6.  IANA Considerations\n\n   In b'stry,\n   IANA has made several changes as described in this section.\n\n   RFC 3168 originally created this registry but only populated it with\n   the new bits defined in RFC 3168, neglecting the other bits that had\n   previously been described in RFC 793 and other documents.  Bit 7 has\n   since also been updated by RFC 8311 [54].\n\n   The "Bit" column has been renamed below as the "Bit Offset" column\n   because it references each header flag\'s offset within the 16-bit\n   aligned view of the TCP header in Figure 1.  The bits in offsets 0\n   through 3 are the TCP segment Data Offset field, and not header\n   flags.\n\n   IANA has added a column for "Assignment Notes".\n\n   IANA has assigned values as indicated below.\n\n      +========+===================+===========+====================+\n      | Bit    | Name              | Reference | Assignment Notes   |\n      | Offset |                   |           |                    |\n      +========+===================b'd for      | RFC 9293  |                    |\n      |        | future use        |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 5      | Reserved for      | RFC 9293  |                    |\n      |        | future use        |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 6      | Reserved for      | RFC 9293  |                    |\n      |        | future use        |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 7      | Reserved for      | RFC 8311  | Previously used by |\n      |        | future use        |           | Historic RFC 3540  |\n      |        |                   |           | as NS (Nonce Sum). |\n      +--------+-------------------+-----------+--------------------+\n      | 8      | CWR (Congestion   | RFC 3168  |                    |\n      |        | b'|\n      +--------+-------------------+-----------+--------------------+\n      | 9      | ECE (ECN-Echo)    | RFC 3168  |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 10     | Urgent pointer    | RFC 9293  |                    |\n      |        | field is          |           |                    |\n      |        | significant (URG) |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 11     | Acknowledgment    | RFC 9293  |                    |\n      |        | field is          |           |                    |\n      |        | significant (ACK) |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 12     | Push function     | RFC 9293  |                    |\n      |        | (PSH)             |           |                    |\n      +--------+-------------------+-----------+-------------b'293  |                    |\n      |        | connection (RST)  |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 14     | Synchronize       | RFC 9293  |                    |\n      |        | sequence numbers  |           |                    |\n      |        | (SYN)             |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 15     | No more data from | RFC 9293  |                    |\n      |        | sender (FIN)      |           |                    |\n      +--------+-------------------+-----------+--------------------+\n\n                         Table 7: TCP Header Flags\n\n   The "TCP Header Flags" registry has also been moved to a subregistry\n   under the global "Transmission Control Protocol (TCP) Parameters"\n   registry <https://www.iana.org/assignments/tcp-parameters/>.\n\n   The registry\'s Registration Procedure remains Stab' this document, and the Note has\n   been removed.\n\n7.  Security and Privacy Considerations\n\n   The TCP design includes only rudimentary security features that\n   improve the robustness and reliability of connections and application\n   data transfer, but there are no built-in cryptographic capabilities\n   to support any form of confidentiality, authentication, or other\n   typical security functions.  Non-cryptographic enhancements (e.g.,\n   [9]) have been developed to improve robustness of TCP connections to\n   particular types of attacks, but the applicability and protections of\n   non-cryptographic enhancements are limited (e.g., see Section 1.1 of\n   [9]).  Applications typically utilize lower-layer (e.g., IPsec) and\n   upper-layer (e.g., TLS) protocols to provide security and privacy for\n   TCP connections and application data carried in TCP.  Methods based\n   on TCP Options have been developed as well, to support some security\n   capabilities.\n\n   Inb'ction, and\n   authentication for TCP connections (including their control flags),\n   IPsec is the only current effective method.  For integrity protection\n   and authentication, the TCP Authentication Option (TCP-AO) [38] is\n   available, with a proposed extension to also provide confidentiality\n   for the segment payload.  Other methods discussed in this section may\n   provide confidentiality or integrity protection for the payload, but\n   for the TCP header only cover either a subset of the fields (e.g.,\n   tcpcrypt [57]) or none at all (e.g., TLS).  Other security features\n   that have been added to TCP (e.g., ISN generation, sequence number\n   checks, and others) are only capable of partially hindering attacks.\n\n   Applications using long-lived TCP flows have been vulnerable to\n   attacks that exploit the processing of control flags described in\n   earlier TCP specifications [33].  TCP-MD5 was a commonly implemented\n   TCP Option to support authenticatiob'd is now deprecated.  TCP-AO provides a capability to\n   protect long-lived TCP connections from attacks and has superior\n   properties to TCP-MD5.  It does not provide any privacy for\n   application data or for the TCP headers.\n\n   The "tcpcrypt" [57] experimental extension to TCP provides the\n   ability to cryptographically protect connection data.  Metadata\n   aspects of the TCP flow are still visible, but the application stream\n   is well protected.  Within the TCP header, only the urgent pointer\n   and FIN flag are protected through tcpcrypt.\n\n   The TCP Roadmap [49] includes notes about several RFCs related to TCP\n   security.  Many of the enhancements provided by these RFCs have been\n   integrated into the present document, including ISN generation,\n   mitigating blind in-window attacks, and improving handling of soft\n   errors and ICMP packets.  These are all discussed in greater detail\n   in the referenced RFCs that originally described the changesb'ly, see RFC 6093 [39] for\n   discussion of security considerations related to the urgent pointer\n   field, which also discourages new applications from using the urgent\n   pointer.\n\n   Since TCP is often used for bulk transfer flows, some attacks are\n   possible that abuse the TCP congestion control logic.  An example is\n   "ACK-division" attacks.  Updates that have been made to the TCP\n   congestion control specifications include mechanisms like Appropriate\n   Byte Counting (ABC) [29] that act as mitigations to these attacks.\n\n   Other attacks are focused on exhausting the resources of a TCP\n   server.  Examples include SYN flooding [32] or wasting resources on\n   non-progressing connections [41].  Operating systems commonly\n   implement mitigations for these attacks.  Some common defenses also\n   utilize proxies, stateful firewalls, and other technologies outside\n   the end-host TCP implementation.\n\n   The concept of a protocol\'s "wire image" is describ'text headers expose more\n   metadata to nodes on the path than is strictly required to route the\n   packets to their destination.  On-path adversaries may be able to\n   leverage this metadata.  Lessons learned in this respect from TCP\n   have been applied in the design of newer transports like QUIC [60].\n   Additionally, based partly on experiences with TCP and its\n   extensions, there are considerations that might be applicable for\n   future TCP extensions and other transports that the IETF has\n   documented in RFC 9065 [61], along with IAB recommendations in RFC\n   8558 [58] and [67].\n\n   There are also methods of "fingerprinting" that can be used to infer\n   the host TCP implementation (operating system) version or platform\n   information.  These collect observations of several aspects, such as\n   the options present in segments, the ordering of options, the\n   specific behaviors in the case of various conditions, packet timing,\n   packet sizing, and othb'ermined by an implementer, and can use those observations to\n   identify information about the host and implementation.\n\n   Since ICMP message processing also can interact with TCP connections,\n   there is potential for ICMP-based attacks against TCP connections.\n   These are discussed in RFC 5927 [100], along with mitigations that\n   have been implemented.\n\n8.  References\n\n8.1.  Normative References\n\n   [1]        Postel, J., "Internet Protocol", STD 5, RFC 791,\n              DOI 10.17487/RFC0791, September 1981,\n              <https://www.rfc-editor.org/info/rfc791>.\n\n   [2]        Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,\n              DOI 10.17487/RFC1191, November 1990,\n              <https://www.rfc-editor.org/info/rfc1191>.\n\n   [3]        Bradner, S., "Key words for use in RFCs to Indicate\n              Requirement Levels", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.ob'er, F., and D. Black,\n              "Definition of the Differentiated Services Field (DS\n              Field) in the IPv4 and IPv6 Headers", RFC 2474,\n              DOI 10.17487/RFC2474, December 1998,\n              <https://www.rfc-editor.org/info/rfc2474>.\n\n   [5]        Floyd, S., "Congestion Control Principles", BCP 41,\n              RFC 2914, DOI 10.17487/RFC2914, September 2000,\n              <https://www.rfc-editor.org/info/rfc2914>.\n\n   [6]        Ramakrishnan, K., Floyd, S., and D. Black, "The Addition\n              of Explicit Congestion Notification (ECN) to IP",\n              RFC 3168, DOI 10.17487/RFC3168, September 2001,\n              <https://www.rfc-editor.org/info/rfc3168>.\n\n   [7]        Floyd, S. and M. Allman, "Specifying New Congestion\n              Control Algorithms", BCP 133, RFC 5033,\n              DOI 10.17487/RFC5033, August 2007,\n              <https://www.rfc-editor.org/info/rfc5033>.\n\n   [8]        Allman, M., Paxson, V., ab'C 5681, DOI 10.17487/RFC5681, September 2009,\n              <https://www.rfc-editor.org/info/rfc5681>.\n\n   [9]        Ramaiah, A., Stewart, R., and M. Dalal, "Improving TCP\'s\n              Robustness to Blind In-Window Attacks", RFC 5961,\n              DOI 10.17487/RFC5961, August 2010,\n              <https://www.rfc-editor.org/info/rfc5961>.\n\n   [10]       Paxson, V., Allman, M., Chu, J., and M. Sargent,\n              "Computing TCP\'s Retransmission Timer", RFC 6298,\n              DOI 10.17487/RFC6298, June 2011,\n              <https://www.rfc-editor.org/info/rfc6298>.\n\n   [11]       Gont, F., "Deprecation of ICMP Source Quench Messages",\n              RFC 6633, DOI 10.17487/RFC6633, May 2012,\n              <https://www.rfc-editor.org/info/rfc6633>.\n\n   [12]       Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174b'tocol, Version 6\n              (IPv6) Specification", STD 86, RFC 8200,\n              DOI 10.17487/RFC8200, July 2017,\n              <https://www.rfc-editor.org/info/rfc8200>.\n\n   [14]       McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,\n              "Path MTU Discovery for IP version 6", STD 87, RFC 8201,\n              DOI 10.17487/RFC8201, July 2017,\n              <https://www.rfc-editor.org/info/rfc8201>.\n\n   [15]       Allman, M., "Requirements for Time-Based Loss Detection",\n              BCP 233, RFC 8961, DOI 10.17487/RFC8961, November 2020,\n              <https://www.rfc-editor.org/info/rfc8961>.\n\n8.2.  Informative References\n\n   [16]       Postel, J., "Transmission Control Protocol", STD 7,\n              RFC 793, DOI 10.17487/RFC0793, September 1981,\n              <https://www.rfc-editor.org/info/rfc793>.\n\n   [17]       Nagle, J., "Congestion Control in IP/TCP Internetworks",\n              RFC 896, DOI 10.17487/RFC0896, January 1984,b'   [18]       Reynolds, J. and J. Postel, "Official Internet protocols",\n              RFC 1011, DOI 10.17487/RFC1011, May 1987,\n              <https://www.rfc-editor.org/info/rfc1011>.\n\n   [19]       Braden, R., Ed., "Requirements for Internet Hosts -\n              Communication Layers", STD 3, RFC 1122,\n              DOI 10.17487/RFC1122, October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n\n   [20]       Almquist, P., "Type of Service in the Internet Protocol\n              Suite", RFC 1349, DOI 10.17487/RFC1349, July 1992,\n              <https://www.rfc-editor.org/info/rfc1349>.\n\n   [21]       Braden, R., "T/TCP -- TCP Extensions for Transactions\n              Functional Specification", RFC 1644, DOI 10.17487/RFC1644,\n              July 1994, <https://www.rfc-editor.org/info/rfc1644>.\n\n   [22]       Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP\n              Selective Acknowledgment Options", RFC 2018,\n              DOI 10b'.rfc-editor.org/info/rfc2018>.\n\n   [23]       Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner,\n              J., Heavens, I., Lahey, K., Semke, J., and B. Volz, "Known\n              TCP Implementation Problems", RFC 2525,\n              DOI 10.17487/RFC2525, March 1999,\n              <https://www.rfc-editor.org/info/rfc2525>.\n\n   [24]       Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",\n              RFC 2675, DOI 10.17487/RFC2675, August 1999,\n              <https://www.rfc-editor.org/info/rfc2675>.\n\n   [25]       Xiao, X., Hannan, A., Paxson, V., and E. Crabbe, "TCP\n              Processing of the IPv4 Precedence Field", RFC 2873,\n              DOI 10.17487/RFC2873, June 2000,\n              <https://www.rfc-editor.org/info/rfc2873>.\n\n   [26]       Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, "An\n              Extension to the Selective Acknowledgement (SACK) Option\n              for TCP", RFC 2883, DOI 10.17487/RFC2883, July 2b'883>.\n\n   [27]       Lahey, K., "TCP Problems with Path MTU Discovery",\n              RFC 2923, DOI 10.17487/RFC2923, September 2000,\n              <https://www.rfc-editor.org/info/rfc2923>.\n\n   [28]       Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M.\n              Sooriyabandara, "TCP Performance Implications of Network\n              Path Asymmetry", BCP 69, RFC 3449, DOI 10.17487/RFC3449,\n              December 2002, <https://www.rfc-editor.org/info/rfc3449>.\n\n   [29]       Allman, M., "TCP Congestion Control with Appropriate Byte\n              Counting (ABC)", RFC 3465, DOI 10.17487/RFC3465, February\n              2003, <https://www.rfc-editor.org/info/rfc3465>.\n\n   [30]       Fenner, B., "Experimental Values In IPv4, IPv6, ICMPv4,\n              ICMPv6, UDP, and TCP Headers", RFC 4727,\n              DOI 10.17487/RFC4727, November 2006,\n              <https://www.rfc-editor.org/info/rfc4727>.\n\n   [31]       Mathis, M. and J. Heffner, "Packeb'1, DOI 10.17487/RFC4821, March 2007,\n              <https://www.rfc-editor.org/info/rfc4821>.\n\n   [32]       Eddy, W., "TCP SYN Flooding Attacks and Common\n              Mitigations", RFC 4987, DOI 10.17487/RFC4987, August 2007,\n              <https://www.rfc-editor.org/info/rfc4987>.\n\n   [33]       Touch, J., "Defending TCP Against Spoofing Attacks",\n              RFC 4953, DOI 10.17487/RFC4953, July 2007,\n              <https://www.rfc-editor.org/info/rfc4953>.\n\n   [34]       Culley, P., Elzur, U., Recio, R., Bailey, S., and J.\n              Carrier, "Marker PDU Aligned Framing for TCP\n              Specification", RFC 5044, DOI 10.17487/RFC5044, October\n              2007, <https://www.rfc-editor.org/info/rfc5044>.\n\n   [35]       Gont, F., "TCP\'s Reaction to Soft Errors", RFC 5461,\n              DOI 10.17487/RFC5461, February 2009,\n              <https://www.rfc-editor.org/info/rfc5461>.\n\n   [36]       StJohns, M., Atkinson, R., and G. Thomas, "Commb'CALIPSO)",\n              RFC 5570, DOI 10.17487/RFC5570, July 2009,\n              <https://www.rfc-editor.org/info/rfc5570>.\n\n   [37]       Sandlund, K., Pelletier, G., and L-E. Jonsson, "The RObust\n              Header Compression (ROHC) Framework", RFC 5795,\n              DOI 10.17487/RFC5795, March 2010,\n              <https://www.rfc-editor.org/info/rfc5795>.\n\n   [38]       Touch, J., Mankin, A., and R. Bonica, "The TCP\n              Authentication Option", RFC 5925, DOI 10.17487/RFC5925,\n              June 2010, <https://www.rfc-editor.org/info/rfc5925>.\n\n   [39]       Gont, F. and A. Yourtchenko, "On the Implementation of the\n              TCP Urgent Mechanism", RFC 6093, DOI 10.17487/RFC6093,\n              January 2011, <https://www.rfc-editor.org/info/rfc6093>.\n\n   [40]       Gont, F., "Reducing the TIME-WAIT State Using TCP\n              Timestamps", BCP 159, RFC 6191, DOI 10.17487/RFC6191,\n              April 2011, <https://www.rfc-editor.org/ib'M., and A. Ramaiah, "TCP Sender\n              Clarification for Persist Condition", RFC 6429,\n              DOI 10.17487/RFC6429, December 2011,\n              <https://www.rfc-editor.org/info/rfc6429>.\n\n   [42]       Gont, F. and S. Bellovin, "Defending against Sequence\n              Number Attacks", RFC 6528, DOI 10.17487/RFC6528, February\n              2012, <https://www.rfc-editor.org/info/rfc6528>.\n\n   [43]       Borman, D., "TCP Options and Maximum Segment Size (MSS)",\n              RFC 6691, DOI 10.17487/RFC6691, July 2012,\n              <https://www.rfc-editor.org/info/rfc6691>.\n\n   [44]       Touch, J., "Updated Specification of the IPv4 ID Field",\n              RFC 6864, DOI 10.17487/RFC6864, February 2013,\n              <https://www.rfc-editor.org/info/rfc6864>.\n\n   [45]       Touch, J., "Shared Use of Experimental TCP Options",\n              RFC 6994, DOI 10.17487/RFC6994, August 2013,\n              <https://www.rfc-editor.org/info/rfc6994>.\nb'. Osterweil,\n              "Architectural Considerations of IP Anycast", RFC 7094,\n              DOI 10.17487/RFC7094, January 2014,\n              <https://www.rfc-editor.org/info/rfc7094>.\n\n   [47]       Borman, D., Braden, B., Jacobson, V., and R.\n              Scheffenegger, Ed., "TCP Extensions for High Performance",\n              RFC 7323, DOI 10.17487/RFC7323, September 2014,\n              <https://www.rfc-editor.org/info/rfc7323>.\n\n   [48]       Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP\n              Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014,\n              <https://www.rfc-editor.org/info/rfc7413>.\n\n   [49]       Duke, M., Braden, R., Eddy, W., Blanton, E., and A.\n              Zimmermann, "A Roadmap for Transmission Control Protocol\n              (TCP) Specification Documents", RFC 7414,\n              DOI 10.17487/RFC7414, February 2015,\n              <https://www.rfc-editor.org/info/rfc7414>.\n\n   [50]       Black,b'     (Diffserv) and Real-Time Communication", RFC 7657,\n              DOI 10.17487/RFC7657, November 2015,\n              <https://www.rfc-editor.org/info/rfc7657>.\n\n   [51]       Fairhurst, G. and M. Welzl, "The Benefits of Using\n              Explicit Congestion Notification (ECN)", RFC 8087,\n              DOI 10.17487/RFC8087, March 2017,\n              <https://www.rfc-editor.org/info/rfc8087>.\n\n   [52]       Fairhurst, G., Ed., Trammell, B., Ed., and M. Kuehlewind,\n              Ed., "Services Provided by IETF Transport Protocols and\n              Congestion Control Mechanisms", RFC 8095,\n              DOI 10.17487/RFC8095, March 2017,\n              <https://www.rfc-editor.org/info/rfc8095>.\n\n   [53]       Welzl, M., Tuexen, M., and N. Khademi, "On the Usage of\n              Transport Features Provided by IETF Transport Protocols",\n              RFC 8303, DOI 10.17487/RFC8303, February 2018,\n              <https://www.rfc-editor.org/info/rfc8303>.\n\n b't Congestion\n              Notification (ECN) Experimentation", RFC 8311,\n              DOI 10.17487/RFC8311, January 2018,\n              <https://www.rfc-editor.org/info/rfc8311>.\n\n   [55]       Chown, T., Loughney, J., and T. Winters, "IPv6 Node\n              Requirements", BCP 220, RFC 8504, DOI 10.17487/RFC8504,\n              January 2019, <https://www.rfc-editor.org/info/rfc8504>.\n\n   [56]       Trammell, B. and M. Kuehlewind, "The Wire Image of a\n              Network Protocol", RFC 8546, DOI 10.17487/RFC8546, April\n              2019, <https://www.rfc-editor.org/info/rfc8546>.\n\n   [57]       Bittau, A., Giffin, D., Handley, M., Mazieres, D., Slack,\n              Q., and E. Smith, "Cryptographic Protection of TCP Streams\n              (tcpcrypt)", RFC 8548, DOI 10.17487/RFC8548, May 2019,\n              <https://www.rfc-editor.org/info/rfc8548>.\n\n   [58]       Hardie, T., Ed., "Transport Protocol Path Signals",\n              RFC 8558, DOI 10.17487/Rb'r.org/info/rfc8558>.\n\n   [59]       Ford, A., Raiciu, C., Handley, M., Bonaventure, O., and C.\n              Paasch, "TCP Extensions for Multipath Operation with\n              Multiple Addresses", RFC 8684, DOI 10.17487/RFC8684, March\n              2020, <https://www.rfc-editor.org/info/rfc8684>.\n\n   [60]       Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based\n              Multiplexed and Secure Transport", RFC 9000,\n              DOI 10.17487/RFC9000, May 2021,\n              <https://www.rfc-editor.org/info/rfc9000>.\n\n   [61]       Fairhurst, G. and C. Perkins, "Considerations around\n              Transport Header Confidentiality, Network Operations, and\n              the Evolution of Internet Transport Protocols", RFC 9065,\n              DOI 10.17487/RFC9065, July 2021,\n              <https://www.rfc-editor.org/info/rfc9065>.\n\n   [62]       IANA, "Transmission Control Protocol (TCP) Parameters",\n              <https://www.iana.org/assignments/tb' IP Security/Compartment and\n              Precedence Information by TCP", Work in Progress,\n              Internet-Draft, draft-gont-tcpm-tcp-seccomp-prec-00, 29\n              March 2012, <https://datatracker.ietf.org/doc/html/draft-\n              gont-tcpm-tcp-seccomp-prec-00>.\n\n   [64]       Gont, F. and D. Borman, "On the Validation of TCP Sequence\n              Numbers", Work in Progress, Internet-Draft, draft-gont-\n              tcpm-tcp-seq-validation-04, 11 March 2019,\n              <https://datatracker.ietf.org/doc/html/draft-gont-tcpm-\n              tcp-seq-validation-04>.\n\n   [65]       Touch, J. and W. M. Eddy, "TCP Extended Data Offset\n              Option", Work in Progress, Internet-Draft, draft-ietf-\n              tcpm-tcp-edo-12, 15 April 2022,\n              <https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-\n              tcp-edo-12>.\n\n   [66]       McQuistin, S., Band, V., Jacob, D., and C. Perkins,\n              "Describing Protocb' Diagrams", Work in Progress, Internet-Draft, draft-\n              mcquistin-augmented-ascii-diagrams-10, 7 March 2022,\n              <https://datatracker.ietf.org/doc/html/draft-mcquistin-\n              augmented-ascii-diagrams-10>.\n\n   [67]       Thomson, M. and T. Pauly, "Long-Term Viability of Protocol\n              Extension Mechanisms", RFC 9170, DOI 10.17487/RFC9170,\n              December 2021, <https://www.rfc-editor.org/info/rfc9170>.\n\n   [68]       Minshall, G., "A Suggested Modification to Nagle\'s\n              Algorithm", Work in Progress, Internet-Draft, draft-\n              minshall-nagle-01, 18 June 1999,\n              <https://datatracker.ietf.org/doc/html/draft-minshall-\n              nagle-01>.\n\n   [69]       Dalal, Y. and C. Sunshine, "Connection Management in\n              Transport Protocols", Computer Networks, Vol. 2, No. 6,\n              pp. 454-473, DOI 10.1016/0376-5075(78)90053-3, December\n              1978, <https://doi.org/b' Touch, J., and W. Yui, "The TIME-WAIT state in\n              TCP and Its Effect on Busy Servers", Proceedings of IEEE\n              INFOCOM, pp. 1573-1583, DOI 10.1109/INFCOM.1999.752180,\n              March 1999, <https://doi.org/10.1109/INFCOM.1999.752180>.\n\n   [71]       Postel, J., "Comments on Action Items from the January\n              Meeting", IEN 177, March 1981,\n              <https://www.rfc-editor.org/ien/ien177.txt>.\n\n   [72]       "Segmentation Offloads", The Linux Kernel Documentation,\n              <https://www.kernel.org/doc/html/latest/networking/\n              segmentation-offloads.html>.\n\n   [73]       RFC Errata, Erratum ID 573, RFC 793,\n              <https://www.rfc-editor.org/errata/eid573>.\n\n   [74]       RFC Errata, Erratum ID 574, RFC 793,\n              <https://www.rfc-editor.org/errata/eid574>.\n\n   [75]       RFC Errata, Erratum ID 700, RFC 793,\n              <https://www.rfc-editor.org/errata/eid700>.\n\n   [76]       RFC b'.rfc-editor.org/errata/eid701>.\n\n   [77]       RFC Errata, Erratum ID 1283, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1283>.\n\n   [78]       RFC Errata, Erratum ID 1561, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1561>.\n\n   [79]       RFC Errata, Erratum ID 1562, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1562>.\n\n   [80]       RFC Errata, Erratum ID 1564, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1564>.\n\n   [81]       RFC Errata, Erratum ID 1571, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1571>.\n\n   [82]       RFC Errata, Erratum ID 1572, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1572>.\n\n   [83]       RFC Errata, Erratum ID 2297, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2297>.\n\n   [84]       RFC Errata, Erratum ID 2298, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2298>.\n\n   [85]       RFC Errata, Erratub'rrata/eid2748>.\n\n   [86]       RFC Errata, Erratum ID 2749, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2749>.\n\n   [87]       RFC Errata, Erratum ID 2934, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2934>.\n\n   [88]       RFC Errata, Erratum ID 3213, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3213>.\n\n   [89]       RFC Errata, Erratum ID 3300, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3300>.\n\n   [90]       RFC Errata, Erratum ID 3301, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3301>.\n\n   [91]       RFC Errata, Erratum ID 6222, RFC 793,\n              <https://www.rfc-editor.org/errata/eid6222>.\n\n   [92]       RFC Errata, Erratum ID 572, RFC 793,\n              <https://www.rfc-editor.org/errata/eid572>.\n\n   [93]       RFC Errata, Erratum ID 575, RFC 793,\n              <https://www.rfc-editor.org/errata/eid575>.\n\n   [94]       RFC Errata, Erratum ID 1565, RFC 793,\b'[95]       RFC Errata, Erratum ID 1569, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1569>.\n\n   [96]       RFC Errata, Erratum ID 2296, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2296>.\n\n   [97]       RFC Errata, Erratum ID 3305, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3305>.\n\n   [98]       RFC Errata, Erratum ID 3602, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3602>.\n\n   [99]       RFC Errata, Erratum ID 4772, RFC 5961,\n              <https://www.rfc-editor.org/errata/eid4772>.\n\n   [100]      Gont, F., "ICMP Attacks against TCP", RFC 5927,\n              DOI 10.17487/RFC5927, July 2010,\n              <https://www.rfc-editor.org/info/rfc5927>.\n\nAppendix A.  Other Implementation Notes\n\n   This section includes additional notes and references on TCP\n   implementation decisions that are currently not a part of the RFC\n   series or included within the TCP standard.  These items can bb'sensus to\n   include them in the standard.\n\nA.1.  IP Security Compartment and Precedence\n\n   The IPv4 specification [1] includes a precedence value in the (now\n   obsoleted) Type of Service (TOS) field.  It was modified in [20] and\n   then obsoleted by the definition of Differentiated Services\n   (Diffserv) [4].  Setting and conveying TOS between the network layer,\n   TCP implementation, and applications is obsolete and is replaced by\n   Diffserv in the current TCP specification.\n\n   RFC 793 required checking the IP security compartment and precedence\n   on incoming TCP segments for consistency within a connection and with\n   application requests.  Each of these aspects of IP have become\n   outdated, without specific updates to RFC 793.  The issues with\n   precedence were fixed by [25], which is Standards Track, and so this\n   present TCP specification includes those changes.  However, the state\n   of IP security options that may be used by Multi-Level Seb'rrently.\n\n   Resetting connections when incoming packets do not meet expected\n   security compartment or precedence expectations has been recognized\n   as a possible attack vector [63], and there has been discussion about\n   amending the TCP specification to prevent connections from being\n   aborted due to nonmatching IP security compartment and Diffserv\n   codepoint values.\n\nA.1.1.  Precedence\n\n   In Diffserv, the former precedence values are treated as Class\n   Selector codepoints, and methods for compatible treatment are\n   described in the Diffserv architecture.  The RFC TCP specification\n   defined by RFCs 793 and 1122 included logic intending to have\n   connections use the highest precedence requested by either endpoint\n   application, and to keep the precedence consistent throughout a\n   connection.  This logic from the obsolete TOS is not applicable to\n   Diffserv and should not be included in TCP implementations, though\n   changes to Diffserv vab'sion of this, see RFC 7657 (Sections 5.1, 5.3, and 6) [50].\n\n   The obsoleted TOS processing rules in TCP assumed bidirectional (or\n   symmetric) precedence values used on a connection, but the Diffserv\n   architecture is asymmetric.  Problems with the old TCP logic in this\n   regard were described in [25], and the solution described is to\n   ignore IP precedence in TCP.  Since RFC 2873 is a Standards Track\n   document (although not marked as updating RFC 793), current\n   implementations are expected to be robust in these conditions.  Note\n   that the Diffserv field value used in each direction is a part of the\n   interface between TCP and the network layer, and values in use can be\n   indicated both ways between TCP and the application.\n\nA.1.2.  MLS Systems\n\n   The IP Security Option (IPSO) and compartment defined in [1] was\n   refined in RFC 1038, which was later obsoleted by RFC 1108.  The\n   Commercial IP Security Option (CIPSO) is defined in FIPS-188\b'e vendors and\n   operating systems.  RFC 1108 is now Historic, though RFC 791 itself\n   has not been updated to remove the IP Security Option.  For IPv6, a\n   similar option (Common Architecture Label IPv6 Security Option\n   (CALIPSO)) has been defined [36].  RFC 793 includes logic that\n   includes the IP security/compartment information in treatment of TCP\n   segments.  References to the IP "security/compartment" in this\n   document may be relevant for Multi-Level Secure (MLS) system\n   implementers but can be ignored for non-MLS implementations,\n   consistent with running code on the Internet.  See Appendix A.1 for\n   further discussion.  Note that RFC 5570 describes some MLS networking\n   scenarios where IPSO, CIPSO, or CALIPSO may be used.  In these\n   special cases, TCP implementers should see Section 7.3.1 of RFC 5570\n   and follow the guidance in that document.\n\nA.2.  Sequence Number Validation\n\n   There are cases where the TCP sequence number validb'ssed.  This can result in\n   connection issues, as described in [64], which includes descriptions\n   of potential problems in conditions of simultaneous open, self-\n   connects, simultaneous close, and simultaneous window probes.  The\n   document also describes potential changes to the TCP specification to\n   mitigate the issue by expanding the acceptable sequence numbers.\n\n   In Internet usage of TCP, these conditions rarely occur.  Common\n   operating systems include different alternative mitigations, and the\n   standard has not been updated yet to codify one of them, but\n   implementers should consider the problems described in [64].\n\nA.3.  Nagle Modification\n\n   In common operating systems, both the Nagle algorithm and delayed\n   acknowledgments are implemented and enabled by default.  TCP is used\n   by many applications that have a request-response style of\n   communication, where the combination of the Nagle algorithm and\n   delayed acknowledgments b'cation to the Nagle algorithm is described in [68] that\n   improves the situation for these applications.\n\n   This modification is implemented in some common operating systems and\n   does not impact TCP interoperability.  Additionally, many\n   applications simply disable Nagle since this is generally supported\n   by a socket option.  The TCP standard has not been updated to include\n   this Nagle modification, but implementers may find it beneficial to\n   consider.\n\nA.4.  Low Watermark Settings\n\n   Some operating system kernel TCP implementations include socket\n   options that allow specifying the number of bytes in the buffer until\n   the socket layer will pass sent data to TCP (SO_SNDLOWAT) or to the\n   application on receiving (SO_RCVLOWAT).\n\n   In addition, another socket option (TCP_NOTSENT_LOWAT) can be used to\n   control the amount of unsent bytes in the write queue.  This can help\n   a sending TCP application to avoid creating large amounts of bufb'e, this may be useful\n   for applications that are multiplexing data from multiple upper-level\n   streams onto a connection, especially when streams may be a mix of\n   interactive/real-time and bulk data transfer.\n\nAppendix B.  TCP Requirement Summary\n\n   This section is adapted from RFC 1122.\n\n   Note that there is no requirement related to PLPMTUD in this list,\n   but that PLPMTUD is recommended.\n\n    +=================+=========+======+========+=====+========+======+\n    |     Feature     |  ReqID  | MUST | SHOULD | MAY | SHOULD | MUST |\n    |                 |         |      |        |     |  NOT   | NOT  |\n    +=================+=========+======+========+=====+========+======+\n    | PUSH flag                                                       |\n    +=================+=========+======+========+=====+========+======+\n    | Aggregate or    | MAY-16  |      |        |  X  |        |      |\n    | queue un-pushed |         |      |        |     |      b'   |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Sender collapse | SHLD-27 |      |   X    |     |        |      |\n    | successive PSH  |         |      |        |     |        |      |\n    | bits            |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | SEND call can   | MAY-15  |      |        |  X  |        |      |\n    | specify PUSH    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  If cannot:   | MUST-60 |      |        |     |        |  X   |\n    |    sender       |         |      |        |     |        |      |\n    |    buffer       |         |      |        |     |        |      |\n    |    indefinitely |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Ib'  |      |\n    |    PSH last     |         |      |        |     |        |      |\n    |    segment      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Notify          | MAY-17  |      |        |  X  |        |      |\n    | receiving ALP^1 |         |      |        |     |        |      |\n    | of PSH          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Send max size   | SHLD-28 |      |   X    |     |        |      |\n    | segment when    |         |      |        |     |        |      |\n    | possible        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Window                                                          |\n    +=================+=========+======+========+=====+========+======+\n    | Treat as        | MUb' unsigned number |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Handle as       | REC-1   |      |   X    |     |        |      |\n    | 32-bit number   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Shrink window   | SHLD-14 |      |        |     |   X    |      |\n    | from right      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Send new     | SHLD-15 |      |        |     |   X    |      |\n    |    data when    |         |      |        |     |        |      |\n    |    window       |         |      |        |     |        |      |\n    |    shrinks      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Retransmit   | SHLD-16 |      |   b" |         |      |        |     |        |      |\n    |    data within  |         |      |        |     |        |      |\n    |    window       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Time out     | SHLD-17 |      |        |     |   X    |      |\n    |    conn for     |         |      |        |     |        |      |\n    |    data past    |         |      |        |     |        |      |\n    |    right edge   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Robust against  | MUST-34 |  X   |        |     |        |      |\n    | shrinking       |         |      |        |     |        |      |\n    | window          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receiver's      | MAY-8   |      |        |  X  |    b'  |        |     |        |      |\n    | indefinitely    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Use standard    | MUST-35 |  X   |        |     |        |      |\n    | probing logic   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Sender probe    | MUST-36 |  X   |        |     |        |      |\n    | zero window     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  First probe  | SHLD-29 |      |   X    |     |        |      |\n    |    after RTO    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Exponential  | SHLD-30 |      |   X    |     |        |      |\n    |    backoff      |         |      |        |     |        |      |\n  b'-+--------+------+\n    | Allow window    | MUST-37 |  X   |        |     |        |      |\n    | stay zero       |         |      |        |     |        |      |\n    | indefinitely    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Retransmit old  | MAY-7   |      |        |  X  |        |      |\n    | data beyond     |         |      |        |     |        |      |\n    | SND.UNA+SND.WND |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Process RST and | MUST-66 |  X   |        |     |        |      |\n    | URG even with   |         |      |        |     |        |      |\n    | zero window     |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Urgent Data                                                     |\n    +=============b'=+\n    | Include support | MUST-30 |  X   |        |     |        |      |\n    | for urgent      |         |      |        |     |        |      |\n    | pointer         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Pointer         | MUST-62 |  X   |        |     |        |      |\n    | indicates first |         |      |        |     |        |      |\n    | non-urgent      |         |      |        |     |        |      |\n    | octet           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Arbitrary       | MUST-31 |  X   |        |     |        |      |\n    | length urgent   |         |      |        |     |        |      |\n    | data sequence   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Inform ALP^1    | MUST-32 | b"onously  |         |      |        |     |        |      |\n    | of urgent data  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP^1 can learn | MUST-33 |  X   |        |     |        |      |\n    | if/how much     |         |      |        |     |        |      |\n    | urgent data Q'd |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP employ the  | SHLD-13 |      |        |     |   X    |      |\n    | urgent          |         |      |        |     |        |      |\n    | mechanism       |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | TCP Options                                                     |\n    +=================+=========+======+========+=====+========+======+\n    | Support the     | MUST-4  |  X   |        |  b'   |      |        |     |        |      |\n    | option set      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receive TCP     | MUST-5  |  X   |        |     |        |      |\n    | Option in any   |         |      |        |     |        |      |\n    | segment         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Ignore          | MUST-6  |  X   |        |     |        |      |\n    | unsupported     |         |      |        |     |        |      |\n    | options         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Include length  | MUST-68 |  X   |        |     |        |      |\n    | for all options |         |      |        |     |        |      |\n    | except EOL+NOP  |         |      |        |     |        |   b'---+-----+--------+------+\n    | Cope with       | MUST-7  |  X   |        |     |        |      |\n    | illegal option  |         |      |        |     |        |      |\n    | length          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Process options | MUST-64 |  X   |        |     |        |      |\n    | regardless of   |         |      |        |     |        |      |\n    | word alignment  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Implement       | MUST-14 |  X   |        |     |        |      |\n    | sending &       |         |      |        |     |        |      |\n    | receiving MSS   |         |      |        |     |        |      |\n    | Option          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv4b'  |      |\n    | Option unless   |         |      |        |     |        |      |\n    | 536             |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv6 Send MSS   | SHLD-5  |      |   X    |     |        |      |\n    | Option unless   |         |      |        |     |        |      |\n    | 1220            |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Send MSS Option | MAY-3   |      |        |  X  |        |      |\n    | always          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv4 Send-MSS   | MUST-15 |  X   |        |     |        |      |\n    | default is 536  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv6 Send-MSS   | MUb' default is 1220 |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Calculate       | MUST-16 |  X   |        |     |        |      |\n    | effective send  |         |      |        |     |        |      |\n    | seg size        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | MSS accounts    | SHLD-6  |      |   X    |     |        |      |\n    | for varying MTU |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | MSS not sent on | MUST-65 |      |        |     |        |  X   |\n    | non-SYN         |         |      |        |     |        |      |\n    | segments        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | MSS value based | MUST-67 |  X   |   b' |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Pad with zero   | MUST-69 |  X   |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | TCP Checksums                                                   |\n    +=================+=========+======+========+=====+========+======+\n    | Sender compute  | MUST-2  |  X   |        |     |        |      |\n    | checksum        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receiver check  | MUST-3  |  X   |        |     |        |      |\n    | checksum        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | ISN Selection                                                   |\n    +=================+=========+======+========+=====+====b'  |        |     |        |      |\n    | clock-driven    |         |      |        |     |        |      |\n    | ISN generator   |         |      |        |     |        |      |\n    | component       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Secure ISN      | SHLD-1  |      |   X    |     |        |      |\n    | generator with  |         |      |        |     |        |      |\n    | a PRF component |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | PRF computable  | MUST-9  |      |        |     |        |  X   |\n    | from outside    |         |      |        |     |        |      |\n    | the host        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Opening Connections                                             |\n  b'=+========+======+\n    | Support         | MUST-10 |  X   |        |     |        |      |\n    | simultaneous    |         |      |        |     |        |      |\n    | open attempts   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | SYN-RECEIVED    | MUST-11 |  X   |        |     |        |      |\n    | remembers last  |         |      |        |     |        |      |\n    | state           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Passive OPEN    | MUST-41 |      |        |     |        |  X   |\n    | call interfere  |         |      |        |     |        |      |\n    | with others     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Function:       | MUST-42 |  X   |        |     |        |      |\n    | simultaneousb' |\n    | LISTENs for     |         |      |        |     |        |      |\n    | same port       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Ask IP for src  | MUST-44 |  X   |        |     |        |      |\n    | address for SYN |         |      |        |     |        |      |\n    | if necessary    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Otherwise,   | MUST-45 |  X   |        |     |        |      |\n    |    use local    |         |      |        |     |        |      |\n    |    addr of      |         |      |        |     |        |      |\n    |    connection   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | OPEN to         | MUST-46 |      |        |     |        |  X   |\n    | broadcast/      |         | b'st IP    |         |      |        |     |        |      |\n    | address         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Silently        | MUST-57 |  X   |        |     |        |      |\n    | discard seg to  |         |      |        |     |        |      |\n    | bcast/mcast     |         |      |        |     |        |      |\n    | addr            |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Closing Connections                                             |\n    +=================+=========+======+========+=====+========+======+\n    | RST can contain | SHLD-2  |      |   X    |     |        |      |\n    | data            |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Inform          | MUST-12 |  X   |        |  b'   |      |        |     |        |      |\n    | aborted conn    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Half-duplex     | MAY-1   |      |        |  X  |        |      |\n    | close           |         |      |        |     |        |      |\n    | connections     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Send RST to  | SHLD-3  |      |   X    |     |        |      |\n    |    indicate     |         |      |        |     |        |      |\n    |    data lost    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | In TIME-WAIT    | MUST-13 |  X   |        |     |        |      |\n    | state for 2MSL  |         |      |        |     |        |      |\n    | seconds         |         |      |        |     |        |   b'---+-----+--------+------+\n    | *  Accept SYN   | MAY-2   |      |        |  X  |        |      |\n    |    from TIME-   |         |      |        |     |        |      |\n    |    WAIT state   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Use          | SHLD-4  |      |   X    |     |        |      |\n    |    Timestamps   |         |      |        |     |        |      |\n    |    to reduce    |         |      |        |     |        |      |\n    |    TIME-WAIT    |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Retransmissions                                                 |\n    +=================+=========+======+========+=====+========+======+\n    | Implement       | MUST-19 |  X   |        |     |        |      |\n    | exponential     |         |      |        |     |        |      |\n    | backb"  |      |\n    | start, and      |         |      |        |     |        |      |\n    | congestion      |         |      |        |     |        |      |\n    | avoidance       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Retransmit with | MAY-4   |      |        |  X  |        |      |\n    | same IP         |         |      |        |     |        |      |\n    | identity        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Karn's          | MUST-18 |  X   |        |     |        |      |\n    | algorithm       |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Generating ACKs                                                 |\n    +=================+=========+======+========+=====+========+======+\n    | Aggregate       | MUb" whenever        |         |      |        |     |        |      |\n    | possible        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Queue out-of-   | SHLD-31 |      |   X    |     |        |      |\n    | order segments  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Process all Q'd | MUST-59 |  X   |        |     |        |      |\n    | before send ACK |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Send ACK for    | MAY-13  |      |        |  X  |        |      |\n    | out-of-order    |         |      |        |     |        |      |\n    | segment         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Delayed ACKs    | SHLD-18 |      |   b"-+---------+------+--------+-----+--------+------+\n    | *  Delay < 0.5  | MUST-40 |  X   |        |     |        |      |\n    |    seconds      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Every 2nd    | SHLD-19 |      |   X    |     |        |      |\n    |    full-sized   |         |      |        |     |        |      |\n    |    segment or   |         |      |        |     |        |      |\n    |    2*RMSS ACK'd |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receiver SWS-   | MUST-39 |  X   |        |     |        |      |\n    | Avoidance       |         |      |        |     |        |      |\n    | Algorithm       |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Sending Data                                         b'==+========+=====+========+======+\n    | Configurable    | MUST-49 |  X   |        |     |        |      |\n    | TTL             |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Sender SWS-     | MUST-38 |  X   |        |     |        |      |\n    | Avoidance       |         |      |        |     |        |      |\n    | Algorithm       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Nagle algorithm | SHLD-7  |      |   X    |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Application  | MUST-17 |  X   |        |     |        |      |\n    |    can disable  |         |      |        |     |        |      |\n    |    Nagle        |         |      |        |     |        |      |\n    |    algorithm    |         |      |        |     |        |      |\n  b'=+========+======+\n    | Connection Failures                                             |\n    +=================+=========+======+========+=====+========+======+\n    | Negative advice | MUST-20 |  X   |        |     |        |      |\n    | to IP on R1     |         |      |        |     |        |      |\n    | retransmissions |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Close           | MUST-20 |  X   |        |     |        |      |\n    | connection on   |         |      |        |     |        |      |\n    | R2              |         |      |        |     |        |      |\n    | retransmissions |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP^1 can set   | MUST-21 |  X   |        |     |        |      |\n    | R2              |         |      |        |     |        |      |\n    +-------------b'-+\n    | Inform ALP of   | SHLD-9  |      |   X    |     |        |      |\n    | R1<=retxs<R2    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Recommended     | SHLD-10 |      |   X    |     |        |      |\n    | value for R1    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Recommended     | SHLD-11 |      |   X    |     |        |      |\n    | value for R2    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Same mechanism  | MUST-22 |  X   |        |     |        |      |\n    | for SYNs        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  R2 at least  | MUST-23 |  X   |        |     |        |      |\n    |    3 minutes    |         | b'SYN      |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Send Keep-alive Packets                                         |\n    +=================+=========+======+========+=====+========+======+\n    | Send Keep-alive | MAY-5   |      |   X    |     |        |      |\n    | Packets:        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Application  | MUST-24 |  X   |        |     |        |      |\n    |    can request  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Default is   | MUST-25 |  X   |        |     |        |      |\n    |    "off"        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Only send if | MUST-26 |  X   |        |  b'   |      |        |     |        |      |\n    |    interval     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Interval     | MUST-27 |  X   |        |     |        |      |\n    |    configurable |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Default at   | MUST-28 |  X   |        |     |        |      |\n    |    least 2 hrs. |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Tolerant of  | MUST-29 |  X   |        |     |        |      |\n    |    lost ACKs    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Send with no | SHLD-12 |      |   X    |     |        |      |\n    |    data         |         |      |        |     |        |   b"---+-----+--------+------+\n    | *  Configurable | MAY-6   |      |        |  X  |        |      |\n    |    to send      |         |      |        |     |        |      |\n    |    garbage      |         |      |        |     |        |      |\n    |    octet        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | IP Options                                                      |\n    +=================+=========+======+========+=====+========+======+\n    | Ignore options  | MUST-50 |  X   |        |     |        |      |\n    | TCP doesn't     |         |      |        |     |        |      |\n    | understand      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Timestamp       | MAY-10  |      |   X    |     |        |      |\n    | support         |         |      |        |     |        |      |\n    +-----b'--+------+\n    | Record Route    | MAY-11  |      |   X    |     |        |      |\n    | support         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Source Route:   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  ALP^1 can    | MUST-51 |  X   |        |     |        |      |\n    |    specify      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *     Overrides | MUST-52 |  X   |        |     |        |      |\n    |       src route |         |      |        |     |        |      |\n    |       in        |         |      |        |     |        |      |\n    |       datagram  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Build return | MUb'    route from   |         |      |        |     |        |      |\n    |    src route    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Later src    | SHLD-24 |      |   X    |     |        |      |\n    |    route        |         |      |        |     |        |      |\n    |    overrides    |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Receiving ICMP Messages from IP                                 |\n    +=================+=========+======+========+=====+========+======+\n    | Receiving ICMP  | MUST-54 |  X   |        |     |        |      |\n    | messages from   |         |      |        |     |        |      |\n    | IP              |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Dest Unreach | SHLD-25 |  X   |   b' |         |      |        |     |        |      |\n    |    inform ALP   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Abort on     | MUST-56 |      |        |     |        |  X   |\n    |    Dest Unreach |         |      |        |     |        |      |\n    |    (0,1,5)      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Dest Unreach | SHLD-26 |      |   X    |     |        |      |\n    |    (2-4) =>     |         |      |        |     |        |      |\n    |    abort conn   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Source       | MUST-55 |  X   |        |     |        |      |\n    |    Quench =>    |         |      |        |     |        |      |\n    |    silent       |         |      |        |     |    b'  |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Abort on     | MUST-56 |      |        |     |        |  X   |\n    |    Time         |         |      |        |     |        |      |\n    |    Exceeded     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Abort on     | MUST-56 |      |        |     |        |  X   |\n    |    Param        |         |      |        |     |        |      |\n    |    Problem      |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Address Validation                                              |\n    +=================+=========+======+========+=====+========+======+\n    | Reject OPEN     | MUST-46 |  X   |        |     |        |      |\n    | call to invalid |         |      |        |     |        |      |\n  b' |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Reject SYN from | MUST-63 |  X   |        |     |        |      |\n    | invalid IP      |         |      |        |     |        |      |\n    | address         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Silently        | MUST-57 |  X   |        |     |        |      |\n    | discard SYN to  |         |      |        |     |        |      |\n    | bcast/mcast     |         |      |        |     |        |      |\n    | addr            |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | TCP/ALP Interface Services                                      |\n    +=================+=========+======+========+=====+========+======+\n    | Error Report    | MUST-47 |  X   |        |     |        |      |\n    | mechanism   b' |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP can disable | SHLD-20 |      |   X    |     |        |      |\n    | Error Report    |         |      |        |     |        |      |\n    | Routine         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP can specify | MUST-48 |  X   |        |     |        |      |\n    | Diffserv field  |         |      |        |     |        |      |\n    | for sending     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Passed       | SHLD-22 |      |   X    |     |        |      |\n    |    unchanged to |         |      |        |     |        |      |\n    |    IP           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP can change  | SHLD-21 | b'v field  |         |      |        |     |        |      |\n    | during          |         |      |        |     |        |      |\n    | connection      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP generally   | SHLD-23 |      |        |     |   X    |      |\n    | changing        |         |      |        |     |        |      |\n    | Diffserv during |         |      |        |     |        |      |\n    | conn.           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Pass received   | MAY-9   |      |        |  X  |        |      |\n    | Diffserv field  |         |      |        |     |        |      |\n    | up to ALP       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | FLUSH call      | MAY-14  |      |        |  b'---+------+--------+-----+--------+------+\n    | Optional local  | MUST-43 |  X   |        |     |        |      |\n    | IP addr param   |         |      |        |     |        |      |\n    | in OPEN         |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | RFC 5961 Support                                                |\n    +=================+=========+======+========+=====+========+======+\n    | Implement data  | MAY-12  |      |        |  X  |        |      |\n    | injection       |         |      |        |     |        |      |\n    | protection      |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Explicit Congestion Notification                                |\n    +=================+=========+======+========+=====+========+======+\n    | Support ECN     | SHLD-8  |      |   X    |     |        |   b'===+=====+========+======+\n    | Alternative Congestion Control                                  |\n    +=================+=========+======+========+=====+========+======+\n    | Implement       | MAY-18  |      |        |  X  |        |      |\n    | alternative     |         |      |        |     |        |      |\n    | conformant      |         |      |        |     |        |      |\n    | algorithm(s)    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n\n                     Table 8: TCP Requirements Summary\n\n   FOOTNOTES: (1) "ALP" means Application-Layer Program.\n\nAcknowledgments\n\n   This document is largely a revision of RFC 793, of which Jon Postel\n   was the editor.  Due to his excellent work, it was able to last for\n   three decades before we felt the need to revise it.\n\n   Andre Oppermann was a contributor and helped to edit the first\n   revision of this document.\n\n   We ab'up\n   chairs over the course of work on this document:\n\n   Michael Scharf\n\n\n   Yoshifumi Nishida\n\n\n   Pasi Sarolahti\n\n\n   Michael T\xc3\xbcxen\n\n\n   During the discussions of this work on the TCPM mailing list, in\n   working group meetings, and via area reviews, helpful comments,\n   critiques, and reviews were received from (listed alphabetically by\n   last name): Praveen Balasubramanian, David Borman, Mohamed Boucadair,\n   Bob Briscoe, Neal Cardwell, Yuchung Cheng, Martin Duke, Francis\n   Dupont, Ted Faber, Gorry Fairhurst, Fernando Gont, Rodney Grimes, Yi\n   Huang, Rahul Jadhav, Markku Kojo, Mike Kosek, Juhamatti Kuusisaari,\n   Kevin Lahey, Kevin Mason, Matt Mathis, Stephen McQuistin, Jonathan\n   Morton, Matt Olson, Tommy Pauly, Tom Petch, Hagen Paul Pfeifer, Kyle\n   Rose, Anthony Sabatini, Michael Scharf, Greg Skinner, Joe Touch,\n   Michael T\xc3\xbcxen, Reji Varghese, Bernie Volz, Tim Wicinski, Lloyd Wood,\n   and Alex Zimmermann.\n\n   Joe Toucb"arameters and PMTUD/PLPMTUD recommendations.  Markku\n   Kojo helped put together the text in the section on TCP Congestion\n   Control.\n\n   This document includes content from errata that were reported by\n   (listed chronologically): Yin Shuming, Bob Braden, Morris M. Keesan,\n   Pei-chun Cheng, Constantin Hagemeier, Vishwas Manral, Mykyta\n   Yevstifeyev, EungJun Yi, Botong Huang, Charles Deng, Merlin Buge.\n\nAuthor's Address\n\n   Wesley M. Eddy (editor)\n   MTI Systems\n   United States of America\n   Email: wes@mti-systems.com\n"b'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'eled\n   and referenced in Appendix B, which summarizes implementation\n   requirements.\n\n   Sentences using "MUST" are labeled as "MUST-X" with X being a numeric\n   identifier enabling the requirement to be located easily when\n   referenced from Appendix B.\n\n   Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY"\n   with "MAY-X", and "RECOMMENDED" with "REC-X".\n\n   For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are\n   labeled the same as "SHOULD" and "MUST" instances.\n\n2.2.  Key TCP Concepts\n\n   TCP provides a reliable, in-order, byte-stream service to\n   applications.\n\n   The application byte-stream is conveyed over the network via TCP\n   segments, with each TCP segment sent as an Internet Protocol (IP)\n   datagram.\n\n   TCP reliability consists of detecting packet losses (via sequence\n   numbers) and errors (via per-segment checksums), as well as\n   correction via retransmission.\n\n   TCP supports unicast delivery ofb' use TCP without modifications,\n   though there is some risk of instability due to changes of lower-\n   layer forwarding behavior [46].\n\n   TCP is connection oriented, though it does not inherently include a\n   liveness detection capability.\n\n   Data flow is supported bidirectionally over TCP connections, though\n   applications are free to send data only unidirectionally, if they so\n   choose.\n\n   TCP uses port numbers to identify application services and to\n   multiplex distinct flows between hosts.\n\n   A more detailed description of TCP features compared to other\n   transport protocols can be found in Section 3.1 of [52].  Further\n   description of the motivations for developing TCP and its role in the\n   Internet protocol stack can be found in Section 2 of [16] and earlier\n   versions of the TCP specification.\n\n3.  Functional Specification\n\n3.1.  Header Format\n\n   TCP segments are sent as internet datagrams.  The Internet Protocol\n   (IP) header b'nd destination host addresses [1] [13].  A TCP header follows the IP\n   headers, supplying information specific to TCP.  This division allows\n   for the existence of host-level protocols other than TCP.  In the\n   early development of the Internet suite of protocols, the IP header\n   fields had been a part of TCP.\n\n   This document describes TCP, which uses TCP headers.\n\n   A TCP header, followed by any user data in the segment, is formatted\n   as follows, using the style from [66]:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |          Source Port          |       Destination Port        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                        Sequence Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-b'dgment Number                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |  Data |       |C|E|U|A|P|R|S|F|                               |\n      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |\n      |       |       |R|E|G|K|H|T|N|N|                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Checksum            |         Urgent Pointer        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                           [Options]                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               :\n      :                             Data                              :\n      :                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\b'e bit position.\n\n                        Figure 1: TCP Header Format\n\n   where:\n\n   Source Port:  16 bits\n\n     The source port number.\n\n   Destination Port:  16 bits\n\n     The destination port number.\n\n   Sequence Number:  32 bits\n\n     The sequence number of the first data octet in this segment (except\n     when the SYN flag is set).  If SYN is set, the sequence number is\n     the initial sequence number (ISN) and the first data octet is\n     ISN+1.\n\n   Acknowledgment Number:  32 bits\n\n     If the ACK control bit is set, this field contains the value of the\n     next sequence number the sender of the segment is expecting to\n     receive.  Once a connection is established, this is always sent.\n\n   Data Offset (DOffset):  4 bits\n\n     The number of 32-bit words in the TCP header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integer multiple of 32 bits long.\n\n   Reserved (Rsrvd):  4 bits\b'\n     generated segments and must be ignored in received segments if the\n     corresponding future features are not implemented by the sending or\n     receiving host.\n\n   Control bits:  The control bits are also known as "flags".\n     Assignment is managed by IANA from the "TCP Header Flags" registry\n     [62].  The currently assigned control bits are CWR, ECE, URG, ACK,\n     PSH, RST, SYN, and FIN.\n\n     CWR:  1 bit\n\n         Congestion Window Reduced (see [6]).\n\n     ECE:  1 bit\n\n         ECN-Echo (see [6]).\n\n     URG:  1 bit\n\n         Urgent pointer field is significant.\n\n     ACK:  1 bit\n\n         Acknowledgment field is significant.\n\n     PSH:  1 bit\n\n         Push function (see the Send Call description in Section 3.9.1).\n\n     RST:  1 bit\n\n         Reset the connection.\n\n     SYN:  1 bit\n\n         Synchronize sequence numbers.\n\n     FIN:  1 bit\n\n         No more data from sender.\n\n   Window:  16 bits\n\n     The number of datb"the sender of this segment is willing to\n     accept.  The value is shifted when the window scaling extension is\n     used [47].\n\n     The window size MUST be treated as an unsigned number, or else\n     large window sizes will appear like negative windows and TCP will\n     not work (MUST-1).  It is RECOMMENDED that implementations will\n     reserve 32-bit fields for the send and receive window sizes in the\n     connection record and do all window computations with 32 bits (REC-\n     1).\n\n   Checksum:  16 bits\n\n     The checksum field is the 16-bit ones' complement of the ones'\n     complement sum of all 16-bit words in the header and text.  The\n     checksum computation needs to ensure the 16-bit alignment of the\n     data being summed.  If a segment contains an odd number of header\n     and text octets, alignment can be achieved by padding the last\n     octet with zeros on its right to form a 16-bit word for checksum\n     purposes.  The pad is not transmb'checksum, the checksum field itself is replaced\n     with zeros.\n\n     The checksum also covers a pseudo-header (Figure 2) conceptually\n     prefixed to the TCP header.  The pseudo-header is 96 bits for IPv4\n     and 320 bits for IPv6.  Including the pseudo-header in the checksum\n     gives the TCP connection protection against misrouted segments.\n     This information is carried in IP headers and is transferred across\n     the TCP/network interface in the arguments or results of calls by\n     the TCP implementation on the IP layer.\n\n                     +--------+--------+--------+--------+\n                     |           Source Address          |\n                     +--------+--------+--------+--------+\n                     |         Destination Address       |\n                     +--------+--------+--------+--------+\n                     |  zero  |  PTCL  |    TCP Length   |\n                     +--------+--------+--------+--------+\n\n               b'der components for IPv4:\n       Source Address:  the IPv4 source address in network byte order\n\n       Destination Address:  the IPv4 destination address in network\n          byte order\n\n       zero:  bits set to zero\n\n       PTCL:  the protocol number from the IP header\n\n       TCP Length:  the TCP header length plus the data length in octets\n          (this is not an explicitly transmitted quantity but is\n          computed), and it does not count the 12 octets of the pseudo-\n          header.\n\n     For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200\n     [13] and contains the IPv6 Source Address and Destination Address,\n     an Upper-Layer Packet Length (a 32-bit value otherwise equivalent\n     to TCP Length in the IPv4 pseudo-header), three bytes of zero\n     padding, and a Next Header value, which differs from the IPv6\n     header value if there are extension headers present between IPv6\n     and TCP.\n\n     The TCP checksum is neverb'he receiver MUST check it (MUST-3).\n\n   Urgent Pointer:  16 bits\n\n     This field communicates the current value of the urgent pointer as\n     a positive offset from the sequence number in this segment.  The\n     urgent pointer points to the sequence number of the octet following\n     the urgent data.  This field is only to be interpreted in segments\n     with the URG control bit set.\n\n   Options:  [TCP Option]; size(Options) == (DOffset-5)*32; present only\n     when DOffset > 5.  Note that this size expression also includes any\n     padding trailing the actual options present.\n\n     Options may occupy space at the end of the TCP header and are a\n     multiple of 8 bits in length.  All options are included in the\n     checksum.  An option may begin on any octet boundary.  There are\n     two cases for the format of an option:\n\n     Case 1:  A single octet of option-kind.\n\n     Case 2:  An octet of option-kind (Kind), an octet of option-length,\n        ab'counts the two octets of option-kind and option-\n     length as well as the option-data octets.\n\n     Note that the list of options may be shorter than the Data Offset\n     field might imply.  The content of the header beyond the End of\n     Option List Option MUST be header padding of zeros (MUST-69).\n\n     The list of all currently defined options is managed by IANA [62],\n     and each option is defined in other RFCs, as indicated there.  That\n     set includes experimental options that can be extended to support\n     multiple concurrent usages [45].\n\n     A given TCP implementation can support any currently defined\n     options, but the following options MUST be supported (MUST-4 --\n     note Maximum Segment Size Option support is also part of MUST-14 in\n     Section 3.7.1):\n\n               +======+========+============================+\n               | Kind | Length | Meaning                    |\n               +======+========+=======================b'ist Option. |\n               +------+--------+----------------------------+\n               | 1    | -      | No-Operation.              |\n               +------+--------+----------------------------+\n               | 2    | 4      | Maximum Segment Size.      |\n               +------+--------+----------------------------+\n\n                       Table 1: Mandatory Option Set\n\n     These options are specified in detail in Section 3.2.\n\n     A TCP implementation MUST be able to receive a TCP Option in any\n     segment (MUST-5).\n\n     A TCP implementation MUST (MUST-6) ignore without error any TCP\n     Option it does not implement, assuming that the option has a length\n     field.  All TCP Options except End of Option List Option (EOL) and\n     No-Operation (NOP) MUST have length fields, including all future\n     options (MUST-68).  TCP implementations MUST be prepared to handle\n     an illegal option length (e.g., zero); a suggested procedure is to\n     reb'   Note: There is ongoing work to extend the space available for TCP\n     Options, such as [65].\n\n   Data:  variable length\n\n     User data carried by the TCP segment.\n\n3.2.  Specific Option Definitions\n\n   A TCP Option, in the mandatory option set, is one of an End of Option\n   List Option, a No-Operation Option, or a Maximum Segment Size Option.\n\n   An End of Option List Option is formatted as follows:\n\n       0\n       0 1 2 3 4 5 6 7\n      +-+-+-+-+-+-+-+-+\n      |       0       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 0.\n\n     This option code indicates the end of the option list.  This might\n     not coincide with the end of the TCP header according to the Data\n     Offset field.  This is used at the end of all options, not the end\n     of each option, and need only be used if the end of the options\n     would not otherwise coincide with the end of the TCP header.\n\n   A No-Operation Option is formatted as follows:\n\b'   1       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 1.\n\n     This option code can be used between options, for example, to align\n     the beginning of a subsequent option on a word boundary.  There is\n     no guarantee that senders will use this option, so receivers MUST\n     be prepared to process options even if they do not begin on a word\n     boundary (MUST-64).\n\n   A Maximum Segment Size Option is formatted as follows:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |       2       |     Length    |   Maximum Segment Size (MSS)  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 2.\n\n     If this option is present, then it communicates the maximum receive\n     segment size at the TCP endpoint tb'reassembly limit.  This field may be\n     sent in the initial connection request (i.e., in segments with the\n     SYN control bit set) and MUST NOT be sent in other segments (MUST-\n     65).  If this option is not used, any segment size is allowed.  A\n     more complete description of this option is provided in\n     Section 3.7.1.\n\n   Length:  1 byte; Length == 4.\n\n     Length of the option in bytes.\n\n   Maximum Segment Size (MSS):  2 bytes.\n\n     The maximum receive segment size at the TCP endpoint that sends\n     this segment.\n\n3.2.1.  Other Common Options\n\n   Additional RFCs define some other commonly used options that are\n   recommended to implement for high performance but are not necessary\n   for basic TCP interoperability.  These are the TCP Selective\n   Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option\n   [47], and TCP Window Scale (WS) Option [47].\n\n3.2.2.  Experimental TCP Options\n\n   Experimental TCP Option values are defb"age for these experimental\n   values.\n\n3.3.  TCP Terminology Overview\n\n   This section includes an overview of key terms needed to understand\n   the detailed protocol operation in the rest of the document.  There\n   is a glossary of terms in Section 4.\n\n3.3.1.  Key Connection State Variables\n\n   Before we can discuss the operation of the TCP implementation in\n   detail, we need to introduce some detailed terminology.  The\n   maintenance of a TCP connection requires maintaining state for\n   several variables.  We conceive of these variables being stored in a\n   connection record called a Transmission Control Block or TCB.  Among\n   the variables stored in the TCB are the local and remote IP addresses\n   and port numbers, the IP security level, and compartment of the\n   connection (see Appendix A.1), pointers to the user's send and\n   receive buffers, pointers to the retransmit queue and to the current\n   segment.  In addition, several variables relating tb' the TCB.\n\n    +==========+=====================================================+\n    | Variable | Description                                         |\n    +==========+=====================================================+\n    | SND.UNA  | send unacknowledged                                 |\n    +----------+-----------------------------------------------------+\n    | SND.NXT  | send next                                           |\n    +----------+-----------------------------------------------------+\n    | SND.WND  | send window                                         |\n    +----------+-----------------------------------------------------+\n    | SND.UP   | send urgent pointer                                 |\n    +----------+-----------------------------------------------------+\n    | SND.WL1  | segment sequence number used for last window update |\n    +----------+-----------------------------------------------------+\n    | SND.WL2  | segment acknowledgmentb'date                                              |\n    +----------+-----------------------------------------------------+\n    | ISS      | initial send sequence number                        |\n    +----------+-----------------------------------------------------+\n\n                     Table 2: Send Sequence Variables\n\n              +==========+=================================+\n              | Variable | Description                     |\n              +==========+=================================+\n              | RCV.NXT  | receive next                    |\n              +----------+---------------------------------+\n              | RCV.WND  | receive window                  |\n              +----------+---------------------------------+\n              | RCV.UP   | receive urgent pointer          |\n              +----------+---------------------------------+\n              | IRS      | initial receive sequence number |\n              +----------+--------------b'eive Sequence Variables\n\n   The following diagrams may help to relate some of these variables to\n   the sequence space.\n\n                      1         2          3          4\n                 ----------|----------|----------|----------\n                        SND.UNA    SND.NXT    SND.UNA\n                                             +SND.WND\n\n           1 - old sequence numbers that have been acknowledged\n           2 - sequence numbers of unacknowledged data\n           3 - sequence numbers allowed for new data transmission\n           4 - future sequence numbers that are not yet allowed\n\n                       Figure 3: Send Sequence Space\n\n   The send window is the portion of the sequence space labeled 3 in\n   Figure 3.\n\n                          1          2          3\n                      ----------|----------|----------\n                             RCV.NXT    RCV.NXT\n                                       +RCV.WND\n\n           1 - old sequenceb'numbers allowed for new reception\n           3 - future sequence numbers that are not yet allowed\n\n                      Figure 4: Receive Sequence Space\n\n   The receive window is the portion of the sequence space labeled 2 in\n   Figure 4.\n\n   There are also some variables used frequently in the discussion that\n   take their values from the fields of the current segment.\n\n               +==========+===============================+\n               | Variable | Description                   |\n               +==========+===============================+\n               | SEG.SEQ  | segment sequence number       |\n               +----------+-------------------------------+\n               | SEG.ACK  | segment acknowledgment number |\n               +----------+-------------------------------+\n               | SEG.LEN  | segment length                |\n               +----------+-------------------------------+\n               | SEG.WND  | segment window           b'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'eled\n   and referenced in Appendix B, which summarizes implementation\n   requirements.\n\n   Sentences using "MUST" are labeled as "MUST-X" with X being a numeric\n   identifier enabling the requirement to be located easily when\n   referenced from Appendix B.\n\n   Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY"\n   with "MAY-X", and "RECOMMENDED" with "REC-X".\n\n   For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are\n   labeled the same as "SHOULD" and "MUST" instances.\n\n2.2.  Key TCP Concepts\n\n   TCP provides a reliable, in-order, byte-stream service to\n   applications.\n\n   The application byte-stream is conveyed over the network via TCP\n   segments, with each TCP segment sent as an Internet Protocol (IP)\n   datagram.\n\n   TCP reliability consists of detecting packet losses (via sequence\n   numbers) and errors (via per-segment checksums), as well as\n   correction via retransmission.\n\n   TCP supports unicast delivery ofb' use TCP without modifications,\n   though there is some risk of instability due to changes of lower-\n   layer forwarding behavior [46].\n\n   TCP is connection oriented, though it does not inherently include a\n   liveness detection capability.\n\n   Data flow is supported bidirectionally over TCP connections, though\n   applications are free to send data only unidirectionally, if they so\n   choose.\n\n   TCP uses port numbers to identify application services and to\n   multiplex distinct flows between hosts.\n\n   A more detailed description of TCP features compared to other\n   transport protocols can be found in Section 3.1 of [52].  Further\n   description of the motivations for developing TCP and its role in the\n   Internet protocol stack can be found in Section 2 of [16] and earlier\n   versions of the TCP specification.\n\n3.  Functional Specification\n\n3.1.  Header Format\n\n   TCP segments are sent as internet datagrams.  The Internet Protocol\n   (IP) header b'nd destination host addresses [1] [13].  A TCP header follows the IP\n   headers, supplying information specific to TCP.  This division allows\n   for the existence of host-level protocols other than TCP.  In the\n   early development of the Internet suite of protocols, the IP header\n   fields had been a part of TCP.\n\n   This document describes TCP, which uses TCP headers.\n\n   A TCP header, followed by any user data in the segment, is formatted\n   as follows, using the style from [66]:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |          Source Port          |       Destination Port        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                        Sequence Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-b'dgment Number                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |  Data |       |C|E|U|A|P|R|S|F|                               |\n      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |\n      |       |       |R|E|G|K|H|T|N|N|                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Checksum            |         Urgent Pointer        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                           [Options]                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               :\n      :                             Data                              :\n      :                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\b'e bit position.\n\n                        Figure 1: TCP Header Format\n\n   where:\n\n   Source Port:  16 bits\n\n     The source port number.\n\n   Destination Port:  16 bits\n\n     The destination port number.\n\n   Sequence Number:  32 bits\n\n     The sequence number of the first data octet in this segment (except\n     when the SYN flag is set).  If SYN is set, the sequence number is\n     the initial sequence number (ISN) and the first data octet is\n     ISN+1.\n\n   Acknowledgment Number:  32 bits\n\n     If the ACK control bit is set, this field contains the value of the\n     next sequence number the sender of the segment is expecting to\n     receive.  Once a connection is established, this is always sent.\n\n   Data Offset (DOffset):  4 bits\n\n     The number of 32-bit words in the TCP header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integer multiple of 32 bits long.\n\n   Reserved (Rsrvd):  4 bits\b'\n     generated segments and must be ignored in received segments if the\n     corresponding future features are not implemented by the sending or\n     receiving host.\n\n   Control bits:  The control bits are also known as "flags".\n     Assignment is managed by IANA from the "TCP Header Flags" registry\n     [62].  The currently assigned control bits are CWR, ECE, URG, ACK,\n     PSH, RST, SYN, and FIN.\n\n     CWR:  1 bit\n\n         Congestion Window Reduced (see [6]).\n\n     ECE:  1 bit\n\n         ECN-Echo (see [6]).\n\n     URG:  1 bit\n\n         Urgent pointer field is significant.\n\n     ACK:  1 bit\n\n         Acknowledgment field is significant.\n\n     PSH:  1 bit\n\n         Push function (see the Send Call description in Section 3.9.1).\n\n     RST:  1 bit\n\n         Reset the connection.\n\n     SYN:  1 bit\n\n         Synchronize sequence numbers.\n\n     FIN:  1 bit\n\n         No more data from sender.\n\n   Window:  16 bits\n\n     The number of datb"the sender of this segment is willing to\n     accept.  The value is shifted when the window scaling extension is\n     used [47].\n\n     The window size MUST be treated as an unsigned number, or else\n     large window sizes will appear like negative windows and TCP will\n     not work (MUST-1).  It is RECOMMENDED that implementations will\n     reserve 32-bit fields for the send and receive window sizes in the\n     connection record and do all window computations with 32 bits (REC-\n     1).\n\n   Checksum:  16 bits\n\n     The checksum field is the 16-bit ones' complement of the ones'\n     complement sum of all 16-bit words in the header and text.  The\n     checksum computation needs to ensure the 16-bit alignment of the\n     data being summed.  If a segment contains an odd number of header\n     and text octets, alignment can be achieved by padding the last\n     octet with zeros on its right to form a 16-bit word for checksum\n     purposes.  The pad is not transmb'checksum, the checksum field itself is replaced\n     with zeros.\n\n     The checksum also covers a pseudo-header (Figure 2) conceptually\n     prefixed to the TCP header.  The pseudo-header is 96 bits for IPv4\n     and 320 bits for IPv6.  Including the pseudo-header in the checksum\n     gives the TCP connection protection against misrouted segments.\n     This information is carried in IP headers and is transferred across\n     the TCP/network interface in the arguments or results of calls by\n     the TCP implementation on the IP layer.\n\n                     +--------+--------+--------+--------+\n                     |           Source Address          |\n                     +--------+--------+--------+--------+\n                     |         Destination Address       |\n                     +--------+--------+--------+--------+\n                     |  zero  |  PTCL  |    TCP Length   |\n                     +--------+--------+--------+--------+\n\n               b'der components for IPv4:\n       Source Address:  the IPv4 source address in network byte order\n\n       Destination Address:  the IPv4 destination address in network\n          byte order\n\n       zero:  bits set to zero\n\n       PTCL:  the protocol number from the IP header\n\n       TCP Length:  the TCP header length plus the data length in octets\n          (this is not an explicitly transmitted quantity but is\n          computed), and it does not count the 12 octets of the pseudo-\n          header.\n\n     For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200\n     [13] and contains the IPv6 Source Address and Destination Address,\n     an Upper-Layer Packet Length (a 32-bit value otherwise equivalent\n     to TCP Length in the IPv4 pseudo-header), three bytes of zero\n     padding, and a Next Header value, which differs from the IPv6\n     header value if there are extension headers present between IPv6\n     and TCP.\n\n     The TCP checksum is neverb'he receiver MUST check it (MUST-3).\n\n   Urgent Pointer:  16 bits\n\n     This field communicates the current value of the urgent pointer as\n     a positive offset from the sequence number in this segment.  The\n     urgent pointer points to the sequence number of the octet following\n     the urgent data.  This field is only to be interpreted in segments\n     with the URG control bit set.\n\n   Options:  [TCP Option]; size(Options) == (DOffset-5)*32; present only\n     when DOffset > 5.  Note that this size expression also includes any\n     padding trailing the actual options present.\n\n     Options may occupy space at the end of the TCP header and are a\n     multiple of 8 bits in length.  All options are included in the\n     checksum.  An option may begin on any octet boundary.  There are\n     two cases for the format of an option:\n\n     Case 1:  A single octet of option-kind.\n\n     Case 2:  An octet of option-kind (Kind), an octet of option-length,\n        ab'counts the two octets of option-kind and option-\n     length as well as the option-data octets.\n\n     Note that the list of options may be shorter than the Data Offset\n     field might imply.  The content of the header beyond the End of\n     Option List Option MUST be header padding of zeros (MUST-69).\n\n     The list of all currently defined options is managed by IANA [62],\n     and each option is defined in other RFCs, as indicated there.  That\n     set includes experimental options that can be extended to support\n     multiple concurrent usages [45].\n\n     A given TCP implementation can support any currently defined\n     options, but the following options MUST be supported (MUST-4 --\n     note Maximum Segment Size Option support is also part of MUST-14 in\n     Section 3.7.1):\n\n               +======+========+============================+\n               | Kind | Length | Meaning                    |\n               +======+========+=======================b'ist Option. |\n               +------+--------+----------------------------+\n               | 1    | -      | No-Operation.              |\n               +------+--------+----------------------------+\n               | 2    | 4      | Maximum Segment Size.      |\n               +------+--------+----------------------------+\n\n                       Table 1: Mandatory Option Set\n\n     These options are specified in detail in Section 3.2.\n\n     A TCP implementation MUST be able to receive a TCP Option in any\n     segment (MUST-5).\n\n     A TCP implementation MUST (MUST-6) ignore without error any TCP\n     Option it does not implement, assuming that the option has a length\n     field.  All TCP Options except End of Option List Option (EOL) and\n     No-Operation (NOP) MUST have length fields, including all future\n     options (MUST-68).  TCP implementations MUST be prepared to handle\n     an illegal option length (e.g., zero); a suggested procedure is to\n     reb'   Note: There is ongoing work to extend the space available for TCP\n     Options, such as [65].\n\n   Data:  variable length\n\n     User data carried by the TCP segment.\n\n3.2.  Specific Option Definitions\n\n   A TCP Option, in the mandatory option set, is one of an End of Option\n   List Option, a No-Operation Option, or a Maximum Segment Size Option.\n\n   An End of Option List Option is formatted as follows:\n\n       0\n       0 1 2 3 4 5 6 7\n      +-+-+-+-+-+-+-+-+\n      |       0       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 0.\n\n     This option code indicates the end of the option list.  This might\n     not coincide with the end of the TCP header according to the Data\n     Offset field.  This is used at the end of all options, not the end\n     of each option, and need only be used if the end of the options\n     would not otherwise coincide with the end of the TCP header.\n\n   A No-Operation Option is formatted as follows:\n\b'   1       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 1.\n\n     This option code can be used between options, for example, to align\n     the beginning of a subsequent option on a word boundary.  There is\n     no guarantee that senders will use this option, so receivers MUST\n     be prepared to process options even if they do not begin on a word\n     boundary (MUST-64).\n\n   A Maximum Segment Size Option is formatted as follows:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |       2       |     Length    |   Maximum Segment Size (MSS)  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 2.\n\n     If this option is present, then it communicates the maximum receive\n     segment size at the TCP endpoint tb'reassembly limit.  This field may be\n     sent in the initial connection request (i.e., in segments with the\n     SYN control bit set) and MUST NOT be sent in other segments (MUST-\n     65).  If this option is not used, any segment size is allowed.  A\n     more complete description of this option is provided in\n     Section 3.7.1.\n\n   Length:  1 byte; Length == 4.\n\n     Length of the option in bytes.\n\n   Maximum Segment Size (MSS):  2 bytes.\n\n     The maximum receive segment size at the TCP endpoint that sends\n     this segment.\n\n3.2.1.  Other Common Options\n\n   Additional RFCs define some other commonly used options that are\n   recommended to implement for high performance but are not necessary\n   for basic TCP interoperability.  These are the TCP Selective\n   Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option\n   [47], and TCP Window Scale (WS) Option [47].\n\n3.2.2.  Experimental TCP Options\n\n   Experimental TCP Option values are defb"age for these experimental\n   values.\n\n3.3.  TCP Terminology Overview\n\n   This section includes an overview of key terms needed to understand\n   the detailed protocol operation in the rest of the document.  There\n   is a glossary of terms in Section 4.\n\n3.3.1.  Key Connection State Variables\n\n   Before we can discuss the operation of the TCP implementation in\n   detail, we need to introduce some detailed terminology.  The\n   maintenance of a TCP connection requires maintaining state for\n   several variables.  We conceive of these variables being stored in a\n   connection record called a Transmission Control Block or TCB.  Among\n   the variables stored in the TCB are the local and remote IP addresses\n   and port numbers, the IP security level, and compartment of the\n   connection (see Appendix A.1), pointers to the user's send and\n   receive buffers, pointers to the retransmit queue and to the current\n   segment.  In addition, several variables relating tb' the TCB.\n\n    +==========+=====================================================+\n    | Variable | Description                                         |\n    +==========+=====================================================+\n    | SND.UNA  | send unacknowledged                                 |\n    +----------+-----------------------------------------------------+\n    | SND.NXT  | send next                                           |\n    +----------+-----------------------------------------------------+\n    | SND.WND  | send window                                         |\n    +----------+-----------------------------------------------------+\n    | SND.UP   | send urgent pointer                                 |\n    +----------+-----------------------------------------------------+\n    | SND.WL1  | segment sequence number used for last window update |\n    +----------+-----------------------------------------------------+\n    | SND.WL2  | segment acknowledgmentb'date                                              |\n    +----------+-----------------------------------------------------+\n    | ISS      | initial send sequence number                        |\n    +----------+-----------------------------------------------------+\n\n                     Table 2: Send Sequence Variables\n\n              +==========+=================================+\n              | Variable | Description                     |\n              +==========+=================================+\n              | RCV.NXT  | receive next                    |\n              +----------+---------------------------------+\n              | RCV.WND  | receive window                  |\n              +----------+---------------------------------+\n              | RCV.UP   | receive urgent pointer          |\n              +----------+---------------------------------+\n              | IRS      | initial receive sequence number |\n              +----------+--------------b'eive Sequence Variables\n\n   The following diagrams may help to relate some of these variables to\n   the sequence space.\n\n                      1         2          3          4\n                 ----------|----------|----------|----------\n                        SND.UNA    SND.NXT    SND.UNA\n                                             +SND.WND\n\n           1 - old sequence numbers that have been acknowledged\n           2 - sequence numbers of unacknowledged data\n           3 - sequence numbers allowed for new data transmission\n           4 - future sequence numbers that are not yet allowed\n\n                       Figure 3: Send Sequence Space\n\n   The send window is the portion of the sequence space labeled 3 in\n   Figure 3.\n\n                          1          2          3\n                      ----------|----------|----------\n                             RCV.NXT    RCV.NXT\n                                       +RCV.WND\n\n           1 - old sequenceb'numbers allowed for new reception\n           3 - future sequence numbers that are not yet allowed\n\n                      Figure 4: Receive Sequence Space\n\n   The receive window is the portion of the sequence space labeled 2 in\n   Figure 4.\n\n   There are also some variables used frequently in the discussion that\n   take their values from the fields of the current segment.\n\n               +==========+===============================+\n               | Variable | Description                   |\n               +==========+===============================+\n               | SEG.SEQ  | segment sequence number       |\n               +----------+-------------------------------+\n               | SEG.ACK  | segment acknowledgment number |\n               +----------+-------------------------------+\n               | SEG.LEN  | segment length                |\n               +----------+-------------------------------+\n               | SEG.WND  | segment window           b'---------+\n               | SEG.UP   | segment urgent pointer        |\n               +----------+-------------------------------+\n\n                    Table 4: Current Segment Variables\n\n3.3.2.  State Machine Overview\n\n   A connection progresses through a series of states during its\n   lifetime.  The states are: LISTEN, SYN-SENT, SYN-RECEIVED,\n   ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,\n   TIME-WAIT, and the fictional state CLOSED.  CLOSED is fictional\n   because it represents the state when there is no TCB, and therefore,\n   no connection.  Briefly the meanings of the states are:\n\n   LISTEN -  represents waiting for a connection request from any remote\n      TCP peer and port.\n\n   SYN-SENT -  represents waiting for a matching connection request\n      after having sent a connection request.\n\n   SYN-RECEIVED -  represents waiting for a confirming connection\n      request acknowledgment after having both received and sent a\n b'pen connection, data received can be\n      delivered to the user.  The normal state for the data transfer\n      phase of the connection.\n\n   FIN-WAIT-1 -  represents waiting for a connection termination request\n      from the remote TCP peer, or an acknowledgment of the connection\n      termination request previously sent.\n\n   FIN-WAIT-2 -  represents waiting for a connection termination request\n      from the remote TCP peer.\n\n   CLOSE-WAIT -  represents waiting for a connection termination request\n      from the local user.\n\n   CLOSING -  represents waiting for a connection termination request\n      acknowledgment from the remote TCP peer.\n\n   LAST-ACK -  represents waiting for an acknowledgment of the\n      connection termination request previously sent to the remote TCP\n      peer (this termination request sent to the remote TCP peer already\n      included an acknowledgment of the termination request sent from\n      the remote TCP peer).\n\n   TIME-b're\n      the remote TCP peer received the acknowledgment of its connection\n      termination request and to avoid new connections being impacted by\n      delayed segments from previous connections.\n\n   CLOSED -  represents no connection state at all.\n\n   A TCP connection progresses from one state to another in response to\n   events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,\n   ABORT, and STATUS; the incoming segments, particularly those\n   containing the SYN, ACK, RST, and FIN flags; and timeouts.\n\n   The OPEN call specifies whether connection establishment is to be\n   actively pursued, or to be passively waited for.\n\n   A passive OPEN request means that the process wants to accept\n   incoming connection requests, in contrast to an active OPEN\n   attempting to initiate a connection.\n\n   The state diagram in Figure 5 illustrates only state changes,\n   together with the causing events and resulting actions, but addresses\n   neither errorb'ate changes.  In a later section, more detail is offered with\n   respect to the reaction of the TCP implementation to events.  Some\n   state names are abbreviated or hyphenated differently in the diagram\n   from how they appear elsewhere in the document.\n\n   NOTA BENE:  This diagram is only a summary and must not be taken as\n      the total specification.  Many details are not included.\n\n                               +---------+ ---------\\      active OPEN\n                               |  CLOSED |            \\    -----------\n                               +---------+<---------\\   \\   create TCB\n                                 |     ^              \\   \\  snd SYN\n                    passive OPEN |     |   CLOSE        \\   \\\n                    ------------ |     | ----------       \\   \\\n                     create TCB  |     | delete TCB         \\   \\\n                                 V     |                      \\   \\\n             rcv RST (notb'--------->|  LISTEN |          ---------- |     |\n         /                     +---------+          delete TCB |     |\n        /           rcv SYN      |     |     SEND              |     |\n       /           -----------   |     |    -------            |     V\n   +--------+      snd SYN,ACK  /       \\   snd SYN          +--------+\n   |        |<-----------------           ------------------>|        |\n   |  SYN   |                    rcv SYN                     |  SYN   |\n   |  RCVD  |<-----------------------------------------------|  SENT  |\n   |        |                  snd SYN,ACK                   |        |\n   |        |------------------           -------------------|        |\n   +--------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +--------+\n      |         --------------   |     |   -----------\n      |                x         |     |     snd ACK\n      |                          V     V\n      |  CLOSE                 +---------+\n      | ----b'         +---------+\n      |                 CLOSE    |     |    rcv FIN\n      V                -------   |     |    -------\n   +---------+         snd FIN  /       \\   snd ACK         +---------+\n   |  FIN    |<----------------          ------------------>|  CLOSE  |\n   | WAIT-1  |------------------                            |   WAIT  |\n   +---------+          rcv FIN  \\                          +---------+\n     | rcv ACK of FIN   -------   |                          CLOSE  |\n     | --------------   snd ACK   |                         ------- |\n     V        x                   V                         snd FIN V\n   +---------+               +---------+                    +---------+\n   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|\n   +---------+               +---------+                    +---------+\n     |              rcv ACK of FIN |                 rcv ACK of FIN |\n     |  rcv FIN     -------------- |    Timeout=2MSL ----------b'-------        x       V\n      \\ snd ACK              +---------+delete TCB          +---------+\n        -------------------->|TIME-WAIT|------------------->| CLOSED  |\n                             +---------+                    +---------+\n\n                   Figure 5: TCP Connection State Diagram\n\n   The following notes apply to Figure 5:\n\n   Note 1:  The transition from SYN-RECEIVED to LISTEN on receiving a\n      RST is conditional on having reached SYN-RECEIVED after a passive\n      OPEN.\n\n   Note 2:  The figure omits a transition from FIN-WAIT-1 to TIME-WAIT\n      if a FIN is received and the local FIN is also acknowledged.\n\n   Note 3:  A RST can be sent from any state with a corresponding\n      transition to TIME-WAIT (see [70] for rationale).  These\n      transitions are not explicitly shown; otherwise, the diagram would\n      become very difficult to read.  Similarly, receipt of a RST from\n      any state results in a transition to LISTEN or CLOb'or legibility.\n\n3.4.  Sequence Numbers\n\n   A fundamental notion in the design is that every octet of data sent\n   over a TCP connection has a sequence number.  Since every octet is\n   sequenced, each of them can be acknowledged.  The acknowledgment\n   mechanism employed is cumulative so that an acknowledgment of\n   sequence number X indicates that all octets up to but not including X\n   have been received.  This mechanism allows for straightforward\n   duplicate detection in the presence of retransmission.  The numbering\n   scheme of octets within a segment is as follows: the first data octet\n   immediately following the header is the lowest numbered, and the\n   following octets are numbered consecutively.\n\n   It is essential to remember that the actual sequence number space is\n   finite, though large.  This space ranges from 0 to 2^32 - 1.  Since\n   the space is finite, all arithmetic dealing with sequence numbers\n   must be performed modulo 2^32.  This unb'uence numbers as they cycle from 2^32 - 1 to 0\n   again.  There are some subtleties to computer modulo arithmetic, so\n   great care should be taken in programming the comparison of such\n   values.  The symbol "=<" means "less than or equal" (modulo 2^32).\n\n   The typical kinds of sequence number comparisons that the TCP\n   implementation must perform include:\n\n   (a)  Determining that an acknowledgment refers to some sequence\n        number sent but not yet acknowledged.\n\n   (b)  Determining that all sequence numbers occupied by a segment have\n        been acknowledged (e.g., to remove the segment from a\n        retransmission queue).\n\n   (c)  Determining that an incoming segment contains sequence numbers\n        that are expected (i.e., that the segment "overlaps" the receive\n        window).\n\n   In response to sending data, the TCP endpoint will receive\n   acknowledgments.  The following comparisons are needed to process the\n   acknowledgments:\n\n   b'ND.NXT = next sequence number to be sent\n\n      SEG.ACK = acknowledgment from the receiving TCP peer (next\n      sequence number expected by the receiving TCP peer)\n\n      SEG.SEQ = first sequence number of a segment\n\n      SEG.LEN = the number of octets occupied by the data in the segment\n      (counting SYN and FIN)\n\n      SEG.SEQ+SEG.LEN-1 = last sequence number of a segment\n\n   A new acknowledgment (called an "acceptable ack") is one for which\n   the inequality below holds:\n\n      SND.UNA < SEG.ACK =< SND.NXT\n\n   A segment on the retransmission queue is fully acknowledged if the\n   sum of its sequence number and length is less than or equal to the\n   acknowledgment value in the incoming segment.\n\n   When data is received, the following comparisons are needed:\n\n      RCV.NXT = next sequence number expected on an incoming segment,\n      and is the left or lower edge of the receive window\n\n      RCV.NXT+RCV.WND-1 = last sequence number expected onb'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'eled\n   and referenced in Appendix B, which summarizes implementation\n   requirements.\n\n   Sentences using "MUST" are labeled as "MUST-X" with X being a numeric\n   identifier enabling the requirement to be located easily when\n   referenced from Appendix B.\n\n   Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY"\n   with "MAY-X", and "RECOMMENDED" with "REC-X".\n\n   For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are\n   labeled the same as "SHOULD" and "MUST" instances.\n\n2.2.  Key TCP Concepts\n\n   TCP provides a reliable, in-order, byte-stream service to\n   applications.\n\n   The application byte-stream is conveyed over the network via TCP\n   segments, with each TCP segment sent as an Internet Protocol (IP)\n   datagram.\n\n   TCP reliability consists of detecting packet losses (via sequence\n   numbers) and errors (via per-segment checksums), as well as\n   correction via retransmission.\n\n   TCP supports unicast delivery ofb' use TCP without modifications,\n   though there is some risk of instability due to changes of lower-\n   layer forwarding behavior [46].\n\n   TCP is connection oriented, though it does not inherently include a\n   liveness detection capability.\n\n   Data flow is supported bidirectionally over TCP connections, though\n   applications are free to send data only unidirectionally, if they so\n   choose.\n\n   TCP uses port numbers to identify application services and to\n   multiplex distinct flows between hosts.\n\n   A more detailed description of TCP features compared to other\n   transport protocols can be found in Section 3.1 of [52].  Further\n   description of the motivations for developing TCP and its role in the\n   Internet protocol stack can be found in Section 2 of [16] and earlier\n   versions of the TCP specification.\n\n3.  Functional Specification\n\n3.1.  Header Format\n\n   TCP segments are sent as internet datagrams.  The Internet Protocol\n   (IP) header b'nd destination host addresses [1] [13].  A TCP header follows the IP\n   headers, supplying information specific to TCP.  This division allows\n   for the existence of host-level protocols other than TCP.  In the\n   early development of the Internet suite of protocols, the IP header\n   fields had been a part of TCP.\n\n   This document describes TCP, which uses TCP headers.\n\n   A TCP header, followed by any user data in the segment, is formatted\n   as follows, using the style from [66]:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |          Source Port          |       Destination Port        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                        Sequence Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-b'dgment Number                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |  Data |       |C|E|U|A|P|R|S|F|                               |\n      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |\n      |       |       |R|E|G|K|H|T|N|N|                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Checksum            |         Urgent Pointer        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                           [Options]                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               :\n      :                             Data                              :\n      :                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\b'e bit position.\n\n                        Figure 1: TCP Header Format\n\n   where:\n\n   Source Port:  16 bits\n\n     The source port number.\n\n   Destination Port:  16 bits\n\n     The destination port number.\n\n   Sequence Number:  32 bits\n\n     The sequence number of the first data octet in this segment (except\n     when the SYN flag is set).  If SYN is set, the sequence number is\n     the initial sequence number (ISN) and the first data octet is\n     ISN+1.\n\n   Acknowledgment Number:  32 bits\n\n     If the ACK control bit is set, this field contains the value of the\n     next sequence number the sender of the segment is expecting to\n     receive.  Once a connection is established, this is always sent.\n\n   Data Offset (DOffset):  4 bits\n\n     The number of 32-bit words in the TCP header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integer multiple of 32 bits long.\n\n   Reserved (Rsrvd):  4 bits\b'\n     generated segments and must be ignored in received segments if the\n     corresponding future features are not implemented by the sending or\n     receiving host.\n\n   Control bits:  The control bits are also known as "flags".\n     Assignment is managed by IANA from the "TCP Header Flags" registry\n     [62].  The currently assigned control bits are CWR, ECE, URG, ACK,\n     PSH, RST, SYN, and FIN.\n\n     CWR:  1 bit\n\n         Congestion Window Reduced (see [6]).\n\n     ECE:  1 bit\n\n         ECN-Echo (see [6]).\n\n     URG:  1 bit\n\n         Urgent pointer field is significant.\n\n     ACK:  1 bit\n\n         Acknowledgment field is significant.\n\n     PSH:  1 bit\n\n         Push function (see the Send Call description in Section 3.9.1).\n\n     RST:  1 bit\n\n         Reset the connection.\n\n     SYN:  1 bit\n\n         Synchronize sequence numbers.\n\n     FIN:  1 bit\n\n         No more data from sender.\n\n   Window:  16 bits\n\n     The number of datb"the sender of this segment is willing to\n     accept.  The value is shifted when the window scaling extension is\n     used [47].\n\n     The window size MUST be treated as an unsigned number, or else\n     large window sizes will appear like negative windows and TCP will\n     not work (MUST-1).  It is RECOMMENDED that implementations will\n     reserve 32-bit fields for the send and receive window sizes in the\n     connection record and do all window computations with 32 bits (REC-\n     1).\n\n   Checksum:  16 bits\n\n     The checksum field is the 16-bit ones' complement of the ones'\n     complement sum of all 16-bit words in the header and text.  The\n     checksum computation needs to ensure the 16-bit alignment of the\n     data being summed.  If a segment contains an odd number of header\n     and text octets, alignment can be achieved by padding the last\n     octet with zeros on its right to form a 16-bit word for checksum\n     purposes.  The pad is not transmb'checksum, the checksum field itself is replaced\n     with zeros.\n\n     The checksum also covers a pseudo-header (Figure 2) conceptually\n     prefixed to the TCP header.  The pseudo-header is 96 bits for IPv4\n     and 320 bits for IPv6.  Including the pseudo-header in the checksum\n     gives the TCP connection protection against misrouted segments.\n     This information is carried in IP headers and is transferred across\n     the TCP/network interface in the arguments or results of calls by\n     the TCP implementation on the IP layer.\n\n                     +--------+--------+--------+--------+\n                     |           Source Address          |\n                     +--------+--------+--------+--------+\n                     |         Destination Address       |\n                     +--------+--------+--------+--------+\n                     |  zero  |  PTCL  |    TCP Length   |\n                     +--------+--------+--------+--------+\n\n               b'der components for IPv4:\n       Source Address:  the IPv4 source address in network byte order\n\n       Destination Address:  the IPv4 destination address in network\n          byte order\n\n       zero:  bits set to zero\n\n       PTCL:  the protocol number from the IP header\n\n       TCP Length:  the TCP header length plus the data length in octets\n          (this is not an explicitly transmitted quantity but is\n          computed), and it does not count the 12 octets of the pseudo-\n          header.\n\n     For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200\n     [13] and contains the IPv6 Source Address and Destination Address,\n     an Upper-Layer Packet Length (a 32-bit value otherwise equivalent\n     to TCP Length in the IPv4 pseudo-header), three bytes of zero\n     padding, and a Next Header value, which differs from the IPv6\n     header value if there are extension headers present between IPv6\n     and TCP.\n\n     The TCP checksum is neverb'he receiver MUST check it (MUST-3).\n\n   Urgent Pointer:  16 bits\n\n     This field communicates the current value of the urgent pointer as\n     a positive offset from the sequence number in this segment.  The\n     urgent pointer points to the sequence number of the octet following\n     the urgent data.  This field is only to be interpreted in segments\n     with the URG control bit set.\n\n   Options:  [TCP Option]; size(Options) == (DOffset-5)*32; present only\n     when DOffset > 5.  Note that this size expression also includes any\n     padding trailing the actual options present.\n\n     Options may occupy space at the end of the TCP header and are a\n     multiple of 8 bits in length.  All options are included in the\n     checksum.  An option may begin on any octet boundary.  There are\n     two cases for the format of an option:\n\n     Case 1:  A single octet of option-kind.\n\n     Case 2:  An octet of option-kind (Kind), an octet of option-length,\n        ab'counts the two octets of option-kind and option-\n     length as well as the option-data octets.\n\n     Note that the list of options may be shorter than the Data Offset\n     field might imply.  The content of the header beyond the End of\n     Option List Option MUST be header padding of zeros (MUST-69).\n\n     The list of all currently defined options is managed by IANA [62],\n     and each option is defined in other RFCs, as indicated there.  That\n     set includes experimental options that can be extended to support\n     multiple concurrent usages [45].\n\n     A given TCP implementation can support any currently defined\n     options, but the following options MUST be supported (MUST-4 --\n     note Maximum Segment Size Option support is also part of MUST-14 in\n     Section 3.7.1):\n\n               +======+========+============================+\n               | Kind | Length | Meaning                    |\n               +======+========+=======================b'ist Option. |\n               +------+--------+----------------------------+\n               | 1    | -      | No-Operation.              |\n               +------+--------+----------------------------+\n               | 2    | 4      | Maximum Segment Size.      |\n               +------+--------+----------------------------+\n\n                       Table 1: Mandatory Option Set\n\n     These options are specified in detail in Section 3.2.\n\n     A TCP implementation MUST be able to receive a TCP Option in any\n     segment (MUST-5).\n\n     A TCP implementation MUST (MUST-6) ignore without error any TCP\n     Option it does not implement, assuming that the option has a length\n     field.  All TCP Options except End of Option List Option (EOL) and\n     No-Operation (NOP) MUST have length fields, including all future\n     options (MUST-68).  TCP implementations MUST be prepared to handle\n     an illegal option length (e.g., zero); a suggested procedure is to\n     reb'   Note: There is ongoing work to extend the space available for TCP\n     Options, such as [65].\n\n   Data:  variable length\n\n     User data carried by the TCP segment.\n\n3.2.  Specific Option Definitions\n\n   A TCP Option, in the mandatory option set, is one of an End of Option\n   List Option, a No-Operation Option, or a Maximum Segment Size Option.\n\n   An End of Option List Option is formatted as follows:\n\n       0\n       0 1 2 3 4 5 6 7\n      +-+-+-+-+-+-+-+-+\n      |       0       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 0.\n\n     This option code indicates the end of the option list.  This might\n     not coincide with the end of the TCP header according to the Data\n     Offset field.  This is used at the end of all options, not the end\n     of each option, and need only be used if the end of the options\n     would not otherwise coincide with the end of the TCP header.\n\n   A No-Operation Option is formatted as follows:\n\b'   1       |\n      +-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 1.\n\n     This option code can be used between options, for example, to align\n     the beginning of a subsequent option on a word boundary.  There is\n     no guarantee that senders will use this option, so receivers MUST\n     be prepared to process options even if they do not begin on a word\n     boundary (MUST-64).\n\n   A Maximum Segment Size Option is formatted as follows:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |       2       |     Length    |   Maximum Segment Size (MSS)  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   where:\n\n   Kind:  1 byte; Kind == 2.\n\n     If this option is present, then it communicates the maximum receive\n     segment size at the TCP endpoint tb'reassembly limit.  This field may be\n     sent in the initial connection request (i.e., in segments with the\n     SYN control bit set) and MUST NOT be sent in other segments (MUST-\n     65).  If this option is not used, any segment size is allowed.  A\n     more complete description of this option is provided in\n     Section 3.7.1.\n\n   Length:  1 byte; Length == 4.\n\n     Length of the option in bytes.\n\n   Maximum Segment Size (MSS):  2 bytes.\n\n     The maximum receive segment size at the TCP endpoint that sends\n     this segment.\n\n3.2.1.  Other Common Options\n\n   Additional RFCs define some other commonly used options that are\n   recommended to implement for high performance but are not necessary\n   for basic TCP interoperability.  These are the TCP Selective\n   Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option\n   [47], and TCP Window Scale (WS) Option [47].\n\n3.2.2.  Experimental TCP Options\n\n   Experimental TCP Option values are defb"age for these experimental\n   values.\n\n3.3.  TCP Terminology Overview\n\n   This section includes an overview of key terms needed to understand\n   the detailed protocol operation in the rest of the document.  There\n   is a glossary of terms in Section 4.\n\n3.3.1.  Key Connection State Variables\n\n   Before we can discuss the operation of the TCP implementation in\n   detail, we need to introduce some detailed terminology.  The\n   maintenance of a TCP connection requires maintaining state for\n   several variables.  We conceive of these variables being stored in a\n   connection record called a Transmission Control Block or TCB.  Among\n   the variables stored in the TCB are the local and remote IP addresses\n   and port numbers, the IP security level, and compartment of the\n   connection (see Appendix A.1), pointers to the user's send and\n   receive buffers, pointers to the retransmit queue and to the current\n   segment.  In addition, several variables relating tb' the TCB.\n\n    +==========+=====================================================+\n    | Variable | Description                                         |\n    +==========+=====================================================+\n    | SND.UNA  | send unacknowledged                                 |\n    +----------+-----------------------------------------------------+\n    | SND.NXT  | send next                                           |\n    +----------+-----------------------------------------------------+\n    | SND.WND  | send window                                         |\n    +----------+-----------------------------------------------------+\n    | SND.UP   | send urgent pointer                                 |\n    +----------+-----------------------------------------------------+\n    | SND.WL1  | segment sequence number used for last window update |\n    +----------+-----------------------------------------------------+\n    | SND.WL2  | segment acknowledgmentb'date                                              |\n    +----------+-----------------------------------------------------+\n    | ISS      | initial send sequence number                        |\n    +----------+-----------------------------------------------------+\n\n                     Table 2: Send Sequence Variables\n\n              +==========+=================================+\n              | Variable | Description                     |\n              +==========+=================================+\n              | RCV.NXT  | receive next                    |\n              +----------+---------------------------------+\n              | RCV.WND  | receive window                  |\n              +----------+---------------------------------+\n              | RCV.UP   | receive urgent pointer          |\n              +----------+---------------------------------+\n              | IRS      | initial receive sequence number |\n              +----------+--------------b'eive Sequence Variables\n\n   The following diagrams may help to relate some of these variables to\n   the sequence space.\n\n                      1         2          3          4\n                 ----------|----------|----------|----------\n                        SND.UNA    SND.NXT    SND.UNA\n                                             +SND.WND\n\n           1 - old sequence numbers that have been acknowledged\n           2 - sequence numbers of unacknowledged data\n           3 - sequence numbers allowed for new data transmission\n           4 - future sequence numbers that are not yet allowed\n\n                       Figure 3: Send Sequence Space\n\n   The send window is the portion of the sequence space labeled 3 in\n   Figure 3.\n\n                          1          2          3\n                      ----------|----------|----------\n                             RCV.NXT    RCV.NXT\n                                       +RCV.WND\n\n           1 - old sequenceb'numbers allowed for new reception\n           3 - future sequence numbers that are not yet allowed\n\n                      Figure 4: Receive Sequence Space\n\n   The receive window is the portion of the sequence space labeled 2 in\n   Figure 4.\n\n   There are also some variables used frequently in the discussion that\n   take their values from the fields of the current segment.\n\n               +==========+===============================+\n               | Variable | Description                   |\n               +==========+===============================+\n               | SEG.SEQ  | segment sequence number       |\n               +----------+-------------------------------+\n               | SEG.ACK  | segment acknowledgment number |\n               +----------+-------------------------------+\n               | SEG.LEN  | segment length                |\n               +----------+-------------------------------+\n               | SEG.WND  | segment window           b'---------+\n               | SEG.UP   | segment urgent pointer        |\n               +----------+-------------------------------+\n\n                    Table 4: Current Segment Variables\n\n3.3.2.  State Machine Overview\n\n   A connection progresses through a series of states during its\n   lifetime.  The states are: LISTEN, SYN-SENT, SYN-RECEIVED,\n   ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,\n   TIME-WAIT, and the fictional state CLOSED.  CLOSED is fictional\n   because it represents the state when there is no TCB, and therefore,\n   no connection.  Briefly the meanings of the states are:\n\n   LISTEN -  represents waiting for a connection request from any remote\n      TCP peer and port.\n\n   SYN-SENT -  represents waiting for a matching connection request\n      after having sent a connection request.\n\n   SYN-RECEIVED -  represents waiting for a confirming connection\n      request acknowledgment after having both received and sent a\n b'pen connection, data received can be\n      delivered to the user.  The normal state for the data transfer\n      phase of the connection.\n\n   FIN-WAIT-1 -  represents waiting for a connection termination request\n      from the remote TCP peer, or an acknowledgment of the connection\n      termination request previously sent.\n\n   FIN-WAIT-2 -  represents waiting for a connection termination request\n      from the remote TCP peer.\n\n   CLOSE-WAIT -  represents waiting for a connection termination request\n      from the local user.\n\n   CLOSING -  represents waiting for a connection termination request\n      acknowledgment from the remote TCP peer.\n\n   LAST-ACK -  represents waiting for an acknowledgment of the\n      connection termination request previously sent to the remote TCP\n      peer (this termination request sent to the remote TCP peer already\n      included an acknowledgment of the termination request sent from\n      the remote TCP peer).\n\n   TIME-b're\n      the remote TCP peer received the acknowledgment of its connection\n      termination request and to avoid new connections being impacted by\n      delayed segments from previous connections.\n\n   CLOSED -  represents no connection state at all.\n\n   A TCP connection progresses from one state to another in response to\n   events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,\n   ABORT, and STATUS; the incoming segments, particularly those\n   containing the SYN, ACK, RST, and FIN flags; and timeouts.\n\n   The OPEN call specifies whether connection establishment is to be\n   actively pursued, or to be passively waited for.\n\n   A passive OPEN request means that the process wants to accept\n   incoming connection requests, in contrast to an active OPEN\n   attempting to initiate a connection.\n\n   The state diagram in Figure 5 illustrates only state changes,\n   together with the causing events and resulting actions, but addresses\n   neither errorb'ate changes.  In a later section, more detail is offered with\n   respect to the reaction of the TCP implementation to events.  Some\n   state names are abbreviated or hyphenated differently in the diagram\n   from how they appear elsewhere in the document.\n\n   NOTA BENE:  This diagram is only a summary and must not be taken as\n      the total specification.  Many details are not included.\n\n                               +---------+ ---------\\      active OPEN\n                               |  CLOSED |            \\    -----------\n                               +---------+<---------\\   \\   create TCB\n                                 |     ^              \\   \\  snd SYN\n                    passive OPEN |     |   CLOSE        \\   \\\n                    ------------ |     | ----------       \\   \\\n                     create TCB  |     | delete TCB         \\   \\\n                                 V     |                      \\   \\\n             rcv RST (notb'--------->|  LISTEN |          ---------- |     |\n         /                     +---------+          delete TCB |     |\n        /           rcv SYN      |     |     SEND              |     |\n       /           -----------   |     |    -------            |     V\n   +--------+      snd SYN,ACK  /       \\   snd SYN          +--------+\n   |        |<-----------------           ------------------>|        |\n   |  SYN   |                    rcv SYN                     |  SYN   |\n   |  RCVD  |<-----------------------------------------------|  SENT  |\n   |        |                  snd SYN,ACK                   |        |\n   |        |------------------           -------------------|        |\n   +--------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +--------+\n      |         --------------   |     |   -----------\n      |                x         |     |     snd ACK\n      |                          V     V\n      |  CLOSE                 +---------+\n      | ----b'         +---------+\n      |                 CLOSE    |     |    rcv FIN\n      V                -------   |     |    -------\n   +---------+         snd FIN  /       \\   snd ACK         +---------+\n   |  FIN    |<----------------          ------------------>|  CLOSE  |\n   | WAIT-1  |------------------                            |   WAIT  |\n   +---------+          rcv FIN  \\                          +---------+\n     | rcv ACK of FIN   -------   |                          CLOSE  |\n     | --------------   snd ACK   |                         ------- |\n     V        x                   V                         snd FIN V\n   +---------+               +---------+                    +---------+\n   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|\n   +---------+               +---------+                    +---------+\n     |              rcv ACK of FIN |                 rcv ACK of FIN |\n     |  rcv FIN     -------------- |    Timeout=2MSL ----------b'-------        x       V\n      \\ snd ACK              +---------+delete TCB          +---------+\n        -------------------->|TIME-WAIT|------------------->| CLOSED  |\n                             +---------+                    +---------+\n\n                   Figure 5: TCP Connection State Diagram\n\n   The following notes apply to Figure 5:\n\n   Note 1:  The transition from SYN-RECEIVED to LISTEN on receiving a\n      RST is conditional on having reached SYN-RECEIVED after a passive\n      OPEN.\n\n   Note 2:  The figure omits a transition from FIN-WAIT-1 to TIME-WAIT\n      if a FIN is received and the local FIN is also acknowledged.\n\n   Note 3:  A RST can be sent from any state with a corresponding\n      transition to TIME-WAIT (see [70] for rationale).  These\n      transitions are not explicitly shown; otherwise, the diagram would\n      become very difficult to read.  Similarly, receipt of a RST from\n      any state results in a transition to LISTEN or CLOb'or legibility.\n\n3.4.  Sequence Numbers\n\n   A fundamental notion in the design is that every octet of data sent\n   over a TCP connection has a sequence number.  Since every octet is\n   sequenced, each of them can be acknowledged.  The acknowledgment\n   mechanism employed is cumulative so that an acknowledgment of\n   sequence number X indicates that all octets up to but not including X\n   have been received.  This mechanism allows for straightforward\n   duplicate detection in the presence of retransmission.  The numbering\n   scheme of octets within a segment is as follows: the first data octet\n   immediately following the header is the lowest numbered, and the\n   following octets are numbered consecutively.\n\n   It is essential to remember that the actual sequence number space is\n   finite, though large.  This space ranges from 0 to 2^32 - 1.  Since\n   the space is finite, all arithmetic dealing with sequence numbers\n   must be performed modulo 2^32.  This unb'uence numbers as they cycle from 2^32 - 1 to 0\n   again.  There are some subtleties to computer modulo arithmetic, so\n   great care should be taken in programming the comparison of such\n   values.  The symbol "=<" means "less than or equal" (modulo 2^32).\n\n   The typical kinds of sequence number comparisons that the TCP\n   implementation must perform include:\n\n   (a)  Determining that an acknowledgment refers to some sequence\n        number sent but not yet acknowledged.\n\n   (b)  Determining that all sequence numbers occupied by a segment have\n        been acknowledged (e.g., to remove the segment from a\n        retransmission queue).\n\n   (c)  Determining that an incoming segment contains sequence numbers\n        that are expected (i.e., that the segment "overlaps" the receive\n        window).\n\n   In response to sending data, the TCP endpoint will receive\n   acknowledgments.  The following comparisons are needed to process the\n   acknowledgments:\n\n   b'ND.NXT = next sequence number to be sent\n\n      SEG.ACK = acknowledgment from the receiving TCP peer (next\n      sequence number expected by the receiving TCP peer)\n\n      SEG.SEQ = first sequence number of a segment\n\n      SEG.LEN = the number of octets occupied by the data in the segment\n      (counting SYN and FIN)\n\n      SEG.SEQ+SEG.LEN-1 = last sequence number of a segment\n\n   A new acknowledgment (called an "acceptable ack") is one for which\n   the inequality below holds:\n\n      SND.UNA < SEG.ACK =< SND.NXT\n\n   A segment on the retransmission queue is fully acknowledged if the\n   sum of its sequence number and length is less than or equal to the\n   acknowledgment value in the incoming segment.\n\n   When data is received, the following comparisons are needed:\n\n      RCV.NXT = next sequence number expected on an incoming segment,\n      and is the left or lower edge of the receive window\n\n      RCV.NXT+RCV.WND-1 = last sequence number expected onb'the receive window\n\n      SEG.SEQ = first sequence number occupied by the incoming segment\n\n      SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming\n      segment\n\n   A segment is judged to occupy a portion of valid receive sequence\n   space if\n\n      RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n\n   or\n\n      RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND\n\n   The first part of this test checks to see if the beginning of the\n   segment falls in the window, the second part of the test checks to\n   see if the end of the segment falls in the window; if the segment\n   passes either part of the test, it contains data in the window.\n\n   Actually, it is a little more complicated than this.  Due to zero\n   windows and zero-length segments, we have four cases for the\n   acceptability of an incoming segment:\n\n       +=========+=========+======================================+\n       | Segment | Receive | Test                                 |\n       |b'    +=========+=========+======================================+\n       | 0       | 0       | SEG.SEQ = RCV.NXT                    |\n       +---------+---------+--------------------------------------+\n       | 0       | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |\n       +---------+---------+--------------------------------------+\n       | >0      | 0       | not acceptable                       |\n       +---------+---------+--------------------------------------+\n       | >0      | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |\n       |         |         |                                      |\n       |         |         | or                                   |\n       |         |         |                                      |\n       |         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1 <       |\n       |         |         | RCV.NXT+RCV.WND                      |\n       +---------+---------+--------------------------------------+\n\n                   Tablb' the receive window is zero no segments should be\n   acceptable except ACK segments.  Thus, it is possible for a TCP\n   implementation to maintain a zero receive window while transmitting\n   data and receiving ACKs.  A TCP receiver MUST process the RST and URG\n   fields of all incoming segments, even when the receive window is zero\n   (MUST-66).\n\n   We have taken advantage of the numbering scheme to protect certain\n   control information as well.  This is achieved by implicitly\n   including some control flags in the sequence space so they can be\n   retransmitted and acknowledged without confusion (i.e., one and only\n   one copy of the control will be acted upon).  Control information is\n   not physically carried in the segment data space.  Consequently, we\n   must adopt rules for implicitly assigning sequence numbers to\n   control.  The SYN and FIN are the only controls requiring this\n   protection, and these controls are used only at connection opening\n   ab's considered to\n   occur before the first actual data octet of the segment in which it\n   occurs, while the FIN is considered to occur after the last actual\n   data octet in a segment in which it occurs.  The segment length\n   (SEG.LEN) includes both data and sequence space-occupying controls.\n   When a SYN is present, then SEG.SEQ is the sequence number of the\n   SYN.\n\n3.4.1.  Initial Sequence Number Selection\n\n   A connection is defined by a pair of sockets.  Connections can be\n   reused.  New instances of a connection will be referred to as\n   incarnations of the connection.  The problem that arises from this is\n   -- "how does the TCP implementation identify duplicate segments from\n   previous incarnations of the connection?"  This problem becomes\n   apparent if the connection is being opened and closed in quick\n   succession, or if the connection breaks with loss of memory and is\n   then reestablished.  To support this, the TIME-WAIT state limits the\nb'e number selection\n   described below further protects against ambiguity about which\n   incarnation of a connection an incoming packet corresponds to.\n\n   To avoid confusion, we must prevent segments from one incarnation of\n   a connection from being used while the same sequence numbers may\n   still be present in the network from an earlier incarnation.  We want\n   to assure this even if a TCP endpoint loses all knowledge of the\n   sequence numbers it has been using.  When new connections are\n   created, an initial sequence number (ISN) generator is employed that\n   selects a new 32-bit ISN.  There are security issues that result if\n   an off-path attacker is able to predict or guess ISN values [42].\n\n   TCP initial sequence numbers are generated from a number sequence\n   that monotonically increases until it wraps, known loosely as a\n   "clock".  This clock is a 32-bit counter that typically increments at\n   least once every roughly 4 microseconds, althoughb', and need not persist across\n   reboots.  The clock component is intended to ensure that with a\n   Maximum Segment Lifetime (MSL), generated ISNs will be unique since\n   it cycles approximately every 4.55 hours, which is much longer than\n   the MSL.  Please note that for modern networks that support high data\n   rates where the connection might start and quickly advance sequence\n   numbers to overlap within the MSL, it is recommended to implement the\n   Timestamp Option as mentioned later in Section 3.4.3.\n\n   A TCP implementation MUST use the above type of "clock" for clock-\n   driven selection of initial sequence numbers (MUST-8), and SHOULD\n   generate its initial sequence numbers with the expression:\n\n   ISN = M + F(localip, localport, remoteip, remoteport, secretkey)\n\n   where M is the 4 microsecond timer, and F() is a pseudorandom\n   function (PRF) of the connection\'s identifying parameters ("localip,\n   localport, remoteip, remoteport") and a secreb'utable from the outside (MUST-9), or\n   an attacker could still guess at sequence numbers from the ISN used\n   for some other connection.  The PRF could be implemented as a\n   cryptographic hash of the concatenation of the TCP connection\n   parameters and some secret data.  For discussion of the selection of\n   a specific hash algorithm and management of the secret key data,\n   please see Section 3 of [42].\n\n   For each connection there is a send sequence number and a receive\n   sequence number.  The initial send sequence number (ISS) is chosen by\n   the data sending TCP peer, and the initial receive sequence number\n   (IRS) is learned during the connection-establishing procedure.\n\n   For a connection to be established or initialized, the two TCP peers\n   must synchronize on each other\'s initial sequence numbers.  This is\n   done in an exchange of connection-establishing segments carrying a\n   control bit called "SYN" (for synchronize) and the initial sequeb'e SYN bit are also\n   called "SYNs".  Hence, the solution requires a suitable mechanism for\n   picking an initial sequence number and a slightly involved handshake\n   to exchange the ISNs.\n\n   The synchronization requires each side to send its own initial\n   sequence number and to receive a confirmation of it in acknowledgment\n   from the remote TCP peer.  Each side must also receive the remote\n   peer\'s initial sequence number and send a confirming acknowledgment.\n\n       1) A --> B  SYN my sequence number is X\n       2) A <-- B  ACK your sequence number is X\n       3) A <-- B  SYN my sequence number is Y\n       4) A --> B  ACK your sequence number is Y\n\n   Because steps 2 and 3 can be combined in a single message this is\n   called the three-way (or three message) handshake (3WHS).\n\n   A 3WHS is necessary because sequence numbers are not tied to a global\n   clock in the network, and TCP implementations may have different\n   mechanisms for picking the Ib'ing whether the segment was an old one or not, unless\n   it remembers the last sequence number used on the connection (which\n   is not always possible), and so it must ask the sender to verify this\n   SYN.  The three-way handshake and the advantages of a clock-driven\n   scheme for ISN selection are discussed in [69].\n\n3.4.2.  Knowing When to Keep Quiet\n\n   A theoretical problem exists where data could be corrupted due to\n   confusion between old segments in the network and new ones after a\n   host reboots if the same port numbers and sequence space are reused.\n   The "quiet time" concept discussed below addresses this, and the\n   discussion of it is included for situations where it might be\n   relevant, although it is not felt to be necessary in most current\n   implementations.  The problem was more relevant earlier in the\n   history of TCP.  In practical use on the Internet today, the error-\n   prone conditions are sufficiently unlikely that it is safe to ib'(a) ISS and ephemeral port\n   randomization have reduced likelihood of reuse of port numbers and\n   sequence numbers after reboots, (b) the effective MSL of the Internet\n   has declined as links have become faster, and (c) reboots often\n   taking longer than an MSL anyways.\n\n   To be sure that a TCP implementation does not create a segment\n   carrying a sequence number that may be duplicated by an old segment\n   remaining in the network, the TCP endpoint must keep quiet for an MSL\n   before assigning any sequence numbers upon starting up or recovering\n   from a situation where memory of sequence numbers in use was lost.\n   For this specification the MSL is taken to be 2 minutes.  This is an\n   engineering choice, and may be changed if experience indicates it is\n   desirable to do so.  Note that if a TCP endpoint is reinitialized in\n   some sense, yet retains its memory of sequence numbers in use, then\n   it need not wait at all; it must only be sure to use seb'\n3.4.3.  The TCP Quiet Time Concept\n\n   Hosts that for any reason lose knowledge of the last sequence numbers\n   transmitted on each active (i.e., not closed) connection shall delay\n   emitting any TCP segments for at least the agreed MSL in the internet\n   system that the host is a part of.  In the paragraphs below, an\n   explanation for this specification is given.  TCP implementers may\n   violate the "quiet time" restriction, but only at the risk of causing\n   some old data to be accepted as new or new data rejected as old\n   duplicated data by some receivers in the internet system.\n\n   TCP endpoints consume sequence number space each time a segment is\n   formed and entered into the network output queue at a source host.\n   The duplicate detection and sequencing algorithm in TCP relies on the\n   unique binding of segment data to sequence space to the extent that\n   sequence numbers will not cycle through all 2^32 values before the\n   segment data bound tb'knowledged by the receiver and all duplicate copies of the segments\n   have "drained" from the internet.  Without such an assumption, two\n   distinct TCP segments could conceivably be assigned the same or\n   overlapping sequence numbers, causing confusion at the receiver as to\n   which data is new and which is old.  Remember that each segment is\n   bound to as many consecutive sequence numbers as there are octets of\n   data and SYN or FIN flags in the segment.\n\n   Under normal conditions, TCP implementations keep track of the next\n   sequence number to emit and the oldest awaiting acknowledgment so as\n   to avoid mistakenly reusing a sequence number before its first use\n   has been acknowledged.  This alone does not guarantee that old\n   duplicate data is drained from the net, so the sequence space has\n   been made large to reduce the probability that a wandering duplicate\n   will cause trouble upon arrival.  At 2 megabits/sec., it takes 4.5\n   hours to use ub'\n   segment lifetime in the net is not likely to exceed a few tens of\n   seconds, this is deemed ample protection for foreseeable nets, even\n   if data rates escalate to 10s of megabits/sec.  At 100 megabits/sec.,\n   the cycle time is 5.4 minutes, which may be a little short but still\n   within reason.  Much higher data rates are possible today, with\n   implications described in the final paragraph of this subsection.\n\n   The basic duplicate detection and sequencing algorithm in TCP can be\n   defeated, however, if a source TCP endpoint does not have any memory\n   of the sequence numbers it last used on a given connection.  For\n   example, if the TCP implementation were to start all connections with\n   sequence number 0, then upon the host rebooting, a TCP peer might re-\n   form an earlier connection (possibly after half-open connection\n   resolution) and emit packets with sequence numbers identical to or\n   overlapping with packets still in the network, whichb'ame connection.  In the absence of\n   knowledge about the sequence numbers used on a particular connection,\n   the TCP specification recommends that the source delay for MSL\n   seconds before emitting segments on the connection, to allow time for\n   segments from the earlier connection incarnation to drain from the\n   system.\n\n   Even hosts that can remember the time of day and use it to select\n   initial sequence number values are not immune from this problem\n   (i.e., even if time of day is used to select an initial sequence\n   number for each new connection incarnation).\n\n   Suppose, for example, that a connection is opened starting with\n   sequence number S.  Suppose that this connection is not used much and\n   that eventually the initial sequence number function (ISN(t)) takes\n   on a value equal to the sequence number, say S1, of the last segment\n   sent by this TCP endpoint on a particular connection.  Now suppose,\n   at this instant, the host rebootb'ion.  The initial sequence number chosen is S1 = ISN(t)\n   -- last used sequence number on old incarnation of connection!  If\n   the recovery occurs quickly enough, any old duplicates in the net\n   bearing sequence numbers in the neighborhood of S1 may arrive and be\n   treated as new packets by the receiver of the new incarnation of the\n   connection.\n\n   The problem is that the recovering host may not know for how long it\n   was down between rebooting nor does it know whether there are still\n   old duplicates in the system from earlier connection incarnations.\n\n   One way to deal with this problem is to deliberately delay emitting\n   segments for one MSL after recovery from a reboot -- this is the\n   "quiet time" specification.  Hosts that prefer to avoid waiting and\n   are willing to risk possible confusion of old and new packets at a\n   given destination may choose not to wait for the "quiet time".\n   Implementers may provide TCP users with the ability tob'er to wait after a reboot, or may\n   informally implement the "quiet time" for all connections.\n   Obviously, even where a user selects to "wait", this is not necessary\n   after the host has been "up" for at least MSL seconds.\n\n   To summarize: every segment emitted occupies one or more sequence\n   numbers in the sequence space, and the numbers occupied by a segment\n   are "busy" or "in use" until MSL seconds have passed.  Upon\n   rebooting, a block of space-time is occupied by the octets and SYN or\n   FIN flags of any potentially still in-flight segments.  If a new\n   connection is started too soon and uses any of the sequence numbers\n   in the space-time footprint of those potentially still in-flight\n   segments of the previous connection incarnation, there is a potential\n   sequence number overlap area that could cause confusion at the\n   receiver.\n\n   High-performance cases will have shorter cycle times than those in\n   the megabits per second that the b'bps, the cycle time is 34 seconds, only 3 seconds\n   at 10 Gbps, and around a third of a second at 100 Gbps.  In these\n   higher-performance cases, TCP Timestamp Options and Protection\n   Against Wrapped Sequences (PAWS) [47] provide the needed capability\n   to detect and discard old duplicates.\n\n3.5.  Establishing a Connection\n\n   The "three-way handshake" is the procedure used to establish a\n   connection.  This procedure normally is initiated by one TCP peer and\n   responded to by another TCP peer.  The procedure also works if two\n   TCP peers simultaneously initiate the procedure.  When simultaneous\n   open occurs, each TCP peer receives a SYN segment that carries no\n   acknowledgment after it has sent a SYN.  Of course, the arrival of an\n   old duplicate SYN segment can potentially make it appear, to the\n   recipient, that a simultaneous connection initiation is in progress.\n   Proper use of "reset" segments can disambiguate these cases.\n\n   Several eb"se\n   examples do not show connection synchronization using data-carrying\n   segments, this is perfectly legitimate, so long as the receiving TCP\n   endpoint doesn't deliver the data to the user until it is clear the\n   data is valid (e.g., the data is buffered at the receiver until the\n   connection reaches the ESTABLISHED state, given that the three-way\n   handshake reduces the possibility of false connections).  It is a\n   trade-off between memory and messages to provide information for this\n   checking.\n\n   The simplest 3WHS is shown in Figure 6.  The figures should be\n   interpreted in the following way.  Each line is numbered for\n   reference purposes.  Right arrows (-->) indicate departure of a TCP\n   segment from TCP Peer A to TCP Peer B or arrival of a segment at B\n   from A.  Left arrows (<--) indicate the reverse.  Ellipses (...)\n   indicate a segment that is still in the network (delayed).  Comments\n   appear in parentheses.  TCP connection stateb'val of the segment (whose contents are\n   shown in the center of each line).  Segment contents are shown in\n   abbreviated form, with sequence number, control flags, and ACK field.\n   Other fields such as window, addresses, lengths, and text have been\n   left out in the interest of clarity.\n\n       TCP Peer A                                           TCP Peer B\n\n   1.  CLOSED                                               LISTEN\n\n   2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n\n   3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n   4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED\n\n   5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED\n\n     Figure 6: Basic Three-Way Handshake for Connection Synchronization\n\n   In line 2 of Figure 6, TCP Peer A begins by sending a SYN segment\n   indicating that it will use sequence numbers starting with sequence\n   number 100.  In line b"eceived from TCP Peer A.  Note that the acknowledgment field\n   indicates TCP Peer B is now expecting to hear sequence 101,\n   acknowledging the SYN that occupied sequence 100.\n\n   At line 4, TCP Peer A responds with an empty segment containing an\n   ACK for TCP Peer B's SYN; and in line 5, TCP Peer A sends some data.\n   Note that the sequence number of the segment in line 5 is the same as\n   in line 4 because the ACK does not occupy sequence number space (if\n   it did, we would wind up ACKing ACKs!).\n\n   Simultaneous initiation is only slightly more complex, as is shown in\n   Figure 7.  Each TCP peer's connection state cycles from CLOSED to\n   SYN-SENT to SYN-RECEIVED to ESTABLISHED.\n\n       TCP Peer A                                       TCP Peer B\n\n   1.  CLOSED                                           CLOSED\n\n   2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...\n\n   3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT\n\n   4.   b'CEIVED\n\n   5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...\n\n   6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED\n\n   7.               ... <SEQ=100><ACK=301><CTL=SYN,ACK> --> ESTABLISHED\n\n             Figure 7: Simultaneous Connection Synchronization\n\n   A TCP implementation MUST support simultaneous open attempts (MUST-\n   10).\n\n   Note that a TCP implementation MUST keep track of whether a\n   connection has reached SYN-RECEIVED state as the result of a passive\n   OPEN or an active OPEN (MUST-11).\n\n   The principal reason for the three-way handshake is to prevent old\n   duplicate connection initiations from causing confusion.  To deal\n   with this, a special control message, reset, is specified.  If the\n   receiving TCP peer is in a non-synchronized state (i.e., SYN-SENT,\n   SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.\n   If the TCP peer is in one of the synchronized states (ESTABLISHED,\n   FIN-WAIb' it\n   aborts the connection and informs its user.  We discuss this latter\n   case under "half-open" connections below.\n\n       TCP Peer A                                           TCP Peer B\n\n   1.  CLOSED                                               LISTEN\n\n   2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...\n\n   3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED\n\n   4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n   5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN\n\n   6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n\n   7.  ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n   8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED\n\n                 Figure 8: Recovery from Old Duplicate SYN\n\n   As a simple example of recovery from old duplicates, consider\n   Figure 8.  At line 3, an old duplicate SYN arrives at TCP Peer B.\n   TCP Peer b' normally (line 4).  TCP Peer A detects that the ACK field is\n   incorrect and returns a RST (reset) with its SEQ field selected to\n   make the segment believable.  TCP Peer B, on receiving the RST,\n   returns to the LISTEN state.  When the original SYN finally arrives\n   at line 6, the synchronization proceeds normally.  If the SYN at line\n   6 had arrived before the RST, a more complex exchange might have\n   occurred with RSTs sent in both directions.\n\n3.5.1.  Half-Open Connections and Other Anomalies\n\n   An established connection is said to be "half-open" if one of the TCP\n   peers has closed or aborted the connection at its end without the\n   knowledge of the other, or if the two ends of the connection have\n   become desynchronized owing to a failure or reboot that resulted in\n   loss of memory.  Such connections will automatically become reset if\n   an attempt is made to send data in either direction.  However, half-\n   open connections are expected to b'r exists, then an attempt by the\n   user at site B to send any data on it will result in the site B TCP\n   endpoint receiving a reset control message.  Such a message indicates\n   to the site B TCP endpoint that something is wrong, and it is\n   expected to abort the connection.\n\n   Assume that two user processes A and B are communicating with one\n   another when a failure or reboot occurs causing loss of memory to A\'s\n   TCP implementation.  Depending on the operating system supporting A\'s\n   TCP implementation, it is likely that some error recovery mechanism\n   exists.  When the TCP endpoint is up again, A is likely to start\n   again from the beginning or from a recovery point.  As a result, A\n   will probably try to OPEN the connection again or try to SEND on the\n   connection it believes open.  In the latter case, it receives the\n   error message "connection not open" from the local (A\'s) TCP\n   implementation.  In an attempt to establish the connectionb'ning SYN.  This scenario\n   leads to the example shown in Figure 9.  After TCP Peer A reboots,\n   the user attempts to reopen the connection.  TCP Peer B, in the\n   meantime, thinks the connection is open.\n\n         TCP Peer A                                      TCP Peer B\n\n     1.  (REBOOT)                              (send 300,receive 100)\n\n     2.  CLOSED                                           ESTABLISHED\n\n     3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)\n\n     4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED\n\n     5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)\n\n     6.  SYN-SENT                                         CLOSED\n\n     7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->\n\n                  Figure 9: Half-Open Connection Discovery\n\n   When the SYN arrives at line 3, TCP Peer B, being in a synchronized\n   state, and the incoming segment outside the window, responds with an\n   acknowledgb' 100).  TCP Peer A sees that this segment does not acknowledge\n   anything it sent and, being unsynchronized, sends a reset (RST)\n   because it has detected a half-open connection.  TCP Peer B aborts at\n   line 5.  TCP Peer A will continue to try to establish the connection;\n   the problem is now reduced to the basic three-way handshake of\n   Figure 6.\n\n   An interesting alternative case occurs when TCP Peer A reboots and\n   TCP Peer B tries to send data on what it thinks is a synchronized\n   connection.  This is illustrated in Figure 10.  In this case, the\n   data arriving at TCP Peer A from TCP Peer B (line 2) is unacceptable\n   because no such connection exists, so TCP Peer A sends a RST.  The\n   RST is acceptable so TCP Peer B processes it and aborts the\n   connection.\n\n         TCP Peer A                                         TCP Peer B\n\n   1.  (REBOOT)                                  (send 300,receive 100)\n\n   2.  (??)    <-- <SEQ=300><ACK=100><Db'EQ=100><CTL=RST>                   --> (ABORT!!)\n\n        Figure 10: Active Side Causes Half-Open Connection Discovery\n\n   In Figure 11, two TCP Peers A and B with passive connections waiting\n   for SYN are depicted.  An old duplicate arriving at TCP Peer B (line\n   2) stirs B into action.  A SYN-ACK is returned (line 3) and causes\n   TCP A to generate a RST (the ACK in line 3 is not acceptable).  TCP\n   Peer B accepts the reset and returns to its passive LISTEN state.\n\n       TCP Peer A                                    TCP Peer B\n\n   1.  LISTEN                                        LISTEN\n\n   2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED\n\n   3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED\n\n   4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)\n\n   5.  LISTEN                                        LISTEN\n\n   Figure 11: Old Duplicate SYN Initiates a Reset on Two Passive Sockets\n\n   A variety of otheb'he following rules for RST generation and processing.\n\n3.5.2.  Reset Generation\n\n   A TCP user or application can issue a reset on a connection at any\n   time, though reset events are also generated by the protocol itself\n   when various error conditions occur, as described below.  The side of\n   a connection issuing a reset should enter the TIME-WAIT state, as\n   this generally helps to reduce the load on busy servers for reasons\n   described in [70].\n\n   As a general rule, reset (RST) is sent whenever a segment arrives\n   that apparently is not intended for the current connection.  A reset\n   must not be sent if it is not clear that this is the case.\n\n   There are three groups of states:\n\n   1.  If the connection does not exist (CLOSED), then a reset is sent\n       in response to any incoming segment except another reset.  A SYN\n       segment that does not match an existing connection is rejected by\n       this means.\n\n       If the incoming segmentb'number from the ACK field of the segment; otherwise, the\n       reset has sequence number zero and the ACK field is set to the\n       sum of the sequence number and segment length of the incoming\n       segment.  The connection remains in the CLOSED state.\n\n   2.  If the connection is in any non-synchronized state (LISTEN, SYN-\n       SENT, SYN-RECEIVED), and the incoming segment acknowledges\n       something not yet sent (the segment carries an unacceptable ACK),\n       or if an incoming segment has a security level or compartment\n       (Appendix A.1) that does not exactly match the level and\n       compartment requested for the connection, a reset is sent.\n\n       If the incoming segment has an ACK field, the reset takes its\n       sequence number from the ACK field of the segment; otherwise, the\n       reset has sequence number zero and the ACK field is set to the\n       sum of the sequence number and segment length of the incoming\n       segment.  The cb'connection is in a synchronized state (ESTABLISHED, FIN-\n       WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),\n       any unacceptable segment (out-of-window sequence number or\n       unacceptable acknowledgment number) must be responded to with an\n       empty acknowledgment segment (without any user data) containing\n       the current send sequence number and an acknowledgment indicating\n       the next sequence number expected to be received, and the\n       connection remains in the same state.\n\n       If an incoming segment has a security level or compartment that\n       does not exactly match the level and compartment requested for\n       the connection, a reset is sent and the connection goes to the\n       CLOSED state.  The reset takes its sequence number from the ACK\n       field of the incoming segment.\n\n3.5.3.  Reset Processing\n\n   In all states except SYN-SENT, all reset (RST) segments are validated\n   by checking their SEQ fieldb'he window.  In the SYN-SENT state (a RST received in\n   response to an initial SYN), the RST is acceptable if the ACK field\n   acknowledges the SYN.\n\n   The receiver of a RST first validates it, then changes state.  If the\n   receiver was in the LISTEN state, it ignores it.  If the receiver was\n   in SYN-RECEIVED state and had previously been in the LISTEN state,\n   then the receiver returns to the LISTEN state; otherwise, the\n   receiver aborts the connection and goes to the CLOSED state.  If the\n   receiver was in any other state, it aborts the connection and advises\n   the user and goes to the CLOSED state.\n\n   TCP implementations SHOULD allow a received RST segment to include\n   data (SHLD-2).  It has been suggested that a RST segment could\n   contain diagnostic data that explains the cause of the RST.  No\n   standard has yet been established for such data.\n\n3.6.  Closing a Connection\n\n   CLOSE is an operation meaning "I have no more data to send."  Tb'ject to ambiguous\n   interpretation, of course, since it may not be obvious how to treat\n   the receiving side of the connection.  We have chosen to treat CLOSE\n   in a simplex fashion.  The user who CLOSEs may continue to RECEIVE\n   until the TCP receiver is told that the remote peer has CLOSED also.\n   Thus, a program could initiate several SENDs followed by a CLOSE, and\n   then continue to RECEIVE until signaled that a RECEIVE failed because\n   the remote peer has CLOSED.  The TCP implementation will signal a\n   user, even if no RECEIVEs are outstanding, that the remote peer has\n   closed, so the user can terminate their side gracefully.  A TCP\n   implementation will reliably deliver all buffers SENT before the\n   connection was CLOSED so a user who expects no data in return need\n   only wait to hear the connection was CLOSED successfully to know that\n   all their data was received at the destination TCP endpoint.  Users\n   must keep reading connections theb'n indicates there is no more data.\n\n   There are essentially three cases:\n\n   1)  The user initiates by telling the TCP implementation to CLOSE the\n       connection (TCP Peer A in Figure 12).\n\n   2)  The remote TCP endpoint initiates by sending a FIN control signal\n       (TCP Peer B in Figure 12).\n\n   3)  Both users CLOSE simultaneously (Figure 13).\n\n   Case 1:  Local user initiates the close\n\n      In this case, a FIN segment can be constructed and placed on the\n      outgoing segment queue.  No further SENDs from the user will be\n      accepted by the TCP implementation, and it enters the FIN-WAIT-1\n      state.  RECEIVEs are allowed in this state.  All segments\n      preceding and including FIN will be retransmitted until\n      acknowledged.  When the other TCP peer has both acknowledged the\n      FIN and sent a FIN of its own, the first TCP peer can ACK this\n      FIN.  Note that a TCP endpoint receiving a FIN will ACK but not\n      send its own b'e 2:  TCP endpoint receives a FIN from the network\n\n      If an unsolicited FIN arrives from the network, the receiving TCP\n      endpoint can ACK it and tell the user that the connection is\n      closing.  The user will respond with a CLOSE, upon which the TCP\n      endpoint can send a FIN to the other TCP peer after sending any\n      remaining data.  The TCP endpoint then waits until its own FIN is\n      acknowledged whereupon it deletes the connection.  If an ACK is\n      not forthcoming, after the user timeout the connection is aborted\n      and the user is told.\n\n   Case 3:  Both users close simultaneously\n\n      A simultaneous CLOSE by users at both ends of a connection causes\n      FIN segments to be exchanged (Figure 13).  When all segments\n      preceding the FINs have been processed and acknowledged, each TCP\n      peer can ACK the FIN it has received.  Both will, upon receiving\n      these ACKs, delete the connection.\n\n       TCP Peer A        b'STABLISHED                                          ESTABLISHED\n\n   2.  (Close)\n       FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT\n\n   3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT\n\n   4.                                                       (Close)\n       TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK\n\n   5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED\n\n   6.  (2 MSL)\n       CLOSED\n\n                      Figure 12: Normal Close Sequence\n\n       TCP Peer A                                           TCP Peer B\n\n   1.  ESTABLISHED                                          ESTABLISHED\n\n   2.  (Close)                                              (Close)\n       FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1\n                   <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--\n                   ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->\n\n   3.  CLOSING     --> <SEQ=101><ACK=301>b'K=101><CTL=ACK>      <--\n                   ... <SEQ=101><ACK=301><CTL=ACK>      -->\n\n   4.  TIME-WAIT                                            TIME-WAIT\n       (2 MSL)                                              (2 MSL)\n       CLOSED                                               CLOSED\n\n                   Figure 13: Simultaneous Close Sequence\n\n   A TCP connection may terminate in two ways: (1) the normal TCP close\n   sequence using a FIN handshake (Figure 12), and (2) an "abort" in\n   which one or more RST segments are sent and the connection state is\n   immediately discarded.  If the local TCP connection is closed by the\n   remote side due to a FIN or RST received from the remote side, then\n   the local application MUST be informed whether it closed normally or\n   was aborted (MUST-12).\n\n\n3.6.1.  Half-Closed Connections\n\n   The normal TCP close sequence delivers buffered data reliably in both\n   directions.  Since the two directions of a TCP conneb'onnection to be "half closed",\n   i.e., closed in only one direction, and a host is permitted to\n   continue sending data in the open direction on a half-closed\n   connection.\n\n   A host MAY implement a "half-duplex" TCP close sequence, so that an\n   application that has called CLOSE cannot continue to read data from\n   the connection (MAY-1).  If such a host issues a CLOSE call while\n   received data is still pending in the TCP connection, or if new data\n   is received after CLOSE is called, its TCP implementation SHOULD send\n   a RST to show that data was lost (SHLD-3).  See [23], Section 2.17\n   for discussion.\n\n   When a connection is closed actively, it MUST linger in the TIME-WAIT\n   state for a time 2xMSL (Maximum Segment Lifetime) (MUST-13).\n   However, it MAY accept a new SYN from the remote TCP endpoint to\n   reopen the connection directly from TIME-WAIT state (MAY-2), if it:\n\n   (1)  assigns its initial sequence number for the new connection to b'used on the previous\n        connection incarnation, and\n\n   (2)  returns to TIME-WAIT state if the SYN turns out to be an old\n        duplicate.\n\n   When the TCP Timestamp Options are available, an improved algorithm\n   is described in [40] in order to support higher connection\n   establishment rates.  This algorithm for reducing TIME-WAIT is a Best\n   Current Practice that SHOULD be implemented since Timestamp Options\n   are commonly used, and using them to reduce TIME-WAIT provides\n   benefits for busy Internet servers (SHLD-4).\n\n3.7.  Segmentation\n\n   The term "segmentation" refers to the activity TCP performs when\n   ingesting a stream of bytes from a sending application and\n   packetizing that stream of bytes into TCP segments.  Individual TCP\n   segments often do not correspond one-for-one to individual send (or\n   socket write) calls from the application.  Applications may perform\n   writes at the granularity of messages in the upper-layer protocb'ndaries of TCP\n   segments sent and received and the boundaries of the read or write\n   buffers of user application data.  In some specific protocols, such\n   as Remote Direct Memory Access (RDMA) using Direct Data Placement\n   (DDP) and Marker PDU Aligned Framing (MPA) [34], there are\n   performance optimizations possible when the relation between TCP\n   segments and application data units can be controlled, and MPA\n   includes a specific mechanism for detecting and verifying this\n   relationship between TCP segments and application message data\n   structures, but this is specific to applications like RDMA.  In\n   general, multiple goals influence the sizing of TCP segments created\n   by a TCP implementation.\n\n   Goals driving the sending of larger segments include:\n\n   *  Reducing the number of packets in flight within the network.\n\n   *  Increasing processing efficiency and potential performance by\n      enabling a smaller number of interrupts and interb'd of TCP headers.\n\n   Note that the performance benefits of sending larger segments may\n   decrease as the size increases, and there may be boundaries where\n   advantages are reversed.  For instance, on some implementation\n   architectures, 1025 bytes within a segment could lead to worse\n   performance than 1024 bytes, due purely to data alignment on copy\n   operations.\n\n   Goals driving the sending of smaller segments include:\n\n   *  Avoiding sending a TCP segment that would result in an IP datagram\n      larger than the smallest MTU along an IP network path because this\n      results in either packet loss or packet fragmentation.  Making\n      matters worse, some firewalls or middleboxes may drop fragmented\n      packets or ICMP messages related to fragmentation.\n\n   *  Preventing delays to the application data stream, especially when\n      TCP is waiting on the application to generate more data, or when\n      the application is waiting on an event or ib'.\n\n   *  Enabling "fate sharing" between TCP segments and lower-layer data\n      units (e.g., below IP, for links with cell or frame sizes smaller\n      than the IP MTU).\n\n   Towards meeting these competing sets of goals, TCP includes several\n   mechanisms, including the Maximum Segment Size Option, Path MTU\n   Discovery, the Nagle algorithm, and support for IPv6 Jumbograms, as\n   discussed in the following subsections.\n\n3.7.1.  Maximum Segment Size Option\n\n   TCP endpoints MUST implement both sending and receiving the MSS\n   Option (MUST-14).\n\n   TCP implementations SHOULD send an MSS Option in every SYN segment\n   when its receive MSS differs from the default 536 for IPv4 or 1220\n   for IPv6 (SHLD-5), and MAY send it always (MAY-3).\n\n   If an MSS Option is not received at connection setup, TCP\n   implementations MUST assume a default send MSS of 536 (576 - 40) for\n   IPv4 or 1220 (1280 - 60) for IPv6 (MUST-15).\n\n   The maximum size of a segment thab'MUST be the smaller (MUST-16) of the send MSS\n   (that reflects the available reassembly buffer size at the remote\n   host, the EMTU_R [19]) and the largest transmission size permitted by\n   the IP layer (EMTU_S [19]):\n\n   Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize\n\n   where:\n\n   *  SendMSS is the MSS value received from the remote host, or the\n      default 536 for IPv4 or 1220 for IPv6, if no MSS Option is\n      received.\n\n   *  MMS_S is the maximum size for a transport-layer message that TCP\n      may send.\n\n   *  TCPhdrsize is the size of the fixed TCP header and any options.\n      This is 20 in the (rare) case that no options are present but may\n      be larger if TCP Options are to be sent.  Note that some options\n      might not be included on all segments, but that for each segment\n      sent, the sender should adjust the data length accordingly, within\n      the Eff.snd.MSS.\n\n   *  IPoptionsize is the size of any IPv4 opb' connection.  Note that some options\n      or extension headers might not be included on all packets, but\n      that for each segment sent, the sender should adjust the data\n      length accordingly, within the Eff.snd.MSS.\n\n   The MSS value to be sent in an MSS Option should be equal to the\n   effective MTU minus the fixed IP and TCP headers.  By ignoring both\n   IP and TCP Options when calculating the value for the MSS Option, if\n   there are any IP or TCP Options to be sent in a packet, then the\n   sender must decrease the size of the TCP data accordingly.  RFC 6691\n   [43] discusses this in greater detail.\n\n   The MSS value to be sent in an MSS Option must be less than or equal\n   to:\n\n      MMS_R - 20\n\n   where MMS_R is the maximum size for a transport-layer message that\n   can be received (and reassembled at the IP layer) (MUST-67).  TCP\n   obtains MMS_R and MMS_S from the IP layer; see the generic call\n   GET_MAXSIZES in Section 3.4 of RFC 1122.  b's, EMTU_R and EMTU_S [19].\n\n   When TCP is used in a situation where either the IP or TCP headers\n   are not fixed, the sender must reduce the amount of TCP data in any\n   given packet by the number of octets used by the IP and TCP options.\n   This has been a point of confusion historically, as explained in RFC\n   6691, Section 3.1.\n\n3.7.2.  Path MTU Discovery\n\n   A TCP implementation may be aware of the MTU on directly connected\n   links, but will rarely have insight about MTUs across an entire\n   network path.  For IPv4, RFC 1122 recommends an IP-layer default\n   effective MTU of less than or equal to 576 for destinations not\n   directly connected, and for IPv6 this would be 1280.  Using these\n   fixed values limits TCP connection performance and efficiency.\n   Instead, implementation of Path MTU Discovery (PMTUD) and\n   Packetization Layer Path MTU Discovery (PLPMTUD) is strongly\n   recommended in order for TCP to improve segmentation decisions.  Both\nb" avoid both on-\n   path (for IPv4) and source fragmentation (IPv4 and IPv6).\n\n   PMTUD for IPv4 [2] or IPv6 [14] is implemented in conjunction between\n   TCP, IP, and ICMP.  It relies both on avoiding source fragmentation\n   and setting the IPv4 DF (don't fragment) flag, the latter to inhibit\n   on-path fragmentation.  It relies on ICMP errors from routers along\n   the path whenever a segment is too large to traverse a link.  Several\n   adjustments to a TCP implementation with PMTUD are described in RFC\n   2923 in order to deal with problems experienced in practice [27].\n   PLPMTUD [31] is a Standards Track improvement to PMTUD that relaxes\n   the requirement for ICMP support across a path, and improves\n   performance in cases where ICMP is not consistently conveyed, but\n   still tries to avoid source fragmentation.  The mechanisms in all\n   four of these RFCs are recommended to be included in TCP\n   implementations.\n\n   The TCP MSS Option specifies an uppeb'ed (see [43]).  Hence, setting the value in the MSS\n   Option too small can impact the ability for PMTUD or PLPMTUD to find\n   a larger path MTU.  RFC 1191 discusses this implication of many older\n   TCP implementations setting the TCP MSS to 536 (corresponding to the\n   IPv4 576 byte default MTU) for non-local destinations, rather than\n   deriving it from the MTUs of connected interfaces as recommended.\n\n3.7.3.  Interfaces with Variable MTU Values\n\n   The effective MTU can sometimes vary, as when used with variable\n   compression, e.g., RObust Header Compression (ROHC) [37].  It is\n   tempting for a TCP implementation to advertise the largest possible\n   MSS, to support the most efficient use of compressed payloads.\n   Unfortunately, some compression schemes occasionally need to transmit\n   full headers (and thus smaller payloads) to resynchronize state at\n   their endpoint compressors/decompressors.  If the largest MTU is used\n   to calculate the value to b'ay interfere with compressor resynchronization.\n\n   As a result, when the effective MTU of an interface varies packet-to-\n   packet, TCP implementations SHOULD use the smallest effective MTU of\n   the interface to calculate the value to advertise in the MSS Option\n   (SHLD-6).\n\n3.7.4.  Nagle Algorithm\n\n   The "Nagle algorithm" was described in RFC 896 [17] and was\n   recommended in RFC 1122 [19] for mitigation of an early problem of\n   too many small packets being generated.  It has been implemented in\n   most current TCP code bases, sometimes with minor variations (see\n   Appendix A.3).\n\n   If there is unacknowledged data (i.e., SND.NXT > SND.UNA), then the\n   sending TCP endpoint buffers all user data (regardless of the PSH\n   bit) until the outstanding data has been acknowledged or until the\n   TCP endpoint can send a full-sized segment (Eff.snd.MSS bytes).\n\n   A TCP implementation SHOULD implement the Nagle algorithm to coalesce\n   short segments (Sb'on to disable the Nagle algorithm on an individual\n   connection (MUST-17).  In all cases, sending data is also subject to\n   the limitation imposed by the slow start algorithm [8].\n\n   Since there can be problematic interactions between the Nagle\n   algorithm and delayed acknowledgments, some implementations use minor\n   variations of the Nagle algorithm, such as the one described in\n   Appendix A.3.\n\n3.7.5.  IPv6 Jumbograms\n\n   In order to support TCP over IPv6 Jumbograms, implementations need to\n   be able to send TCP segments larger than the 64-KB limit that the MSS\n   Option can convey.  RFC 2675 [24] defines that an MSS value of 65,535\n   bytes is to be treated as infinity, and Path MTU Discovery [14] is\n   used to determine the actual MSS.\n\n   The Jumbo Payload Option need not be implemented or understood by\n   IPv6 nodes that do not support attachment to links with an MTU\n   greater than 65,575 [24], and the present IPv6 Node Requirements does\n  b'mmunication\n\n   Once the connection is established, data is communicated by the\n   exchange of segments.  Because segments may be lost due to errors\n   (checksum test failure) or network congestion, TCP uses\n   retransmission to ensure delivery of every segment.  Duplicate\n   segments may arrive due to network or TCP retransmission.  As\n   discussed in the section on sequence numbers (Section 3.4), the TCP\n   implementation performs certain tests on the sequence and\n   acknowledgment numbers in the segments to verify their acceptability.\n\n   The sender of data keeps track of the next sequence number to use in\n   the variable SND.NXT.  The receiver of data keeps track of the next\n   sequence number to expect in the variable RCV.NXT.  The sender of\n   data keeps track of the oldest unacknowledged sequence number in the\n   variable SND.UNA.  If the data flow is momentarily idle and all data\n   sent has been acknowledged, then the three variables will be equal.\b"it, the sender\n   advances SND.NXT.  When the receiver accepts a segment, it advances\n   RCV.NXT and sends an acknowledgment.  When the data sender receives\n   an acknowledgment, it advances SND.UNA.  The extent to which the\n   values of these variables differ is a measure of the delay in the\n   communication.  The amount by which the variables are advanced is the\n   length of the data and SYN or FIN flags in the segment.  Note that,\n   once in the ESTABLISHED state, all segments must carry current\n   acknowledgment information.\n\n   The CLOSE user call implies a push function (see Section 3.9.1), as\n   does the FIN control flag in an incoming segment.\n\n3.8.1.  Retransmission Timeout\n\n   Because of the variability of the networks that compose an\n   internetwork system and the wide range of uses of TCP connections,\n   the retransmission timeout (RTO) must be dynamically determined.\n\n   The RTO MUST be computed according to the algorithm in [10],\n   includib'  RFC 793 contains an early example procedure for computing the RTO,\n   based on work mentioned in IEN 177 [71].  This was then replaced by\n   the algorithm described in RFC 1122, which was subsequently updated\n   in RFC 2988 and then again in RFC 6298.\n\n   RFC 1122 allows that if a retransmitted packet is identical to the\n   original packet (which implies not only that the data boundaries have\n   not changed, but also that none of the headers have changed), then\n   the same IPv4 Identification field MAY be used (see Section 3.2.1.5\n   of RFC 1122) (MAY-4).  The same IP Identification field may be reused\n   anyways since it is only meaningful when a datagram is fragmented\n   [44].  TCP implementations should not rely on or typically interact\n   with this IPv4 header field in any way.  It is not a reasonable way\n   to indicate duplicate sent segments nor to identify duplicate\n   received segments.\n\n3.8.2.  TCP Congestion Control\n\n   RFC 2914 [5] explains thb".\n\n   RFC 1122 required implementation of Van Jacobson's congestion control\n   algorithms slow start and congestion avoidance together with\n   exponential backoff for successive RTO values for the same segment.\n   RFC 2581 provided IETF Standards Track description of slow start and\n   congestion avoidance, along with fast retransmit and fast recovery.\n   RFC 5681 is the current description of these algorithms and is the\n   current Standards Track specification providing guidelines for TCP\n   congestion control.  RFC 6298 describes exponential backoff of RTO\n   values, including keeping the backed-off value until a subsequent\n   segment with new data has been sent and acknowledged without\n   retransmission.\n\n   A TCP endpoint MUST implement the basic congestion control algorithms\n   slow start, congestion avoidance, and exponential backoff of RTO to\n   avoid creating congestion collapse conditions (MUST-19).  RFC 5681\n   and RFC 6298 describe the basic algorb' applicable.  Multiple other suitable\n   algorithms exist and have been widely used.  Many TCP implementations\n   support a set of alternative algorithms that can be configured for\n   use on the endpoint.  An endpoint MAY implement such alternative\n   algorithms provided that the algorithms are conformant with the TCP\n   specifications from the IETF Standards Track as described in RFC\n   2914, RFC 5033 [7], and RFC 8961 [15] (MAY-18).\n\n   Explicit Congestion Notification (ECN) was defined in RFC 3168 and is\n   an IETF Standards Track enhancement that has many benefits [51].\n\n   A TCP endpoint SHOULD implement ECN as described in RFC 3168 (SHLD-\n   8).\n\n3.8.3.  TCP Connection Failures\n\n   Excessive retransmission of the same segment by a TCP endpoint\n   indicates some failure of the remote host or the internetwork path.\n   This failure may be of short or long duration.  The following\n   procedure MUST be used to handle excessive retransmissions of data\n  b'1 and R2 measuring the amount of\n        retransmission that has occurred for the same segment.  R1 and\n        R2 might be measured in time units or as a count of\n        retransmissions (with the current RTO and corresponding backoffs\n        as a conversion factor, if needed).\n\n   (b)  When the number of transmissions of the same segment reaches or\n        exceeds threshold R1, pass negative advice (see Section 3.3.1.4\n        of [19]) to the IP layer, to trigger dead-gateway diagnosis.\n\n   (c)  When the number of transmissions of the same segment reaches a\n        threshold R2 greater than R1, close the connection.\n\n   (d)  An application MUST (MUST-21) be able to set the value for R2\n        for a particular connection.  For example, an interactive\n        application might set R2 to "infinity", giving the user control\n        over when to disconnect.\n\n   (e)  TCP implementations SHOULD inform the application of the\n        delivery problem (unless sb'ation; see the "Asynchronous Reports" section\n        (Section 3.9.1.8)), when R1 is reached and before R2 (SHLD-9).\n        This will allow a remote login application program to inform the\n        user, for example.\n\n   The value of R1 SHOULD correspond to at least 3 retransmissions, at\n   the current RTO (SHLD-10).  The value of R2 SHOULD correspond to at\n   least 100 seconds (SHLD-11).\n\n   An attempt to open a TCP connection could fail with excessive\n   retransmissions of the SYN segment or by receipt of a RST segment or\n   an ICMP Port Unreachable.  SYN retransmissions MUST be handled in the\n   general way just described for data retransmissions, including\n   notification of the application layer.\n\n   However, the values of R1 and R2 may be different for SYN and data\n   segments.  In particular, R2 for a SYN segment MUST be set large\n   enough to provide retransmission of the segment for at least 3\n   minutes (MUST-23).  The application can close the cb'r, of course.\n\n3.8.4.  TCP Keep-Alives\n\n   A TCP connection is said to be "idle" if for some long amount of time\n   there have been no incoming segments received and there is no new or\n   unacknowledged data to be sent.\n\n   Implementers MAY include "keep-alives" in their TCP implementations\n   (MAY-5), although this practice is not universally accepted.  Some\n   TCP implementations, however, have included a keep-alive mechanism.\n   To confirm that an idle connection is still active, these\n   implementations send a probe segment designed to elicit a response\n   from the TCP peer.  Such a segment generally contains SEG.SEQ =\n   SND.NXT-1 and may or may not contain one garbage octet of data.  If\n   keep-alives are included, the application MUST be able to turn them\n   on or off for each TCP connection (MUST-24), and they MUST default to\n   off (MUST-25).\n\n   Keep-alive packets MUST only be sent when no sent data is\n   outstanding, and no data or acknowledgb'hin an interval (MUST-26).  This interval MUST\n   be configurable (MUST-27) and MUST default to no less than two hours\n   (MUST-28).\n\n   It is extremely important to remember that ACK segments that contain\n   no data are not reliably transmitted by TCP.  Consequently, if a\n   keep-alive mechanism is implemented it MUST NOT interpret failure to\n   respond to any specific probe as a dead connection (MUST-29).\n\n   An implementation SHOULD send a keep-alive segment with no data\n   (SHLD-12); however, it MAY be configurable to send a keep-alive\n   segment containing one garbage octet (MAY-6), for compatibility with\n   erroneous TCP implementations.\n\n3.8.5.  The Communication of Urgent Information\n\n   As a result of implementation differences and middlebox interactions,\n   new applications SHOULD NOT employ the TCP urgent mechanism (SHLD-\n   13).  However, TCP implementations MUST still include support for the\n   urgent mechanism (MUST-30).  Information on howb'r can be found in RFC 6093\n   [39].\n\n   The objective of the TCP urgent mechanism is to allow the sending\n   user to stimulate the receiving user to accept some urgent data and\n   to permit the receiving TCP endpoint to indicate to the receiving\n   user when all the currently known urgent data has been received by\n   the user.\n\n   This mechanism permits a point in the data stream to be designated as\n   the end of urgent information.  Whenever this point is in advance of\n   the receive sequence number (RCV.NXT) at the receiving TCP endpoint,\n   then the TCP implementation must tell the user to go into "urgent\n   mode"; when the receive sequence number catches up to the urgent\n   pointer, the TCP implementation must tell user to go into "normal\n   mode".  If the urgent pointer is updated while the user is in "urgent\n   mode", the update will be invisible to the user.\n\n   The method employs an urgent field that is carried in all segments\n   transmitted.  Thb' meaningful and must be added to the segment sequence number to yield\n   the urgent pointer.  The absence of this flag indicates that there is\n   no urgent data outstanding.\n\n   To send an urgent indication, the user must also send at least one\n   data octet.  If the sending user also indicates a push, timely\n   delivery of the urgent information to the destination process is\n   enhanced.  Note that because changes in the urgent pointer correspond\n   to data being written by a sending application, the urgent pointer\n   cannot "recede" in the sequence space, but a TCP receiver should be\n   robust to invalid urgent pointer values.\n\n   A TCP implementation MUST support a sequence of urgent data of any\n   length (MUST-31) [19].\n\n   The urgent pointer MUST point to the sequence number of the octet\n   following the urgent data (MUST-62).\n\n   A TCP implementation MUST (MUST-32) inform the application layer\n   asynchronously whenever it receives an urgent pointeb' whenever the urgent pointer\n   advances in the data stream.  The TCP implementation MUST (MUST-33)\n   provide a way for the application to learn how much urgent data\n   remains to be read from the connection, or at least to determine\n   whether more urgent data remains to be read [19].\n\n3.8.6.  Managing the Window\n\n   The window sent in each segment indicates the range of sequence\n   numbers the sender of the window (the data receiver) is currently\n   prepared to accept.  There is an assumption that this is related to\n   the data buffer space currently available for this connection.\n\n   The sending TCP endpoint packages the data to be transmitted into\n   segments that fit the current window, and may repackage segments on\n   the retransmission queue.  Such repackaging is not required but may\n   be helpful.\n\n   In a connection with a one-way data flow, the window information will\n   be carried in acknowledgment segments that all have the same sequence\n  b'arrive out of\n   order.  This is not a serious problem, but it will allow the window\n   information to be on occasion temporarily based on old reports from\n   the data receiver.  A refinement to avoid this problem is to act on\n   the window information from segments that carry the highest\n   acknowledgment number (that is, segments with an acknowledgment\n   number equal to or greater than the highest previously received).\n\n   Indicating a large window encourages transmissions.  If more data\n   arrives than can be accepted, it will be discarded.  This will result\n   in excessive retransmissions, adding unnecessarily to the load on the\n   network and the TCP endpoints.  Indicating a small window may\n   restrict the transmission of data to the point of introducing a\n   round-trip delay between each new segment transmitted.\n\n   The mechanisms provided allow a TCP endpoint to advertise a large\n   window and to subsequently advertise a much smaller window withoutb'shrinking the\n   window" is strongly discouraged.  The robustness principle [19]\n   dictates that TCP peers will not shrink the window themselves, but\n   will be prepared for such behavior on the part of other TCP peers.\n\n   A TCP receiver SHOULD NOT shrink the window, i.e., move the right\n   window edge to the left (SHLD-14).  However, a sending TCP peer MUST\n   be robust against window shrinking, which may cause the "usable\n   window" (see Section 3.8.6.2.1) to become negative (MUST-34).\n\n   If this happens, the sender SHOULD NOT send new data (SHLD-15), but\n   SHOULD retransmit normally the old unacknowledged data between\n   SND.UNA and SND.UNA+SND.WND (SHLD-16).  The sender MAY also\n   retransmit old data beyond SND.UNA+SND.WND (MAY-7), but SHOULD NOT\n   time out the connection if data beyond the right window edge is not\n   acknowledged (SHLD-17).  If the window shrinks to zero, the TCP\n   implementation MUST probe it in the standard way (described belob'he sending TCP peer must regularly transmit at least one octet of\n   new data (if available), or retransmit to the receiving TCP peer even\n   if the send window is zero, in order to "probe" the window.  This\n   retransmission is essential to guarantee that when either TCP peer\n   has a zero window the reopening of the window will be reliably\n   reported to the other.  This is referred to as Zero-Window Probing\n   (ZWP) in other documents.\n\n   Probing of zero (offered) windows MUST be supported (MUST-36).\n\n   A TCP implementation MAY keep its offered receive window closed\n   indefinitely (MAY-8).  As long as the receiving TCP peer continues to\n   send acknowledgments in response to the probe segments, the sending\n   TCP peer MUST allow the connection to stay open (MUST-37).  This\n   enables TCP to function in scenarios such as the "printer ran out of\n   paper" situation described in Section 4.2.2.17 of [19].  The behavior\n   is subject to the implementation\b'\n   When the receiving TCP peer has a zero window and a segment arrives,\n   it must still send an acknowledgment showing its next expected\n   sequence number and current window (zero).\n\n   The transmitting host SHOULD send the first zero-window probe when a\n   zero window has existed for the retransmission timeout period (SHLD-\n   29) (Section 3.8.1), and SHOULD increase exponentially the interval\n   between successive probes (SHLD-30).\n\n3.8.6.2.  Silly Window Syndrome Avoidance\n\n   The "Silly Window Syndrome" (SWS) is a stable pattern of small\n   incremental window movements resulting in extremely poor TCP\n   performance.  Algorithms to avoid SWS are described below for both\n   the sending side and the receiving side.  RFC 1122 contains more\n   detailed discussion of the SWS problem.  Note that the Nagle\n   algorithm and the sender SWS avoidance algorithm play complementary\n   roles in improving performance.  The Nagle algorithm discourages\n   sending tb"\n   increments, while the SWS avoidance algorithm discourages small\n   segments resulting from the right window edge advancing in small\n   increments.\n\n3.8.6.2.1.  Sender's Algorithm -- When to Send Data\n\n   A TCP implementation MUST include a SWS avoidance algorithm in the\n   sender (MUST-38).\n\n   The Nagle algorithm from Section 3.7.4 additionally describes how to\n   coalesce short segments.\n\n   The sender's SWS avoidance algorithm is more difficult than the\n   receiver's because the sender does not know (directly) the receiver's\n   total buffer space (RCV.BUFF).  An approach that has been found to\n   work well is for the sender to calculate Max(SND.WND), which is the\n   maximum send window it has seen so far on the connection, and to use\n   this value as an estimate of RCV.BUFF.  Unfortunately, this can only\n   be an estimate; the receiver may at any time reduce the size of\n   RCV.BUFF.  To avoid a resulting deadlock, it is necessary to have a\n   tib'oidance\n   algorithm.  In practice, this timeout should seldom occur.\n\n   The "usable window" is:\n\n      U = SND.UNA + SND.WND - SND.NXT\n\n   i.e., the offered window less the amount of data sent but not\n   acknowledged.  If D is the amount of data queued in the sending TCP\n   endpoint but not yet sent, then the following set of rules is\n   recommended.\n\n   Send data:\n\n   (1)  if a maximum-sized segment can be sent, i.e., if:\n\n           min(D,U) >= Eff.snd.MSS;\n\n   (2)  or if the data is pushed and all queued data can be sent now,\n        i.e., if:\n\n           [SND.NXT = SND.UNA and] PUSHed and D <= U\n\n        (the bracketed condition is imposed by the Nagle algorithm);\n\n   (3)  or if at least a fraction Fs of the maximum window can be sent,\n        i.e., if:\n\n           [SND.NXT = SND.UNA and]\n\n              min(D,U) >= Fs * Max(SND.WND);\n\n   (4)  or if the override timeout occurs.\n\n   Here Fs is a fraction whose recommended value is 1/2.b' may be\n   convenient to combine this timer with the timer used to probe zero\n   windows (Section 3.8.6.1).\n\n3.8.6.2.2.  Receiver\'s Algorithm -- When to Send a Window Update\n\n   A TCP implementation MUST include a SWS avoidance algorithm in the\n   receiver (MUST-39).\n\n   The receiver\'s SWS avoidance algorithm determines when the right\n   window edge may be advanced; this is customarily known as "updating\n   the window".  This algorithm combines with the delayed ACK algorithm\n   (Section 3.8.6.3) to determine when an ACK segment containing the\n   current window will really be sent to the receiver.\n\n   The solution to receiver SWS is to avoid advancing the right window\n   edge RCV.NXT+RCV.WND in small increments, even if data is received\n   from the network in small segments.\n\n   Suppose the total receive buffer space is RCV.BUFF.  At any given\n   moment, RCV.USER octets of this total may be tied up with data that\n   has been received and acknowledged b' connection is quiescent, RCV.WND = RCV.BUFF\n   and RCV.USER = 0.\n\n   Keeping the right window edge fixed as data arrives and is\n   acknowledged requires that the receiver offer less than its full\n   buffer space, i.e., the receiver must specify a RCV.WND that keeps\n   RCV.NXT+RCV.WND constant as RCV.NXT increases.  Thus, the total\n   buffer space RCV.BUFF is generally divided into three parts:\n\n                  |<------- RCV.BUFF ---------------->|\n                       1             2            3\n              ----|---------|------------------|------|----\n                         RCV.NXT               ^\n                                            (Fixed)\n\n              1 - RCV.USER =  data received but not yet consumed;\n              2 - RCV.WND =   space advertised to sender;\n              3 - Reduction = space available but not yet\n                              advertised.\n\n   The suggested SWS avoidance algorithm for the receiver is to keep\n   b'            RCV.BUFF - RCV.USER - RCV.WND  >=\n\n                       min( Fr * RCV.BUFF, Eff.snd.MSS )\n\n   where Fr is a fraction whose recommended value is 1/2, and\n   Eff.snd.MSS is the effective send MSS for the connection (see\n   Section 3.7.1).  When the inequality is satisfied, RCV.WND is set to\n   RCV.BUFF-RCV.USER.\n\n   Note that the general effect of this algorithm is to advance RCV.WND\n   in increments of Eff.snd.MSS (for realistic receive buffers:\n   Eff.snd.MSS < RCV.BUFF/2).  Note also that the receiver must use its\n   own Eff.snd.MSS, making the assumption that it is the same as the\n   sender\'s.\n\n3.8.6.3.  Delayed Acknowledgments -- When to Send an ACK Segment\n\n   A host that is receiving a stream of TCP data segments can increase\n   efficiency in both the network and the hosts by sending fewer than\n   one ACK (acknowledgment) segment per data segment received; this is\n   known as a "delayed ACK".\n\n   A TCP endpoint SHOULD implement a db'y delayed; in particular, the delay MUST be\n   less than 0.5 seconds (MUST-40).  An ACK SHOULD be generated for at\n   least every second full-sized segment or 2*RMSS bytes of new data\n   (where RMSS is the MSS specified by the TCP endpoint receiving the\n   segments to be acknowledged, or the default value if not specified)\n   (SHLD-19).  Excessive delays on ACKs can disturb the round-trip\n   timing and packet "clocking" algorithms.  More complete discussion of\n   delayed ACK behavior is in Section 4.2 of RFC 5681 [8], including\n   recommendations to immediately acknowledge out-of-order segments,\n   segments above a gap in sequence space, or segments that fill all or\n   part of a gap, in order to accelerate loss recovery.\n\n   Note that there are several current practices that further lead to a\n   reduced number of ACKs, including generic receive offload (GRO) [72],\n   ACK compression, and ACK decimation [28].\n\n3.9.  Interfaces\n\n   There are of course two ib' TCP/lower-level interface.  We have a fairly elaborate model\n   of the user/TCP interface, but the interface to the lower-level\n   protocol module is left unspecified here since it will be specified\n   in detail by the specification of the lower-level protocol.  For the\n   case that the lower level is IP, we note some of the parameter values\n   that TCP implementations might use.\n\n3.9.1.  User/TCP Interface\n\n   The following functional description of user commands to the TCP\n   implementation is, at best, fictional, since every operating system\n   will have different facilities.  Consequently, we must warn readers\n   that different TCP implementations may have different user\n   interfaces.  However, all TCP implementations must provide a certain\n   minimum set of services to guarantee that all TCP implementations can\n   support the same protocol hierarchy.  This section specifies the\n   functional interfaces required of all TCP implementations.\n\n   Sectib'CP and\n   could be used as an additional reference for implementers.\n\n   The following sections functionally characterize a user/TCP\n   interface.  The notation used is similar to most procedure or\n   function calls in high-level languages, but this usage is not meant\n   to rule out trap-type service calls.\n\n   The user commands described below specify the basic functions the TCP\n   implementation must perform to support interprocess communication.\n   Individual implementations must define their own exact format and may\n   provide combinations or subsets of the basic functions in single\n   calls.  In particular, some implementations may wish to automatically\n   OPEN a connection on the first SEND or RECEIVE issued by the user for\n   a given connection.\n\n   In providing interprocess communication facilities, the TCP\n   implementation must not only accept commands, but must also return\n   information to the processes it serves.  The latter consists of:\n\n b'rrupts, remote\n        close, binding of unspecified remote socket).\n\n   (b)  replies to specific user commands indicating success or various\n        types of failure.\n\n3.9.1.1.  Open\n\n   Format: OPEN (local port, remote socket, active/passive [, timeout]\n   [, Diffserv field] [, security/compartment] [, local IP address] [,\n   options]) -> local connection name\n\n   If the active/passive flag is set to passive, then this is a call to\n   LISTEN for an incoming connection.  A passive OPEN may have either a\n   fully specified remote socket to wait for a particular connection or\n   an unspecified remote socket to wait for any call.  A fully specified\n   passive call can be made active by the subsequent execution of a\n   SEND.\n\n   A transmission control block (TCB) is created and partially filled in\n   with data from the OPEN command parameters.\n\n   Every passive OPEN call either creates a new connection record in\n   LISTEN state, or it returns an error; b"rd (MUST-41).\n\n   A TCP implementation that supports multiple concurrent connections\n   MUST provide an OPEN call that will functionally allow an application\n   to LISTEN on a port while a connection block with the same local port\n   is in SYN-SENT or SYN-RECEIVED state (MUST-42).\n\n   On an active OPEN command, the TCP endpoint will begin the procedure\n   to synchronize (i.e., establish) the connection at once.\n\n   The timeout, if present, permits the caller to set up a timeout for\n   all data submitted to TCP.  If data is not successfully delivered to\n   the destination within the timeout period, the TCP endpoint will\n   abort the connection.  The present global default is five minutes.\n\n   The TCP implementation or some component of the operating system will\n   verify the user's authority to open a connection with the specified\n   Diffserv field value or security/compartment.  The absence of a\n   Diffserv field value or security/compartment specificatiob' be used.\n\n   TCP will accept incoming requests as matching only if the security/\n   compartment information is exactly the same as that requested in the\n   OPEN call.\n\n   The Diffserv field value indicated by the user only impacts outgoing\n   packets, may be altered en route through the network, and has no\n   direct bearing or relation to received packets.\n\n   A local connection name will be returned to the user by the TCP\n   implementation.  The local connection name can then be used as a\n   shorthand term for the connection defined by the <local socket,\n   remote socket> pair.\n\n   The optional "local IP address" parameter MUST be supported to allow\n   the specification of the local IP address (MUST-43).  This enables\n   applications that need to select the local IP address used when\n   multihoming is present.\n\n   A passive OPEN call with a specified "local IP address" parameter\n   will await an incoming connection request to that address.  If the\n b'coming\n   connection request to any local IP address and then bind the local IP\n   address of the connection to the particular address that is used.\n\n   For an active OPEN call, a specified "local IP address" parameter\n   will be used for opening the connection.  If the parameter is\n   unspecified, the host will choose an appropriate local IP address\n   (see RFC 1122, Section 3.3.4.2).\n\n   If an application on a multihomed host does not specify the local IP\n   address when actively opening a TCP connection, then the TCP\n   implementation MUST ask the IP layer to select a local IP address\n   before sending the (first) SYN (MUST-44).  See the function\n   GET_SRCADDR() in Section 3.4 of RFC 1122.\n\n   At all other times, a previous segment has either been sent or\n   received on this connection, and TCP implementations MUST use the\n   same local address that was used in those previous segments (MUST-\n   45).\n\n   A TCP implementation MUST reject as an error ab'., a broadcast or multicast address)\n   (MUST-46).\n\n3.9.1.2.  Send\n\n   Format: SEND (local connection name, buffer address, byte count,\n   URGENT flag [, PUSH flag] [, timeout])\n\n   This call causes the data contained in the indicated user buffer to\n   be sent on the indicated connection.  If the connection has not been\n   opened, the SEND is considered an error.  Some implementations may\n   allow users to SEND first; in which case, an automatic OPEN would be\n   done.  For example, this might be one way for application data to be\n   included in SYN segments.  If the calling process is not authorized\n   to use this connection, an error is returned.\n\n   A TCP endpoint MAY implement PUSH flags on SEND calls (MAY-15).  If\n   PUSH flags are not implemented, then the sending TCP peer: (1) MUST\n   NOT buffer data indefinitely (MUST-60), and (2) MUST set the PSH bit\n   in the last buffered segment (i.e., when there is no more queued data\n   to be sent) (MUST-61b'lag is supported on SEND calls.\n\n   If the PUSH flag is set, the application intends the data to be\n   transmitted promptly to the receiver, and the PSH bit will be set in\n   the last TCP segment created from the buffer.\n\n   The PSH bit is not a record marker and is independent of segment\n   boundaries.  The transmitter SHOULD collapse successive bits when it\n   packetizes data, to send the largest possible segment (SHLD-27).\n\n   If the PUSH flag is not set, the data may be combined with data from\n   subsequent SENDs for transmission efficiency.  When an application\n   issues a series of SEND calls without setting the PUSH flag, the TCP\n   implementation MAY aggregate the data internally without sending it\n   (MAY-16).  Note that when the Nagle algorithm is in use, TCP\n   implementations may buffer the data before sending, without regard to\n   the PUSH flag (see Section 3.7.4).\n\n   An application program is logically required to set the PUSH flag in\n   ab"ta to avoid\n   a communication deadlock.  However, a TCP implementation SHOULD send\n   a maximum-sized segment whenever possible (SHLD-28) to improve\n   performance (see Section 3.8.6.2.1).\n\n   New applications SHOULD NOT set the URGENT flag [39] due to\n   implementation differences and middlebox issues (SHLD-13).\n\n   If the URGENT flag is set, segments sent to the destination TCP peer\n   will have the urgent pointer set.  The receiving TCP peer will signal\n   the urgent condition to the receiving process if the urgent pointer\n   indicates that data preceding the urgent pointer has not been\n   consumed by the receiving process.  The purpose of the URGENT flag is\n   to stimulate the receiver to process the urgent data and to indicate\n   to the receiver when all the currently known urgent data has been\n   received.  The number of times the sending user's TCP implementation\n   signals urgent will not necessarily be equal to the number of times\n   the receivinb'.\n\n   If no remote socket was specified in the OPEN, but the connection is\n   established (e.g., because a LISTENing connection has become specific\n   due to a remote segment arriving for the local socket), then the\n   designated buffer is sent to the implied remote socket.  Users who\n   make use of OPEN with an unspecified remote socket can make use of\n   SEND without ever explicitly knowing the remote socket address.\n\n   However, if a SEND is attempted before the remote socket becomes\n   specified, an error will be returned.  Users can use the STATUS call\n   to determine the status of the connection.  Some TCP implementations\n   may notify the user when an unspecified socket is bound.\n\n   If a timeout is specified, the current user timeout for this\n   connection is changed to the new one.\n\n   In the simplest implementation, SEND would not return control to the\n   sending process until either the transmission was complete or the\n   timeout had been exceb' deadlocks (for example, both sides of the connection might\n   try to do SENDs before doing any RECEIVEs) and offers poor\n   performance, so it is not recommended.  A more sophisticated\n   implementation would return immediately to allow the process to run\n   concurrently with network I/O, and, furthermore, to allow multiple\n   SENDs to be in progress.  Multiple SENDs are served in first come,\n   first served order, so the TCP endpoint will queue those it cannot\n   service immediately.\n\n   We have implicitly assumed an asynchronous user interface in which a\n   SEND later elicits some kind of SIGNAL or pseudo-interrupt from the\n   serving TCP endpoint.  An alternative is to return a response\n   immediately.  For instance, SENDs might return immediate local\n   acknowledgment, even if the segment sent had not been acknowledged by\n   the distant TCP endpoint.  We could optimistically assume eventual\n   success.  If we are wrong, the connection will close anyway b'ind (synchronous), there\n   will still be some asynchronous signals, but these will deal with the\n   connection itself, and not with specific segments or buffers.\n\n   In order for the process to distinguish among error or success\n   indications for different SENDs, it might be appropriate for the\n   buffer address to be returned along with the coded response to the\n   SEND request.  TCP-to-user signals are discussed below, indicating\n   the information that should be returned to the calling process.\n\n3.9.1.3.  Receive\n\n   Format: RECEIVE (local connection name, buffer address, byte count)\n   -> byte count, URGENT flag [, PUSH flag]\n\n   This command allocates a receiving buffer associated with the\n   specified connection.  If no OPEN precedes this command or the\n   calling process is not authorized to use this connection, an error is\n   returned.\n\n   In the simplest implementation, control would not return to the\n   calling program until either the buffb's highly subject to deadlocks.  A more\n   sophisticated implementation would permit several RECEIVEs to be\n   outstanding at once.  These would be filled as segments arrive.  This\n   strategy permits increased throughput at the cost of a more elaborate\n   scheme (possibly asynchronous) to notify the calling program that a\n   PUSH has been seen or a buffer filled.\n\n   A TCP receiver MAY pass a received PSH bit to the application layer\n   via the PUSH flag in the interface (MAY-17), but it is not required\n   (this was clarified in RFC 1122, Section 4.2.2.2).  The remainder of\n   text describing the RECEIVE call below assumes that passing the PUSH\n   indication is supported.\n\n   If enough data arrive to fill the buffer before a PUSH is seen, the\n   PUSH flag will not be set in the response to the RECEIVE.  The buffer\n   will be filled with as much data as it can hold.  If a PUSH is seen\n   before the buffer is filled, the buffer will be returned partially\n   b', the user will have been informed as soon as\n   it arrived via a TCP-to-user signal.  The receiving user should thus\n   be in "urgent mode".  If the URGENT flag is on, additional urgent\n   data remains.  If the URGENT flag is off, this call to RECEIVE has\n   returned all the urgent data, and the user may now leave "urgent\n   mode".  Note that data following the urgent pointer (non-urgent data)\n   cannot be delivered to the user in the same buffer with preceding\n   urgent data unless the boundary is clearly marked for the user.\n\n   To distinguish among several outstanding RECEIVEs and to take care of\n   the case that a buffer is not completely filled, the return code is\n   accompanied by both a buffer pointer and a byte count indicating the\n   actual length of the data received.\n\n   Alternative implementations of RECEIVE might have the TCP endpoint\n   allocate buffer storage, or the TCP endpoint might share a ring\n   buffer with the user.\n\n3.9.1.4.  Closeb'mand causes the connection specified to be closed.  If the\n   connection is not open or the calling process is not authorized to\n   use this connection, an error is returned.  Closing connections is\n   intended to be a graceful operation in the sense that outstanding\n   SENDs will be transmitted (and retransmitted), as flow control\n   permits, until all have been serviced.  Thus, it should be acceptable\n   to make several SEND calls, followed by a CLOSE, and expect all the\n   data to be sent to the destination.  It should also be clear that\n   users should continue to RECEIVE on CLOSING connections since the\n   remote peer may be trying to transmit the last of its data.  Thus,\n   CLOSE means "I have no more to send" but does not mean "I will not\n   receive any more."  It may happen (if the user-level protocol is not\n   well thought out) that the closing side is unable to get rid of all\n   its data before timing out.  In this event, CLOSE turns into ABORT,\n   b' CLOSE the connection at any time on their own\n   initiative, or in response to various prompts from the TCP\n   implementation (e.g., remote close executed, transmission timeout\n   exceeded, destination inaccessible).\n\n   Because closing a connection requires communication with the remote\n   TCP peer, connections may remain in the closing state for a short\n   time.  Attempts to reopen the connection before the TCP peer replies\n   to the CLOSE command will result in error responses.\n\n   Close also implies push function.\n\n3.9.1.5.  Status\n\n   Format: STATUS (local connection name) -> status data\n\n   This is an implementation-dependent user command and could be\n   excluded without adverse effect.  Information returned would\n   typically come from the TCB associated with the connection.\n\n   This command returns a data block containing the following\n   information:\n\n      local socket,\n\n      remote socket,\n\n      local connection name,\n\n      receib'ber of buffers awaiting acknowledgment,\n\n      number of buffers pending receipt,\n\n      urgent state,\n\n      Diffserv field value,\n\n      security/compartment, and\n\n      transmission timeout.\n\n   Depending on the state of the connection, or on the implementation\n   itself, some of this information may not be available or meaningful.\n   If the calling process is not authorized to use this connection, an\n   error is returned.  This prevents unauthorized processes from gaining\n   information about a connection.\n\n3.9.1.6.  Abort\n\n   Format: ABORT (local connection name)\n\n   This command causes all pending SENDs and RECEIVES to be aborted, the\n   TCB to be removed, and a special RST message to be sent to the remote\n   TCP peer of the connection.  Depending on the implementation, users\n   may receive abort indications for each outstanding SEND or RECEIVE,\n   or may simply receive an ABORT-acknowledgment.\n\n3.9.1.7.  Flush\n\n   Some TCP implementatiob'ue of any data that the user has issued SEND calls\n   for but is still to the right of the current send window.  That is,\n   it flushes as much queued send data as possible without losing\n   sequence number synchronization.  The FLUSH call MAY be implemented\n   (MAY-14).\n\n3.9.1.8.  Asynchronous Reports\n\n   There MUST be a mechanism for reporting soft TCP error conditions to\n   the application (MUST-47).  Generically, we assume this takes the\n   form of an application-supplied ERROR_REPORT routine that may be\n   upcalled asynchronously from the transport layer:\n\n      ERROR_REPORT(local connection name, reason, subreason)\n\n   The precise encoding of the reason and subreason parameters is not\n   specified here.  However, the conditions that are reported\n   asynchronously to the application MUST include:\n\n   *  ICMP error message arrived (see Section 3.9.2.2 for description of\n      handling each ICMP message type since some message types need to\n      beb'  *  Excessive retransmissions (see Section 3.8.3)\n\n   *  Urgent pointer advance (see Section 3.8.5)\n\n   However, an application program that does not want to receive such\n   ERROR_REPORT calls SHOULD be able to effectively disable these calls\n   (SHLD-20).\n\n3.9.1.9.  Set Differentiated Services Field (IPv4 TOS or IPv6 Traffic\n          Class)\n\n   The application layer MUST be able to specify the Differentiated\n   Services field for segments that are sent on a connection (MUST-48).\n   The Differentiated Services field includes the 6-bit Differentiated\n   Services Codepoint (DSCP) value.  It is not required, but the\n   application SHOULD be able to change the Differentiated Services\n   field during the connection lifetime (SHLD-21).  TCP implementations\n   SHOULD pass the current Differentiated Services field value without\n   change to the IP layer, when it sends segments on the connection\n   (SHLD-22).\n\n   The Differentiated Services field will be specb', so that the receiver application\n   will specify the Differentiated Services field used for ACK segments.\n\n   TCP implementations MAY pass the most recently received\n   Differentiated Services field up to the application (MAY-9).\n\n3.9.2.  TCP/Lower-Level Interface\n\n   The TCP endpoint calls on a lower-level protocol module to actually\n   send and receive information over a network.  The two current\n   standard Internet Protocol (IP) versions layered below TCP are IPv4\n   [1] and IPv6 [13].\n\n   If the lower-level protocol is IPv4, it provides arguments for a type\n   of service (used within the Differentiated Services field) and for a\n   time to live.  TCP uses the following settings for these parameters:\n\n   Diffserv field:  The IP header value for the Diffserv field is given\n      by the user.  This includes the bits of the Diffserv Codepoint\n      (DSCP).\n\n   Time to Live (TTL):  The TTL value used to send TCP segments MUST be\n      configurable (Mb'60 seconds) as a\n         constant for the TTL because the assumed maximum segment\n         lifetime was two minutes.  This was intended to explicitly ask\n         that a segment be destroyed if it could not be delivered by the\n         internet system within one minute.  RFC 1122 updated RFC 793 to\n         require that the TTL be configurable.\n\n      *  Note that the Diffserv field is permitted to change during a\n         connection (Section 4.2.4.2 of RFC 1122).  However, the\n         application interface might not support this ability, and the\n         application does not have knowledge about individual TCP\n         segments, so this can only be done on a coarse granularity, at\n         best.  This limitation is further discussed in RFC 7657\n         (Sections 5.1, 5.3, and 6) [50].  Generally, an application\n         SHOULD NOT change the Diffserv field value during the course of\n         a connection (SHLD-23).\n\n   Any lower-level protocol will havb's, and protocol fields, and some way to determine\n   the "TCP length", both to provide the functional equivalent service\n   of IP and to be used in the TCP checksum.\n\n   When received options are passed up to TCP from the IP layer, a TCP\n   implementation MUST ignore options that it does not understand (MUST-\n   50).\n\n   A TCP implementation MAY support the Timestamp (MAY-10) and Record\n   Route (MAY-11) Options.\n\n3.9.2.1.  Source Routing\n\n   If the lower level is IP (or other protocol that provides this\n   feature) and source routing is used, the interface must allow the\n   route information to be communicated.  This is especially important\n   so that the source and destination addresses used in the TCP checksum\n   be the originating source and ultimate destination.  It is also\n   important to preserve the return route to answer connection requests.\n\n   An application MUST be able to specify a source route when it\n   actively opens a TCP connection (Mb'ute received in a datagram (MUST-52).\n\n   When a TCP connection is OPENed passively and a packet arrives with a\n   completed IP Source Route Option (containing a return route), TCP\n   implementations MUST save the return route and use it for all\n   segments sent on this connection (MUST-53).  If a different source\n   route arrives in a later segment, the later definition SHOULD\n   override the earlier one (SHLD-24).\n\n3.9.2.2.  ICMP Messages\n\n   TCP implementations MUST act on an ICMP error message passed up from\n   the IP layer, directing it to the connection that created the error\n   (MUST-54).  The necessary demultiplexing information can be found in\n   the IP header contained within the ICMP message.\n\n   This applies to ICMPv6 in addition to IPv4 ICMP.\n\n   [35] contains discussion of specific ICMP and ICMPv6 messages\n   classified as either "soft" or "hard" errors that may bear different\n   responses.  Treatment for classes of ICMP messages is describ'MUST silently discard any received ICMP Source\n     Quench messages (MUST-55).  See [11] for discussion.\n\n   Soft Errors\n     For IPv4 ICMP, these include: Destination Unreachable -- codes 0,\n     1, 5; Time Exceeded -- codes 0, 1; and Parameter Problem.\n\n     For ICMPv6, these include: Destination Unreachable -- codes 0, 3;\n     Time Exceeded -- codes 0, 1; and Parameter Problem -- codes 0, 1,\n     2.\n\n     Since these Unreachable messages indicate soft error conditions, a\n     TCP implementation MUST NOT abort the connection (MUST-56), and it\n     SHOULD make the information available to the application (SHLD-25).\n\n   Hard Errors\n     For ICMP these include Destination Unreachable -- codes 2-4.\n\n     These are hard error conditions, so TCP implementations SHOULD\n     abort the connection (SHLD-26).  [35] notes that some\n     implementations do not abort connections when an ICMP hard error is\n     received for a connection that is in any of the synchrb's widespread implementation\n   behavior that treats soft errors as hard errors during connection\n   establishment.\n\n3.9.2.3.  Source Address Validation\n\n   RFC 1122 requires addresses to be validated in incoming SYN packets:\n\n   |  An incoming SYN with an invalid source address MUST be ignored\n   |  either by TCP or by the IP layer [(MUST-63)] (see\n   |  Section 3.2.1.3).\n   |  \n   |  A TCP implementation MUST silently discard an incoming SYN segment\n   |  that is addressed to a broadcast or multicast address [(MUST-57)].\n\n   This prevents connection state and replies from being erroneously\n   generated, and implementers should note that this guidance is\n   applicable to all incoming segments, not just SYNs, as specifically\n   indicated in RFC 1122.\n\n3.10.  Event Processing\n\n   The processing depicted in this section is an example of one possible\n   implementation.  Other implementations may have slightly different\n   processing sequences, but they b'ot in substance.\n\n   The activity of the TCP endpoint can be characterized as responding\n   to events.  The events that occur can be cast into three categories:\n   user calls, arriving segments, and timeouts.  This section describes\n   the processing the TCP endpoint does in response to each of the\n   events.  In many cases, the processing required depends on the state\n   of the connection.\n\n   Events that occur:\n\n      User Calls\n\n         OPEN\n\n         SEND\n\n         RECEIVE\n\n         CLOSE\n\n         ABORT\n\n         STATUS\n\n      Arriving Segments\n\n         SEGMENT ARRIVES\n\n      Timeouts\n\n         USER TIMEOUT\n\n         RETRANSMISSION TIMEOUT\n\n         TIME-WAIT TIMEOUT\n\n   The model of the TCP/user interface is that user commands receive an\n   immediate return and possibly a delayed response via an event or\n   pseudo-interrupt.  In the following descriptions, the term "signal"\n   means cause a delayed response.\n\n   Error respob' commands referencing connections that do not exist\n   receive "error: connection not open".\n\n   Please note in the following that all arithmetic on sequence numbers,\n   acknowledgment numbers, windows, et cetera, is modulo 2^32 (the size\n   of the sequence number space).  Also note that "=<" means less than\n   or equal to (modulo 2^32).\n\n   A natural way to think about processing incoming segments is to\n   imagine that they are first tested for proper sequence number (i.e.,\n   that their contents lie in the range of the expected "receive window"\n   in the sequence number space) and then that they are generally queued\n   and processed in sequence number order.\n\n   When a segment overlaps other already received segments, we\n   reconstruct the segment to contain just the new data and adjust the\n   header fields to be consistent.\n\n   Note that if no state change is mentioned, the TCP connection stays\n   in the same state.\n\n3.10.1.  OPEN Call\n\n   CLOSED b'ssion control block (TCB) to hold connection\n      state information.  Fill in local socket identifier, remote\n      socket, Diffserv field, security/compartment, and user timeout\n      information.  Note that some parts of the remote socket may be\n      unspecified in a passive OPEN and are to be filled in by the\n      parameters of the incoming SYN segment.  Verify the security and\n      Diffserv value requested are allowed for this user, if not, return\n      "error: Diffserv value not allowed" or "error: security/\n      compartment not allowed".  If passive, enter the LISTEN state and\n      return.  If active and the remote socket is unspecified, return\n      "error: remote socket unspecified"; if active and the remote\n      socket is specified, issue a SYN segment.  An initial send\n      sequence number (ISS) is selected.  A SYN segment of the form\n      <SEQ=ISS><CTL=SYN> is sent.  Set SND.UNA to ISS, SND.NXT to ISS+1,\n      enter SYN-SENT state, and retb'he local socket specified,\n      return "error: connection illegal for this process".  If there is\n      no room to create a new connection, return "error: insufficient\n      resources".\n\n   LISTEN STATE\n\n   *  If the OPEN call is active and the remote socket is specified,\n      then change the connection from passive to active, select an ISS.\n      Send a SYN segment, set SND.UNA to ISS, SND.NXT to ISS+1.  Enter\n      SYN-SENT state.  Data associated with SEND may be sent with SYN\n      segment or queued for transmission after entering ESTABLISHED\n      state.  The urgent bit if requested in the command must be sent\n      with the data segments sent as a result of this command.  If there\n      is no room to queue the request, respond with "error: insufficient\n      resources".  If the remote socket was not specified, then return\n      "error: remote socket unspecified".\n\n   SYN-SENT STATE\n\n   SYN-RECEIVED STATE\n\n   ESTABLISHED STATE\n\n   FIN-WAIT-1 b'TATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Return "error: connection already exists".\n\n3.10.2.  SEND Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user does not have access to such a connection, then return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  If the remote socket is specified, then change the connection from\n      passive to active, select an ISS.  Send a SYN segment, set SND.UNA\n      to ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data associated\n      with SEND may be sent with SYN segment or queued for transmission\n      after entering ESTABLISHED state.  The urgent bit if requested in\n      the command must be sent with the data segments sent as a result\n      of this command.  If there is no room to queue the request,\n      respond with "error: insufficient resources".  If the remote\n      socket was not specified,b'ENT STATE\n\n   SYN-RECEIVED STATE\n\n   *  Queue the data for transmission after entering ESTABLISHED state.\n      If no space to queue, respond with "error: insufficient\n      resources".\n\n   ESTABLISHED STATE\n\n   CLOSE-WAIT STATE\n\n   *  Segmentize the buffer and send it with a piggybacked\n      acknowledgment (acknowledgment value = RCV.NXT).  If there is\n      insufficient space to remember this buffer, simply return "error:\n      insufficient resources".\n\n   *  If the URGENT flag is set, then SND.UP <- SND.NXT and set the\n      urgent pointer in the outgoing segments.\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Return "error: connection closing" and do not service request.\n\n3.10.3.  RECEIVE Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user does not have access to such a connection, return\n      "error: connection illegal for this process".\n\n   *  Otherwisb'STATE\n\n   SYN-RECEIVED STATE\n\n   *  Queue for processing after entering ESTABLISHED state.  If there\n      is no room to queue this request, respond with "error:\n      insufficient resources".\n\n   ESTABLISHED STATE\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   *  If insufficient incoming segments are queued to satisfy the\n      request, queue the request.  If there is no queue space to\n      remember the RECEIVE, respond with "error: insufficient\n      resources".\n\n   *  Reassemble queued incoming segments into receive buffer and return\n      to user.  Mark "push seen" (PUSH) if this is the case.\n\n   *  If RCV.UP is in advance of the data currently being passed to the\n      user, notify the user of the presence of urgent data.\n\n   *  When the TCP endpoint takes responsibility for delivering data to\n      the user, that fact must be communicated to the sender via an\n      acknowledgment.  The formation of such an acknowledgment is\n      describedb'\n\n   CLOSE-WAIT STATE\n\n   *  Since the remote side has already sent FIN, RECEIVEs must be\n      satisfied by data already on hand, but not yet delivered to the\n      user.  If no text is awaiting delivery, the RECEIVE will get an\n      "error: connection closing" response.  Otherwise, any remaining\n      data can be used to satisfy the RECEIVE.\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Return "error: connection closing".\n\n3.10.4.  CLOSE Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user does not have access to such a connection, return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  Any outstanding RECEIVEs are returned with "error: closing"\n      responses.  Delete TCB, enter CLOSED state, and return.\n\n   SYN-SENT STATE\n\n   *  Delete the TCB and return "error: closing" responses to any queued\n      SENDs, or RECb'ere is no pending data to send,\n      then form a FIN segment and send it, and enter FIN-WAIT-1 state;\n      otherwise, queue for processing after entering ESTABLISHED state.\n\n   ESTABLISHED STATE\n\n   *  Queue this until all preceding SENDs have been segmentized, then\n      form a FIN segment and send it.  In any case, enter FIN-WAIT-1\n      state.\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   *  Strictly speaking, this is an error and should receive an "error:\n      connection closing" response.  An "ok" response would be\n      acceptable, too, as long as a second FIN is not emitted (the first\n      FIN may be retransmitted, though).\n\n   CLOSE-WAIT STATE\n\n   *  Queue this request until all preceding SENDs have been\n      segmentized; then send a FIN segment, enter LAST-ACK state.\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Respond with "error: connection closing".\n\n3.10.5.  ABORT Call\n\n   CLOSED STATE (i.e., TCB does nb'n, return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  Any outstanding RECEIVEs should be returned with "error:\n      connection reset" responses.  Delete TCB, enter CLOSED state, and\n      return.\n\n   SYN-SENT STATE\n\n   *  All queued SENDs and RECEIVEs should be given "connection reset"\n      notification.  Delete the TCB, enter CLOSED state, and return.\n\n   SYN-RECEIVED STATE\n\n   ESTABLISHED STATE\n\n   FIN-WAIT-1 STATE\n\n   FIN-WAIT-2 STATE\n\n   CLOSE-WAIT STATE\n\n   *  Send a reset segment:\n\n      <SEQ=SND.NXT><CTL=RST>\n\n   *  All queued SENDs and RECEIVEs should be given "connection reset"\n      notification; all segments queued for transmission (except for the\n      RST formed above) or retransmission should be flushed.  Delete the\n      TCB, enter CLOSED state, and return.\n\n   CLOSING STATE\n\n   LAST-ACK STATE\n\n   TIME-WAIT STATE\n\n   *  Respb'6.  STATUS Call\n\n   CLOSED STATE (i.e., TCB does not exist)\n\n   *  If the user should not have access to such a connection, return\n      "error: connection illegal for this process".\n\n   *  Otherwise, return "error: connection does not exist".\n\n   LISTEN STATE\n\n   *  Return "state = LISTEN" and the TCB pointer.\n\n   SYN-SENT STATE\n\n   *  Return "state = SYN-SENT" and the TCB pointer.\n\n   SYN-RECEIVED STATE\n\n   *  Return "state = SYN-RECEIVED" and the TCB pointer.\n\n   ESTABLISHED STATE\n\n   *  Return "state = ESTABLISHED" and the TCB pointer.\n\n   FIN-WAIT-1 STATE\n\n   *  Return "state = FIN-WAIT-1" and the TCB pointer.\n\n   FIN-WAIT-2 STATE\n\n   *  Return "state = FIN-WAIT-2" and the TCB pointer.\n\n   CLOSE-WAIT STATE\n\n   *  Return "state = CLOSE-WAIT" and the TCB pointer.\n\n   CLOSING STATE\n\n   *  Return "state = CLOSING" and the TCB pointer.\n\n   LAST-ACK STATE\n\n   *  Return "state = LAST-ACK" and the TCB pointer.\n\n   TIME-WAIT STATE\nb'.10.7.1.  CLOSED STATE\n\n   If the state is CLOSED (i.e., TCB does not exist), then\n\n      all data in the incoming segment is discarded.  An incoming\n      segment containing a RST is discarded.  An incoming segment not\n      containing a RST causes a RST to be sent in response.  The\n      acknowledgment and sequence field values are selected to make the\n      reset sequence acceptable to the TCP endpoint that sent the\n      offending segment.\n\n      If the ACK bit is off, sequence number zero is used,\n\n         <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\n      If the ACK bit is on,\n\n         <SEQ=SEG.ACK><CTL=RST>\n\n      Return.\n\n3.10.7.2.  LISTEN STATE\n\n   If the state is LISTEN, then\n\n      First, check for a RST:\n\n      -  An incoming RST segment could not be valid since it could not\n         have been sent in response to anything sent by this incarnation\n         of the connection.  An incoming RST should be ignored.  Return.\n\n      Seconb'es on a connection still\n         in the LISTEN state.  An acceptable reset segment should be\n         formed for any arriving ACK-bearing segment.  The RST should be\n         formatted as follows:\n\n            <SEQ=SEG.ACK><CTL=RST>\n\n      -  Return.\n\n      Third, check for a SYN:\n\n      -  If the SYN bit is set, check the security.  If the security/\n         compartment on the incoming segment does not exactly match the\n         security/compartment in the TCB, then send a reset and return.\n\n            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\n      -  Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ, and any other\n         control or text should be queued for processing later.  ISS\n         should be selected and a SYN segment sent of the form:\n\n            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n\n      -  SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection\n         state should be changed to SYN-RECEIVED.  Note that any other\n         incob'      in the SYN-RECEIVED state, but processing of SYN and ACK should\n         not be repeated.  If the listen was not fully specified (i.e.,\n         the remote socket was not fully specified), then the\n         unspecified fields should be filled in now.\n\n      Fourth, other data or control:\n\n      -  This should not be reached.  Drop the segment and return.  Any\n         other control or data-bearing segment (not containing SYN) must\n         have an ACK and thus would have been discarded by the ACK\n         processing in the second step, unless it was first discarded by\n         RST checking in the first step.\n\n3.10.7.3.  SYN-SENT STATE\n\n   If the state is SYN-SENT, then\n\n      First, check the ACK bit:\n\n      -  If the ACK bit is set,\n\n         o  If SEG.ACK =< ISS or SEG.ACK > SND.NXT, send a reset (unless\n            the RST bit is set, if so drop the segment and return)\n\n               <SEQ=SEG.ACK><CTL=RST>\n\n         o  and discard the seb'hen the ACK is acceptable.\n            Some deployed TCP code has used the check SEG.ACK == SND.NXT\n            (using "==" rather than "=<"), but this is not appropriate\n            when the stack is capable of sending data on the SYN because\n            the TCP peer may not accept and acknowledge all of the data\n            on the SYN.\n\n      Second, check the RST bit:\n\n      -  If the RST bit is set,\n\n         o  A potential blind reset attack is described in RFC 5961 [9].\n            The mitigation described in that document has specific\n            applicability explained therein, and is not a substitute for\n            cryptographic protection (e.g., IPsec or TCP-AO).  A TCP\n            implementation that supports the mitigation described in RFC\n            5961 SHOULD first check that the sequence number exactly\n            matches RCV.NXT prior to executing the action in the next\n            paragraph.\n\n         o  If the ACK was acceptable, thb't", drop the segment, enter CLOSED state,\n            delete TCB, and return.  Otherwise (no ACK), drop the\n            segment and return.\n\n      Third, check the security:\n\n      -  If the security/compartment in the segment does not exactly\n         match the security/compartment in the TCB, send a reset:\n\n         o  If there is an ACK,\n\n               <SEQ=SEG.ACK><CTL=RST>\n\n         o  Otherwise,\n\n               <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\n      -  If a reset was sent, discard the segment and return.\n\n      Fourth, check the SYN bit:\n\n      -  This step should be reached only if the ACK is ok, or there is\n         no ACK, and the segment did not contain a RST.\n\n      -  If the SYN bit is on and the security/compartment is\n         acceptable, then RCV.NXT is set to SEG.SEQ+1, IRS is set to\n         SEG.SEQ.  SND.UNA should be advanced to equal SEG.ACK (if there\n         is an ACK), and any segments on the retransmission queueb'  -  If SND.UNA > ISS (our SYN has been ACKed), change the\n         connection state to ESTABLISHED, form an ACK segment\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n      -  and send it.  Data or controls that were queued for\n         transmission MAY be included.  Some TCP implementations\n         suppress sending this segment when the received segment\n         contains data that will anyways generate an acknowledgment in\n         the later processing steps, saving this extra acknowledgment of\n         the SYN from being sent.  If there are other controls or text\n         in the segment, then continue processing at the sixth step\n         under Section 3.10.7.4 where the URG bit is checked; otherwise,\n         return.\n\n      -  Otherwise, enter SYN-RECEIVED, form a SYN,ACK segment\n\n            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n\n      -  and send it.  Set the variables:\n\n            SND.WND <- SEG.WND\n\n            SND.WL1 <- SEG.SEQ\n\n      b' or text in the segment, queue them\n         for processing after the ESTABLISHED state has been reached,\n         return.\n\n      -  Note that it is legal to send and receive application data on\n         SYN segments (this is the "text in the segment" mentioned\n         above).  There has been significant misinformation and\n         misunderstanding of this topic historically.  Some firewalls\n         and security devices consider this suspicious.  However, the\n         capability was used in T/TCP [21] and is used in TCP Fast Open\n         (TFO) [48], so is important for implementations and network\n         devices to permit.\n\n      Fifth, if neither of the SYN or RST bits is set, then drop the\n      segment and return.\n\n3.10.7.4.  Other States\n\n   Otherwise,\n\n      First, check sequence number:\n\n      -  SYN-RECEIVED STATE\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n      -  CLOSE-WAIT STATE\n\n      - b"       o  Segments are processed in sequence.  Initial tests on\n            arrival are used to discard old duplicates, but further\n            processing is done in SEG.SEQ order.  If a segment's\n            contents straddle the boundary between old and new, only the\n            new parts are processed.\n\n         o  In general, the processing of received segments MUST be\n            implemented to aggregate ACK segments whenever possible\n            (MUST-58).  For example, if the TCP endpoint is processing a\n            series of queued segments, it MUST process them all before\n            sending any ACK segments (MUST-59).\n\n         o  There are four cases for the acceptability test for an\n            incoming segment:\n\n            +=========+=========+======================================+\n            | Segment | Receive | Test                                 |\n            | Length  | Window  |                                      |\n            +==b'=+\n            | 0       | 0       | SEG.SEQ = RCV.NXT                    |\n            +---------+---------+--------------------------------------+\n            | 0       | >0      | RCV.NXT =< SEG.SEQ <                 |\n            |         |         | RCV.NXT+RCV.WND                      |\n            +---------+---------+--------------------------------------+\n            | >0      | 0       | not acceptable                       |\n            +---------+---------+--------------------------------------+\n            | >0      | >0      | RCV.NXT =< SEG.SEQ <                 |\n            |         |         | RCV.NXT+RCV.WND                      |\n            |         |         |                                      |\n            |         |         | or                                   |\n            |         |         |                                      |\n            |         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1         |\n            |        b'\n            +---------+---------+--------------------------------------+\n\n                        Table 6: Segment Acceptability Tests\n\n         o  In implementing sequence number validation as described\n            here, please note Appendix A.2.\n\n         o  If the RCV.WND is zero, no segments will be acceptable, but\n            special allowance should be made to accept valid ACKs, URGs,\n            and RSTs.\n\n         o  If an incoming segment is not acceptable, an acknowledgment\n            should be sent in reply (unless the RST bit is set, if so\n            drop the segment and return):\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n         o  After sending the acknowledgment, drop the unacceptable\n            segment and return.\n\n         o  Note that for the TIME-WAIT state, there is an improved\n            algorithm described in [40] for handling incoming SYN\n            segments that utilizes timestamps rather than relying on the\n   b'oved\n            algorithm is implemented, the logic above is not applicable\n            for incoming SYN segments with Timestamp Options, received\n            on a connection in the TIME-WAIT state.\n\n         o  In the following it is assumed that the segment is the\n            idealized segment that begins at RCV.NXT and does not exceed\n            the window.  One could tailor actual segments to fit this\n            assumption by trimming off any portions that lie outside the\n            window (including SYN and FIN) and only processing further\n            if the segment then begins at RCV.NXT.  Segments with higher\n            beginning sequence numbers SHOULD be held for later\n            processing (SHLD-31).\n\n      Second, check the RST bit:\n\n      -  RFC 5961 [9], Section 3 describes a potential blind reset\n         attack and optional mitigation approach.  This does not provide\n         a cryptographic protection (e.g., as in IPsec or TCP-AO) bub' RFC 5961.  For\n         stacks implementing the protection described in RFC 5961, the\n         three checks below apply; otherwise, processing for these\n         states is indicated further below.\n\n         1)  If the RST bit is set and the sequence number is outside\n             the current receive window, silently drop the segment.\n\n         2)  If the RST bit is set and the sequence number exactly\n             matches the next expected sequence number (RCV.NXT), then\n             TCP endpoints MUST reset the connection in the manner\n             prescribed below according to the connection state.\n\n         3)  If the RST bit is set and the sequence number does not\n             exactly match the next expected sequence value, yet is\n             within the current receive window, TCP endpoints MUST send\n             an acknowledgment (challenge ACK):\n\n             <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n             After sending the challenge ACK, TCP eb'and stop processing the incoming\n             packet further.  Note that RFC 5961 and Errata ID 4772 [99]\n             contain additional considerations for ACK throttling in an\n             implementation.\n\n      -  SYN-RECEIVED STATE\n\n         o  If the RST bit is set,\n\n            +  If this connection was initiated with a passive OPEN\n               (i.e., came from the LISTEN state), then return this\n               connection to LISTEN state and return.  The user need not\n               be informed.  If this connection was initiated with an\n               active OPEN (i.e., came from SYN-SENT state), then the\n               connection was refused; signal the user "connection\n               refused".  In either case, the retransmission queue\n               should be flushed.  And in the active OPEN case, enter\n               the CLOSED state and delete the TCB, and return.\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-b'it is set, then any outstanding RECEIVEs and\n            SEND should receive "reset" responses.  All segment queues\n            should be flushed.  Users should also receive an unsolicited\n            general "connection reset" signal.  Enter the CLOSED state,\n            delete the TCB, and return.\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  If the RST bit is set, then enter the CLOSED state, delete\n            the TCB, and return.\n\n      Third, check security:\n\n      -  SYN-RECEIVED STATE\n\n         o  If the security/compartment in the segment does not exactly\n            match the security/compartment in the TCB, then send a reset\n            and return.\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n      -  CLOSE-WAIT STATE\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  If the security/compartment in the segment b'en send a\n            reset; any outstanding RECEIVEs and SEND should receive\n            "reset" responses.  All segment queues should be flushed.\n            Users should also receive an unsolicited general "connection\n            reset" signal.  Enter the CLOSED state, delete the TCB, and\n            return.\n\n      -  Note this check is placed following the sequence check to\n         prevent a segment from an old connection between these port\n         numbers with a different security from causing an abort of the\n         current connection.\n\n      Fourth, check the SYN bit:\n\n      -  SYN-RECEIVED STATE\n\n         o  If the connection was initiated with a passive OPEN, then\n            return this connection to the LISTEN state and return.\n            Otherwise, handle per the directions for synchronized states\n            below.\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n      -  CLOSE-WAIT STATE\n\n    b'ATE\n\n         o  If the SYN bit is set in these synchronized states, it may\n            be either a legitimate new connection attempt (e.g., in the\n            case of TIME-WAIT), an error where the connection should be\n            reset, or the result of an attack attempt, as described in\n            RFC 5961 [9].  For the TIME-WAIT state, new connections can\n            be accepted if the Timestamp Option is used and meets\n            expectations (per [40]).  For all other cases, RFC 5961\n            provides a mitigation with applicability to some situations,\n            though there are also alternatives that offer cryptographic\n            protection (see Section 7).  RFC 5961 recommends that in\n            these synchronized states, if the SYN bit is set,\n            irrespective of the sequence number, TCP endpoints MUST send\n            a "challenge ACK" to the remote peer:\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n         o  After sendib'     drop the unacceptable segment and stop processing further.\n            Note that RFC 5961 and Errata ID 4772 [99] contain\n            additional ACK throttling notes for an implementation.\n\n         o  For implementations that do not follow RFC 5961, the\n            original behavior described in RFC 793 follows in this\n            paragraph.  If the SYN is in the window it is an error: send\n            a reset, any outstanding RECEIVEs and SEND should receive\n            "reset" responses, all segment queues should be flushed, the\n            user should also receive an unsolicited general "connection\n            reset" signal, enter the CLOSED state, delete the TCB, and\n            return.\n\n         o  If the SYN is not in the window, this step would not be\n            reached and an ACK would have been sent in the first step\n            (sequence number check).\n\n      Fifth, check the ACK field:\n\n      -  if the ACK bit is off, drop the segment ab"FC 5961 [9], Section 5 describes a potential blind data\n            injection attack, and mitigation that implementations MAY\n            choose to include (MAY-12).  TCP stacks that implement RFC\n            5961 MUST add an input check that the ACK value is\n            acceptable only if it is in the range of ((SND.UNA -\n            MAX.SND.WND) =< SEG.ACK =< SND.NXT).  All incoming segments\n            whose ACK value doesn't satisfy the above condition MUST be\n            discarded and an ACK sent back.  The new state variable\n            MAX.SND.WND is defined as the largest window that the local\n            sender has ever received from its peer (subject to window\n            scaling) or may be hard-coded to a maximum permissible\n            window value.  When the ACK value is acceptable, the per-\n            state processing below applies:\n\n         o  SYN-RECEIVED STATE\n\n            +  If SND.UNA < SEG.ACK =< SND.NXT, then enter ESTABLISHED\n      b'les below\n               set to:\n\n                  SND.WND <- SEG.WND\n\n                  SND.WL1 <- SEG.SEQ\n\n                  SND.WL2 <- SEG.ACK\n\n            +  If the segment acknowledgment is not acceptable, form a\n               reset segment\n\n                  <SEQ=SEG.ACK><CTL=RST>\n\n            +  and send it.\n\n         o  ESTABLISHED STATE\n\n            +  If SND.UNA < SEG.ACK =< SND.NXT, then set SND.UNA <-\n               SEG.ACK.  Any segments on the retransmission queue that\n               are thereby entirely acknowledged are removed.  Users\n               should receive positive acknowledgments for buffers that\n               have been SENT and fully acknowledged (i.e., SEND buffer\n               should be returned with "ok" response).  If the ACK is a\n               duplicate (SEG.ACK =< SND.UNA), it can be ignored.  If\n               the ACK acks something not yet sent (SEG.ACK > SND.NXT),\n               then send an ACK, drop the seb".NXT, the send window should\n               be updated.  If (SND.WL1 < SEG.SEQ or (SND.WL1 = SEG.SEQ\n               and SND.WL2 =< SEG.ACK)), set SND.WND <- SEG.WND, set\n               SND.WL1 <- SEG.SEQ, and set SND.WL2 <- SEG.ACK.\n\n            +  Note that SND.WND is an offset from SND.UNA, that SND.WL1\n               records the sequence number of the last segment used to\n               update SND.WND, and that SND.WL2 records the\n               acknowledgment number of the last segment used to update\n               SND.WND.  The check here prevents using old segments to\n               update the window.\n\n         o  FIN-WAIT-1 STATE\n\n            +  In addition to the processing for the ESTABLISHED state,\n               if the FIN segment is now acknowledged, then enter FIN-\n               WAIT-2 and continue processing in that state.\n\n         o  FIN-WAIT-2 STATE\n\n            +  In addition to the processing for the ESTABLISHED state,\n             b'              can be acknowledged ("ok") but do not delete the TCB.\n\n         o  CLOSE-WAIT STATE\n\n            +  Do the same processing as for the ESTABLISHED state.\n\n         o  CLOSING STATE\n\n            +  In addition to the processing for the ESTABLISHED state,\n               if the ACK acknowledges our FIN, then enter the TIME-WAIT\n               state; otherwise, ignore the segment.\n\n         o  LAST-ACK STATE\n\n            +  The only thing that can arrive in this state is an\n               acknowledgment of our FIN.  If our FIN is now\n               acknowledged, delete the TCB, enter the CLOSED state, and\n               return.\n\n         o  TIME-WAIT STATE\n\n            +  The only thing that can arrive in this state is a\n               retransmission of the remote FIN.  Acknowledge it, and\n               restart the 2 MSL timeout.\n\n      Sixth, check the URG bit:\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAb'SEG.UP), and\n            signal the user that the remote side has urgent data if the\n            urgent pointer (RCV.UP) is in advance of the data consumed.\n            If the user has already been signaled (or is still in the\n            "urgent mode") for this continuous sequence of urgent data,\n            do not signal the user again.\n\n      -  CLOSE-WAIT STATE\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  This should not occur since a FIN has been received from the\n            remote side.  Ignore the URG.\n\n      Seventh, process the segment text:\n\n      -  ESTABLISHED STATE\n\n      -  FIN-WAIT-1 STATE\n\n      -  FIN-WAIT-2 STATE\n\n         o  Once in the ESTABLISHED state, it is possible to deliver\n            segment data to user RECEIVE buffers.  Data from segments\n            can be moved into buffers until either the buffer is full or\n            the segment is empty.  If the segment empties and b'he buffer is\n            returned, that a PUSH has been received.\n\n         o  When the TCP endpoint takes responsibility for delivering\n            the data to the user, it must also acknowledge the receipt\n            of the data.\n\n         o  Once the TCP endpoint takes responsibility for the data, it\n            advances RCV.NXT over the data accepted, and adjusts RCV.WND\n            as appropriate to the current buffer availability.  The\n            total of RCV.NXT and RCV.WND should not be reduced.\n\n         o  A TCP implementation MAY send an ACK segment acknowledging\n            RCV.NXT when a valid segment arrives that is in the window\n            but not at the left window edge (MAY-13).\n\n         o  Please note the window management suggestions in\n            Section 3.8.\n\n         o  Send an acknowledgment of the form:\n\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\n         o  This acknowledgment should be piggybacked on a segment beib'ue delay.\n\n      -  CLOSE-WAIT STATE\n\n      -  CLOSING STATE\n\n      -  LAST-ACK STATE\n\n      -  TIME-WAIT STATE\n\n         o  This should not occur since a FIN has been received from the\n            remote side.  Ignore the segment text.\n\n      Eighth, check the FIN bit:\n\n      -  Do not process the FIN if the state is CLOSED, LISTEN, or SYN-\n         SENT since the SEG.SEQ cannot be validated; drop the segment\n         and return.\n\n      -  If the FIN bit is set, signal the user "connection closing" and\n         return any pending RECEIVEs with same message, advance RCV.NXT\n         over the FIN, and send an acknowledgment for the FIN.  Note\n         that FIN implies PUSH for any segment text not yet delivered to\n         the user.\n\n         o  SYN-RECEIVED STATE\n\n         o  ESTABLISHED STATE\n\n            +  Enter the CLOSE-WAIT state.\n\n         o  FIN-WAIT-1 STATE\n\n            +  If our FIN has been ACKed (perhaps in this segment), then\nb'\n               other timers; otherwise, enter the CLOSING state.\n\n         o  FIN-WAIT-2 STATE\n\n            +  Enter the TIME-WAIT state.  Start the time-wait timer,\n               turn off the other timers.\n\n         o  CLOSE-WAIT STATE\n\n            +  Remain in the CLOSE-WAIT state.\n\n         o  CLOSING STATE\n\n            +  Remain in the CLOSING state.\n\n         o  LAST-ACK STATE\n\n            +  Remain in the LAST-ACK state.\n\n         o  TIME-WAIT STATE\n\n            +  Remain in the TIME-WAIT state.  Restart the 2 MSL time-\n               wait timeout.\n\n      and return.\n\n3.10.8.  Timeouts\n\n   USER TIMEOUT\n\n   *  For any state if the user timeout expires, flush all queues,\n      signal the user "error: connection aborted due to user timeout" in\n      general and for any outstanding calls, delete the TCB, enter the\n      CLOSED state, and return.\n\n   RETRANSMISSION TIMEOUT\n\n   *  For any state if the retransmission timeout expires ob't of the\n      retransmission queue again, reinitialize the retransmission timer,\n      and return.\n\n   TIME-WAIT TIMEOUT\n\n   *  If the time-wait timeout expires on a connection, delete the TCB,\n      enter the CLOSED state, and return.\n\n4.  Glossary\n\n   ACK    \n           A control bit (acknowledge) occupying no sequence space,\n           which indicates that the acknowledgment field of this segment\n           specifies the next sequence number the sender of this segment\n           is expecting to receive, hence acknowledging receipt of all\n           previous sequence numbers.\n\n   connection\n           A logical communication path identified by a pair of sockets.\n\n   datagram\n           A message sent in a packet-switched computer communications\n           network.\n\n   Destination Address\n           The network-layer address of the endpoint intended to receive\n           a segment.\n\n   FIN    \n           A control bit (finis) occupying one sb'd no more data or control\n           occupying sequence space.\n\n   flush  \n           To remove all of the contents (data or segments) from a store\n           (buffer or queue).\n\n   fragment\n           A portion of a logical unit of data.  In particular, an\n           internet fragment is a portion of an internet datagram.\n\n   header \n           Control information at the beginning of a message, segment,\n           fragment, packet, or block of data.\n\n   host   \n           A computer.  In particular, a source or destination of\n           messages from the point of view of the communication network.\n\n   Identification\n           An Internet Protocol field.  This identifying value assigned\n           by the sender aids in assembling the fragments of a datagram.\n\n   internet address\n           A network-layer address.\n\n   internet datagram\n           A unit of data exchanged between internet hosts, together\n           with the internet header that b'ation.\n\n   internet fragment\n           A portion of the data of an internet datagram with an\n           internet header.\n\n   IP     \n           Internet Protocol.  See [1] and [13].\n\n   IRS    \n           The Initial Receive Sequence number.  The first sequence\n           number used by the sender on a connection.\n\n   ISN    \n           The Initial Sequence Number.  The first sequence number used\n           on a connection (either ISS or IRS).  Selected in a way that\n           is unique within a given period of time and is unpredictable\n           to attackers.\n\n   ISS    \n           The Initial Send Sequence number.  The first sequence number\n           used by the sender on a connection.\n\n   left sequence\n           This is the next sequence number to be acknowledged by the\n           data-receiving TCP endpoint (or the lowest currently\n           unacknowledged sequence number) and is sometimes referred to\n           as the left edge of the b'n software, of a protocol or\n           other procedure.\n\n   MSL    \n           Maximum Segment Lifetime, the time a TCP segment can exist in\n           the internetwork system.  Arbitrarily defined to be 2\n           minutes.\n\n   octet  \n           An eight-bit byte.\n\n   Options\n           An Option field may contain several options, and each option\n           may be several octets in length.\n\n   packet \n           A package of data with a header that may or may not be\n           logically complete.  More often a physical packaging than a\n           logical packaging of data.\n\n   port   \n           The portion of a connection identifier used for\n           demultiplexing connections at an endpoint.\n\n   process\n           A program in execution.  A source or destination of data from\n           the point of view of the TCP endpoint or other host-to-host\n           protocol.\n\n   PUSH   \n           A control bit occupying no sequence space, indicb'd through to the\n           receiving user.\n\n   RCV.NXT\n           receive next sequence number\n\n   RCV.UP \n           receive urgent pointer\n\n   RCV.WND\n           receive window\n\n   receive next sequence number\n           This is the next sequence number the local TCP endpoint is\n           expecting to receive.\n\n   receive window\n           This represents the sequence numbers the local (receiving)\n           TCP endpoint is willing to receive.  Thus, the local TCP\n           endpoint considers that segments overlapping the range\n           RCV.NXT to RCV.NXT + RCV.WND - 1 carry acceptable data or\n           control.  Segments containing sequence numbers entirely\n           outside this range are considered duplicates or injection\n           attacks and discarded.\n\n   RST    \n           A control bit (reset), occupying no sequence space,\n           indicating that the receiver should delete the connection\n           without further interactiob'number and acknowledgment fields of the\n           incoming segment, whether it should honor the reset command\n           or ignore it.  In no case does receipt of a segment\n           containing RST give rise to a RST in response.\n\n   SEG.ACK\n           segment acknowledgment\n\n   SEG.LEN\n           segment length\n\n   SEG.SEQ\n           segment sequence\n\n   SEG.UP \n           segment urgent pointer field\n\n   SEG.WND\n           segment window field\n\n   segment\n           A logical unit of data.  In particular, a TCP segment is the\n           unit of data transferred between a pair of TCP modules.\n\n   segment acknowledgment\n           The sequence number in the acknowledgment field of the\n           arriving segment.\n\n   segment length\n           The amount of sequence number space occupied by a segment,\n           including any controls that occupy sequence space.\n\n   segment sequence\n           The number in the sequence field of the arrivib'ber the local (sending) TCP\n           endpoint will use on the connection.  It is initially\n           selected from an initial sequence number curve (ISN) and is\n           incremented for each octet of data or sequenced control\n           transmitted.\n\n   send window\n           This represents the sequence numbers that the remote\n           (receiving) TCP endpoint is willing to receive.  It is the\n           value of the window field specified in segments from the\n           remote (data-receiving) TCP endpoint.  The range of new\n           sequence numbers that may be emitted by a TCP implementation\n           lies between SND.NXT and SND.UNA + SND.WND - 1.\n           (Retransmissions of sequence numbers between SND.UNA and\n           SND.NXT are expected, of course.)\n\n   SND.NXT\n           send sequence\n\n   SND.UNA\n           left sequence\n\n   SND.UP \n           send urgent pointer\n\n   SND.WL1\n           segment sequence number at last windob't last window update\n\n   SND.WND\n           send window\n\n   socket (or socket number, or socket address, or socket identifier)\n           An address that specifically includes a port identifier, that\n           is, the concatenation of an Internet Address with a TCP port.\n\n   Source Address\n           The network-layer address of the sending endpoint.\n\n   SYN    \n           A control bit in the incoming segment, occupying one sequence\n           number, used at the initiation of a connection to indicate\n           where the sequence numbering will start.\n\n   TCB    \n           Transmission control block, the data structure that records\n           the state of a connection.\n\n   TCP    \n           Transmission Control Protocol: a host-to-host protocol for\n           reliable communication in internetwork environments.\n\n   TOS    \n           Type of Service, an obsoleted IPv4 field.  The same header\n           bits currently are used for the Differeb'ted Services Codepoint (DSCP)\n           value and the 2-bit ECN codepoint [6].\n\n   Type of Service\n           See "TOS".\n\n   URG    \n           A control bit (urgent), occupying no sequence space, used to\n           indicate that the receiving user should be notified to do\n           urgent processing as long as there is data to be consumed\n           with sequence numbers less than the value indicated by the\n           urgent pointer.\n\n   urgent pointer\n           A control field meaningful only when the URG bit is on.  This\n           field communicates the value of the urgent pointer that\n           indicates the data octet associated with the sending user\'s\n           urgent call.\n\n5.  Changes from RFC 793\n\n   This document obsoletes RFC 793 as well as RFCs 6093 and 6528, which\n   updated 793.  In all cases, only the normative protocol specification\n   and requirements have been incorporated into this document, and some\n   informational text wb' The informational content of those documents is still\n   valuable in learning about and understanding TCP, and they are valid\n   Informational references, even though their normative content has\n   been incorporated into this document.\n\n   The main body of this document was adapted from RFC 793\'s Section 3,\n   titled "FUNCTIONAL SPECIFICATION", with an attempt to keep formatting\n   and layout as close as possible.\n\n   The collection of applicable RFC errata that have been reported and\n   either accepted or held for an update to RFC 793 were incorporated\n   (Errata IDs: 573 [73], 574 [74], 700 [75], 701 [76], 1283 [77], 1561\n   [78], 1562 [79], 1564 [80], 1571 [81], 1572 [82], 2297 [83], 2298\n   [84], 2748 [85], 2749 [86], 2934 [87], 3213 [88], 3300 [89], 3301\n   [90], 6222 [91]).  Some errata were not applicable due to other\n   changes (Errata IDs: 572 [92], 575 [93], 1565 [94], 1569 [95], 2296\n   [96], 3305 [97], 3602 [98]).\n\n   Changes to the specificb'122, and 6093 were incorporated.  See RFC 6093 for detailed\n   discussion of why these changes were necessary.\n\n   The discussion of the RTO from RFC 793 was updated to refer to RFC\n   6298.  The text on the RTO in RFC 1122 originally replaced the text\n   in RFC 793; however, RFC 2988 should have updated RFC 1122 and has\n   subsequently been obsoleted by RFC 6298.\n\n   RFC 1011 [18] contains a number of comments about RFC 793, including\n   some needed changes to the TCP specification.  These are expanded in\n   RFC 1122, which contains a collection of other changes and\n   clarifications to RFC 793.  The normative items impacting the\n   protocol have been incorporated here, though some historically useful\n   implementation advice and informative discussion from RFC 1122 is not\n   included here.  The present document, which is now the TCP\n   specification rather than RFC 793, updates RFC 1011, and the comments\n   noted in RFC 1011 have been incorporated.\n\n   b'his document\n   can\'t obsolete RFC 1122 entirely.  It is only marked as "updating"\n   RFC 1122; however, it should be understood to effectively obsolete\n   all of the material on TCP found in RFC 1122.\n\n   The more secure initial sequence number generation algorithm from RFC\n   6528 was incorporated.  See RFC 6528 for discussion of the attacks\n   that this mitigates, as well as advice on selecting PRF algorithms\n   and managing secret key data.\n\n   A note based on RFC 6429 was added to explicitly clarify that system\n   resource management concerns allow connection resources to be\n   reclaimed.  RFC 6429 is obsoleted in the sense that the clarification\n   it describes has been reflected within this base TCP specification.\n\n   The description of congestion control implementation was added based\n   on the set of documents that are IETF BCP or Standards Track on the\n   topic and the current state of common implementations.\n\n6.  IANA Considerations\n\n   In b'stry,\n   IANA has made several changes as described in this section.\n\n   RFC 3168 originally created this registry but only populated it with\n   the new bits defined in RFC 3168, neglecting the other bits that had\n   previously been described in RFC 793 and other documents.  Bit 7 has\n   since also been updated by RFC 8311 [54].\n\n   The "Bit" column has been renamed below as the "Bit Offset" column\n   because it references each header flag\'s offset within the 16-bit\n   aligned view of the TCP header in Figure 1.  The bits in offsets 0\n   through 3 are the TCP segment Data Offset field, and not header\n   flags.\n\n   IANA has added a column for "Assignment Notes".\n\n   IANA has assigned values as indicated below.\n\n      +========+===================+===========+====================+\n      | Bit    | Name              | Reference | Assignment Notes   |\n      | Offset |                   |           |                    |\n      +========+===================b'd for      | RFC 9293  |                    |\n      |        | future use        |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 5      | Reserved for      | RFC 9293  |                    |\n      |        | future use        |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 6      | Reserved for      | RFC 9293  |                    |\n      |        | future use        |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 7      | Reserved for      | RFC 8311  | Previously used by |\n      |        | future use        |           | Historic RFC 3540  |\n      |        |                   |           | as NS (Nonce Sum). |\n      +--------+-------------------+-----------+--------------------+\n      | 8      | CWR (Congestion   | RFC 3168  |                    |\n      |        | b'|\n      +--------+-------------------+-----------+--------------------+\n      | 9      | ECE (ECN-Echo)    | RFC 3168  |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 10     | Urgent pointer    | RFC 9293  |                    |\n      |        | field is          |           |                    |\n      |        | significant (URG) |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 11     | Acknowledgment    | RFC 9293  |                    |\n      |        | field is          |           |                    |\n      |        | significant (ACK) |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 12     | Push function     | RFC 9293  |                    |\n      |        | (PSH)             |           |                    |\n      +--------+-------------------+-----------+-------------b'293  |                    |\n      |        | connection (RST)  |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 14     | Synchronize       | RFC 9293  |                    |\n      |        | sequence numbers  |           |                    |\n      |        | (SYN)             |           |                    |\n      +--------+-------------------+-----------+--------------------+\n      | 15     | No more data from | RFC 9293  |                    |\n      |        | sender (FIN)      |           |                    |\n      +--------+-------------------+-----------+--------------------+\n\n                         Table 7: TCP Header Flags\n\n   The "TCP Header Flags" registry has also been moved to a subregistry\n   under the global "Transmission Control Protocol (TCP) Parameters"\n   registry <https://www.iana.org/assignments/tcp-parameters/>.\n\n   The registry\'s Registration Procedure remains Stab' this document, and the Note has\n   been removed.\n\n7.  Security and Privacy Considerations\n\n   The TCP design includes only rudimentary security features that\n   improve the robustness and reliability of connections and application\n   data transfer, but there are no built-in cryptographic capabilities\n   to support any form of confidentiality, authentication, or other\n   typical security functions.  Non-cryptographic enhancements (e.g.,\n   [9]) have been developed to improve robustness of TCP connections to\n   particular types of attacks, but the applicability and protections of\n   non-cryptographic enhancements are limited (e.g., see Section 1.1 of\n   [9]).  Applications typically utilize lower-layer (e.g., IPsec) and\n   upper-layer (e.g., TLS) protocols to provide security and privacy for\n   TCP connections and application data carried in TCP.  Methods based\n   on TCP Options have been developed as well, to support some security\n   capabilities.\n\n   Inb'ction, and\n   authentication for TCP connections (including their control flags),\n   IPsec is the only current effective method.  For integrity protection\n   and authentication, the TCP Authentication Option (TCP-AO) [38] is\n   available, with a proposed extension to also provide confidentiality\n   for the segment payload.  Other methods discussed in this section may\n   provide confidentiality or integrity protection for the payload, but\n   for the TCP header only cover either a subset of the fields (e.g.,\n   tcpcrypt [57]) or none at all (e.g., TLS).  Other security features\n   that have been added to TCP (e.g., ISN generation, sequence number\n   checks, and others) are only capable of partially hindering attacks.\n\n   Applications using long-lived TCP flows have been vulnerable to\n   attacks that exploit the processing of control flags described in\n   earlier TCP specifications [33].  TCP-MD5 was a commonly implemented\n   TCP Option to support authenticatiob'd is now deprecated.  TCP-AO provides a capability to\n   protect long-lived TCP connections from attacks and has superior\n   properties to TCP-MD5.  It does not provide any privacy for\n   application data or for the TCP headers.\n\n   The "tcpcrypt" [57] experimental extension to TCP provides the\n   ability to cryptographically protect connection data.  Metadata\n   aspects of the TCP flow are still visible, but the application stream\n   is well protected.  Within the TCP header, only the urgent pointer\n   and FIN flag are protected through tcpcrypt.\n\n   The TCP Roadmap [49] includes notes about several RFCs related to TCP\n   security.  Many of the enhancements provided by these RFCs have been\n   integrated into the present document, including ISN generation,\n   mitigating blind in-window attacks, and improving handling of soft\n   errors and ICMP packets.  These are all discussed in greater detail\n   in the referenced RFCs that originally described the changesb'ly, see RFC 6093 [39] for\n   discussion of security considerations related to the urgent pointer\n   field, which also discourages new applications from using the urgent\n   pointer.\n\n   Since TCP is often used for bulk transfer flows, some attacks are\n   possible that abuse the TCP congestion control logic.  An example is\n   "ACK-division" attacks.  Updates that have been made to the TCP\n   congestion control specifications include mechanisms like Appropriate\n   Byte Counting (ABC) [29] that act as mitigations to these attacks.\n\n   Other attacks are focused on exhausting the resources of a TCP\n   server.  Examples include SYN flooding [32] or wasting resources on\n   non-progressing connections [41].  Operating systems commonly\n   implement mitigations for these attacks.  Some common defenses also\n   utilize proxies, stateful firewalls, and other technologies outside\n   the end-host TCP implementation.\n\n   The concept of a protocol\'s "wire image" is describ'text headers expose more\n   metadata to nodes on the path than is strictly required to route the\n   packets to their destination.  On-path adversaries may be able to\n   leverage this metadata.  Lessons learned in this respect from TCP\n   have been applied in the design of newer transports like QUIC [60].\n   Additionally, based partly on experiences with TCP and its\n   extensions, there are considerations that might be applicable for\n   future TCP extensions and other transports that the IETF has\n   documented in RFC 9065 [61], along with IAB recommendations in RFC\n   8558 [58] and [67].\n\n   There are also methods of "fingerprinting" that can be used to infer\n   the host TCP implementation (operating system) version or platform\n   information.  These collect observations of several aspects, such as\n   the options present in segments, the ordering of options, the\n   specific behaviors in the case of various conditions, packet timing,\n   packet sizing, and othb'ermined by an implementer, and can use those observations to\n   identify information about the host and implementation.\n\n   Since ICMP message processing also can interact with TCP connections,\n   there is potential for ICMP-based attacks against TCP connections.\n   These are discussed in RFC 5927 [100], along with mitigations that\n   have been implemented.\n\n8.  References\n\n8.1.  Normative References\n\n   [1]        Postel, J., "Internet Protocol", STD 5, RFC 791,\n              DOI 10.17487/RFC0791, September 1981,\n              <https://www.rfc-editor.org/info/rfc791>.\n\n   [2]        Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,\n              DOI 10.17487/RFC1191, November 1990,\n              <https://www.rfc-editor.org/info/rfc1191>.\n\n   [3]        Bradner, S., "Key words for use in RFCs to Indicate\n              Requirement Levels", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.ob'er, F., and D. Black,\n              "Definition of the Differentiated Services Field (DS\n              Field) in the IPv4 and IPv6 Headers", RFC 2474,\n              DOI 10.17487/RFC2474, December 1998,\n              <https://www.rfc-editor.org/info/rfc2474>.\n\n   [5]        Floyd, S., "Congestion Control Principles", BCP 41,\n              RFC 2914, DOI 10.17487/RFC2914, September 2000,\n              <https://www.rfc-editor.org/info/rfc2914>.\n\n   [6]        Ramakrishnan, K., Floyd, S., and D. Black, "The Addition\n              of Explicit Congestion Notification (ECN) to IP",\n              RFC 3168, DOI 10.17487/RFC3168, September 2001,\n              <https://www.rfc-editor.org/info/rfc3168>.\n\n   [7]        Floyd, S. and M. Allman, "Specifying New Congestion\n              Control Algorithms", BCP 133, RFC 5033,\n              DOI 10.17487/RFC5033, August 2007,\n              <https://www.rfc-editor.org/info/rfc5033>.\n\n   [8]        Allman, M., Paxson, V., ab'C 5681, DOI 10.17487/RFC5681, September 2009,\n              <https://www.rfc-editor.org/info/rfc5681>.\n\n   [9]        Ramaiah, A., Stewart, R., and M. Dalal, "Improving TCP\'s\n              Robustness to Blind In-Window Attacks", RFC 5961,\n              DOI 10.17487/RFC5961, August 2010,\n              <https://www.rfc-editor.org/info/rfc5961>.\n\n   [10]       Paxson, V., Allman, M., Chu, J., and M. Sargent,\n              "Computing TCP\'s Retransmission Timer", RFC 6298,\n              DOI 10.17487/RFC6298, June 2011,\n              <https://www.rfc-editor.org/info/rfc6298>.\n\n   [11]       Gont, F., "Deprecation of ICMP Source Quench Messages",\n              RFC 6633, DOI 10.17487/RFC6633, May 2012,\n              <https://www.rfc-editor.org/info/rfc6633>.\n\n   [12]       Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174b'tocol, Version 6\n              (IPv6) Specification", STD 86, RFC 8200,\n              DOI 10.17487/RFC8200, July 2017,\n              <https://www.rfc-editor.org/info/rfc8200>.\n\n   [14]       McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,\n              "Path MTU Discovery for IP version 6", STD 87, RFC 8201,\n              DOI 10.17487/RFC8201, July 2017,\n              <https://www.rfc-editor.org/info/rfc8201>.\n\n   [15]       Allman, M., "Requirements for Time-Based Loss Detection",\n              BCP 233, RFC 8961, DOI 10.17487/RFC8961, November 2020,\n              <https://www.rfc-editor.org/info/rfc8961>.\n\n8.2.  Informative References\n\n   [16]       Postel, J., "Transmission Control Protocol", STD 7,\n              RFC 793, DOI 10.17487/RFC0793, September 1981,\n              <https://www.rfc-editor.org/info/rfc793>.\n\n   [17]       Nagle, J., "Congestion Control in IP/TCP Internetworks",\n              RFC 896, DOI 10.17487/RFC0896, January 1984,b'   [18]       Reynolds, J. and J. Postel, "Official Internet protocols",\n              RFC 1011, DOI 10.17487/RFC1011, May 1987,\n              <https://www.rfc-editor.org/info/rfc1011>.\n\n   [19]       Braden, R., Ed., "Requirements for Internet Hosts -\n              Communication Layers", STD 3, RFC 1122,\n              DOI 10.17487/RFC1122, October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n\n   [20]       Almquist, P., "Type of Service in the Internet Protocol\n              Suite", RFC 1349, DOI 10.17487/RFC1349, July 1992,\n              <https://www.rfc-editor.org/info/rfc1349>.\n\n   [21]       Braden, R., "T/TCP -- TCP Extensions for Transactions\n              Functional Specification", RFC 1644, DOI 10.17487/RFC1644,\n              July 1994, <https://www.rfc-editor.org/info/rfc1644>.\n\n   [22]       Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP\n              Selective Acknowledgment Options", RFC 2018,\n              DOI 10b'.rfc-editor.org/info/rfc2018>.\n\n   [23]       Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner,\n              J., Heavens, I., Lahey, K., Semke, J., and B. Volz, "Known\n              TCP Implementation Problems", RFC 2525,\n              DOI 10.17487/RFC2525, March 1999,\n              <https://www.rfc-editor.org/info/rfc2525>.\n\n   [24]       Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",\n              RFC 2675, DOI 10.17487/RFC2675, August 1999,\n              <https://www.rfc-editor.org/info/rfc2675>.\n\n   [25]       Xiao, X., Hannan, A., Paxson, V., and E. Crabbe, "TCP\n              Processing of the IPv4 Precedence Field", RFC 2873,\n              DOI 10.17487/RFC2873, June 2000,\n              <https://www.rfc-editor.org/info/rfc2873>.\n\n   [26]       Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, "An\n              Extension to the Selective Acknowledgement (SACK) Option\n              for TCP", RFC 2883, DOI 10.17487/RFC2883, July 2b'883>.\n\n   [27]       Lahey, K., "TCP Problems with Path MTU Discovery",\n              RFC 2923, DOI 10.17487/RFC2923, September 2000,\n              <https://www.rfc-editor.org/info/rfc2923>.\n\n   [28]       Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M.\n              Sooriyabandara, "TCP Performance Implications of Network\n              Path Asymmetry", BCP 69, RFC 3449, DOI 10.17487/RFC3449,\n              December 2002, <https://www.rfc-editor.org/info/rfc3449>.\n\n   [29]       Allman, M., "TCP Congestion Control with Appropriate Byte\n              Counting (ABC)", RFC 3465, DOI 10.17487/RFC3465, February\n              2003, <https://www.rfc-editor.org/info/rfc3465>.\n\n   [30]       Fenner, B., "Experimental Values In IPv4, IPv6, ICMPv4,\n              ICMPv6, UDP, and TCP Headers", RFC 4727,\n              DOI 10.17487/RFC4727, November 2006,\n              <https://www.rfc-editor.org/info/rfc4727>.\n\n   [31]       Mathis, M. and J. Heffner, "Packeb'1, DOI 10.17487/RFC4821, March 2007,\n              <https://www.rfc-editor.org/info/rfc4821>.\n\n   [32]       Eddy, W., "TCP SYN Flooding Attacks and Common\n              Mitigations", RFC 4987, DOI 10.17487/RFC4987, August 2007,\n              <https://www.rfc-editor.org/info/rfc4987>.\n\n   [33]       Touch, J., "Defending TCP Against Spoofing Attacks",\n              RFC 4953, DOI 10.17487/RFC4953, July 2007,\n              <https://www.rfc-editor.org/info/rfc4953>.\n\n   [34]       Culley, P., Elzur, U., Recio, R., Bailey, S., and J.\n              Carrier, "Marker PDU Aligned Framing for TCP\n              Specification", RFC 5044, DOI 10.17487/RFC5044, October\n              2007, <https://www.rfc-editor.org/info/rfc5044>.\n\n   [35]       Gont, F., "TCP\'s Reaction to Soft Errors", RFC 5461,\n              DOI 10.17487/RFC5461, February 2009,\n              <https://www.rfc-editor.org/info/rfc5461>.\n\n   [36]       StJohns, M., Atkinson, R., and G. Thomas, "Commb'CALIPSO)",\n              RFC 5570, DOI 10.17487/RFC5570, July 2009,\n              <https://www.rfc-editor.org/info/rfc5570>.\n\n   [37]       Sandlund, K., Pelletier, G., and L-E. Jonsson, "The RObust\n              Header Compression (ROHC) Framework", RFC 5795,\n              DOI 10.17487/RFC5795, March 2010,\n              <https://www.rfc-editor.org/info/rfc5795>.\n\n   [38]       Touch, J., Mankin, A., and R. Bonica, "The TCP\n              Authentication Option", RFC 5925, DOI 10.17487/RFC5925,\n              June 2010, <https://www.rfc-editor.org/info/rfc5925>.\n\n   [39]       Gont, F. and A. Yourtchenko, "On the Implementation of the\n              TCP Urgent Mechanism", RFC 6093, DOI 10.17487/RFC6093,\n              January 2011, <https://www.rfc-editor.org/info/rfc6093>.\n\n   [40]       Gont, F., "Reducing the TIME-WAIT State Using TCP\n              Timestamps", BCP 159, RFC 6191, DOI 10.17487/RFC6191,\n              April 2011, <https://www.rfc-editor.org/ib'M., and A. Ramaiah, "TCP Sender\n              Clarification for Persist Condition", RFC 6429,\n              DOI 10.17487/RFC6429, December 2011,\n              <https://www.rfc-editor.org/info/rfc6429>.\n\n   [42]       Gont, F. and S. Bellovin, "Defending against Sequence\n              Number Attacks", RFC 6528, DOI 10.17487/RFC6528, February\n              2012, <https://www.rfc-editor.org/info/rfc6528>.\n\n   [43]       Borman, D., "TCP Options and Maximum Segment Size (MSS)",\n              RFC 6691, DOI 10.17487/RFC6691, July 2012,\n              <https://www.rfc-editor.org/info/rfc6691>.\n\n   [44]       Touch, J., "Updated Specification of the IPv4 ID Field",\n              RFC 6864, DOI 10.17487/RFC6864, February 2013,\n              <https://www.rfc-editor.org/info/rfc6864>.\n\n   [45]       Touch, J., "Shared Use of Experimental TCP Options",\n              RFC 6994, DOI 10.17487/RFC6994, August 2013,\n              <https://www.rfc-editor.org/info/rfc6994>.\nb'. Osterweil,\n              "Architectural Considerations of IP Anycast", RFC 7094,\n              DOI 10.17487/RFC7094, January 2014,\n              <https://www.rfc-editor.org/info/rfc7094>.\n\n   [47]       Borman, D., Braden, B., Jacobson, V., and R.\n              Scheffenegger, Ed., "TCP Extensions for High Performance",\n              RFC 7323, DOI 10.17487/RFC7323, September 2014,\n              <https://www.rfc-editor.org/info/rfc7323>.\n\n   [48]       Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP\n              Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014,\n              <https://www.rfc-editor.org/info/rfc7413>.\n\n   [49]       Duke, M., Braden, R., Eddy, W., Blanton, E., and A.\n              Zimmermann, "A Roadmap for Transmission Control Protocol\n              (TCP) Specification Documents", RFC 7414,\n              DOI 10.17487/RFC7414, February 2015,\n              <https://www.rfc-editor.org/info/rfc7414>.\n\n   [50]       Black,b'     (Diffserv) and Real-Time Communication", RFC 7657,\n              DOI 10.17487/RFC7657, November 2015,\n              <https://www.rfc-editor.org/info/rfc7657>.\n\n   [51]       Fairhurst, G. and M. Welzl, "The Benefits of Using\n              Explicit Congestion Notification (ECN)", RFC 8087,\n              DOI 10.17487/RFC8087, March 2017,\n              <https://www.rfc-editor.org/info/rfc8087>.\n\n   [52]       Fairhurst, G., Ed., Trammell, B., Ed., and M. Kuehlewind,\n              Ed., "Services Provided by IETF Transport Protocols and\n              Congestion Control Mechanisms", RFC 8095,\n              DOI 10.17487/RFC8095, March 2017,\n              <https://www.rfc-editor.org/info/rfc8095>.\n\n   [53]       Welzl, M., Tuexen, M., and N. Khademi, "On the Usage of\n              Transport Features Provided by IETF Transport Protocols",\n              RFC 8303, DOI 10.17487/RFC8303, February 2018,\n              <https://www.rfc-editor.org/info/rfc8303>.\n\n b't Congestion\n              Notification (ECN) Experimentation", RFC 8311,\n              DOI 10.17487/RFC8311, January 2018,\n              <https://www.rfc-editor.org/info/rfc8311>.\n\n   [55]       Chown, T., Loughney, J., and T. Winters, "IPv6 Node\n              Requirements", BCP 220, RFC 8504, DOI 10.17487/RFC8504,\n              January 2019, <https://www.rfc-editor.org/info/rfc8504>.\n\n   [56]       Trammell, B. and M. Kuehlewind, "The Wire Image of a\n              Network Protocol", RFC 8546, DOI 10.17487/RFC8546, April\n              2019, <https://www.rfc-editor.org/info/rfc8546>.\n\n   [57]       Bittau, A., Giffin, D., Handley, M., Mazieres, D., Slack,\n              Q., and E. Smith, "Cryptographic Protection of TCP Streams\n              (tcpcrypt)", RFC 8548, DOI 10.17487/RFC8548, May 2019,\n              <https://www.rfc-editor.org/info/rfc8548>.\n\n   [58]       Hardie, T., Ed., "Transport Protocol Path Signals",\n              RFC 8558, DOI 10.17487/Rb'r.org/info/rfc8558>.\n\n   [59]       Ford, A., Raiciu, C., Handley, M., Bonaventure, O., and C.\n              Paasch, "TCP Extensions for Multipath Operation with\n              Multiple Addresses", RFC 8684, DOI 10.17487/RFC8684, March\n              2020, <https://www.rfc-editor.org/info/rfc8684>.\n\n   [60]       Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based\n              Multiplexed and Secure Transport", RFC 9000,\n              DOI 10.17487/RFC9000, May 2021,\n              <https://www.rfc-editor.org/info/rfc9000>.\n\n   [61]       Fairhurst, G. and C. Perkins, "Considerations around\n              Transport Header Confidentiality, Network Operations, and\n              the Evolution of Internet Transport Protocols", RFC 9065,\n              DOI 10.17487/RFC9065, July 2021,\n              <https://www.rfc-editor.org/info/rfc9065>.\n\n   [62]       IANA, "Transmission Control Protocol (TCP) Parameters",\n              <https://www.iana.org/assignments/tb' IP Security/Compartment and\n              Precedence Information by TCP", Work in Progress,\n              Internet-Draft, draft-gont-tcpm-tcp-seccomp-prec-00, 29\n              March 2012, <https://datatracker.ietf.org/doc/html/draft-\n              gont-tcpm-tcp-seccomp-prec-00>.\n\n   [64]       Gont, F. and D. Borman, "On the Validation of TCP Sequence\n              Numbers", Work in Progress, Internet-Draft, draft-gont-\n              tcpm-tcp-seq-validation-04, 11 March 2019,\n              <https://datatracker.ietf.org/doc/html/draft-gont-tcpm-\n              tcp-seq-validation-04>.\n\n   [65]       Touch, J. and W. M. Eddy, "TCP Extended Data Offset\n              Option", Work in Progress, Internet-Draft, draft-ietf-\n              tcpm-tcp-edo-12, 15 April 2022,\n              <https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-\n              tcp-edo-12>.\n\n   [66]       McQuistin, S., Band, V., Jacob, D., and C. Perkins,\n              "Describing Protocb' Diagrams", Work in Progress, Internet-Draft, draft-\n              mcquistin-augmented-ascii-diagrams-10, 7 March 2022,\n              <https://datatracker.ietf.org/doc/html/draft-mcquistin-\n              augmented-ascii-diagrams-10>.\n\n   [67]       Thomson, M. and T. Pauly, "Long-Term Viability of Protocol\n              Extension Mechanisms", RFC 9170, DOI 10.17487/RFC9170,\n              December 2021, <https://www.rfc-editor.org/info/rfc9170>.\n\n   [68]       Minshall, G., "A Suggested Modification to Nagle\'s\n              Algorithm", Work in Progress, Internet-Draft, draft-\n              minshall-nagle-01, 18 June 1999,\n              <https://datatracker.ietf.org/doc/html/draft-minshall-\n              nagle-01>.\n\n   [69]       Dalal, Y. and C. Sunshine, "Connection Management in\n              Transport Protocols", Computer Networks, Vol. 2, No. 6,\n              pp. 454-473, DOI 10.1016/0376-5075(78)90053-3, December\n              1978, <https://doi.org/b' Touch, J., and W. Yui, "The TIME-WAIT state in\n              TCP and Its Effect on Busy Servers", Proceedings of IEEE\n              INFOCOM, pp. 1573-1583, DOI 10.1109/INFCOM.1999.752180,\n              March 1999, <https://doi.org/10.1109/INFCOM.1999.752180>.\n\n   [71]       Postel, J., "Comments on Action Items from the January\n              Meeting", IEN 177, March 1981,\n              <https://www.rfc-editor.org/ien/ien177.txt>.\n\n   [72]       "Segmentation Offloads", The Linux Kernel Documentation,\n              <https://www.kernel.org/doc/html/latest/networking/\n              segmentation-offloads.html>.\n\n   [73]       RFC Errata, Erratum ID 573, RFC 793,\n              <https://www.rfc-editor.org/errata/eid573>.\n\n   [74]       RFC Errata, Erratum ID 574, RFC 793,\n              <https://www.rfc-editor.org/errata/eid574>.\n\n   [75]       RFC Errata, Erratum ID 700, RFC 793,\n              <https://www.rfc-editor.org/errata/eid700>.\n\n   [76]       RFC b'.rfc-editor.org/errata/eid701>.\n\n   [77]       RFC Errata, Erratum ID 1283, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1283>.\n\n   [78]       RFC Errata, Erratum ID 1561, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1561>.\n\n   [79]       RFC Errata, Erratum ID 1562, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1562>.\n\n   [80]       RFC Errata, Erratum ID 1564, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1564>.\n\n   [81]       RFC Errata, Erratum ID 1571, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1571>.\n\n   [82]       RFC Errata, Erratum ID 1572, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1572>.\n\n   [83]       RFC Errata, Erratum ID 2297, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2297>.\n\n   [84]       RFC Errata, Erratum ID 2298, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2298>.\n\n   [85]       RFC Errata, Erratub'rrata/eid2748>.\n\n   [86]       RFC Errata, Erratum ID 2749, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2749>.\n\n   [87]       RFC Errata, Erratum ID 2934, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2934>.\n\n   [88]       RFC Errata, Erratum ID 3213, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3213>.\n\n   [89]       RFC Errata, Erratum ID 3300, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3300>.\n\n   [90]       RFC Errata, Erratum ID 3301, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3301>.\n\n   [91]       RFC Errata, Erratum ID 6222, RFC 793,\n              <https://www.rfc-editor.org/errata/eid6222>.\n\n   [92]       RFC Errata, Erratum ID 572, RFC 793,\n              <https://www.rfc-editor.org/errata/eid572>.\n\n   [93]       RFC Errata, Erratum ID 575, RFC 793,\n              <https://www.rfc-editor.org/errata/eid575>.\n\n   [94]       RFC Errata, Erratum ID 1565, RFC 793,\b'[95]       RFC Errata, Erratum ID 1569, RFC 793,\n              <https://www.rfc-editor.org/errata/eid1569>.\n\n   [96]       RFC Errata, Erratum ID 2296, RFC 793,\n              <https://www.rfc-editor.org/errata/eid2296>.\n\n   [97]       RFC Errata, Erratum ID 3305, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3305>.\n\n   [98]       RFC Errata, Erratum ID 3602, RFC 793,\n              <https://www.rfc-editor.org/errata/eid3602>.\n\n   [99]       RFC Errata, Erratum ID 4772, RFC 5961,\n              <https://www.rfc-editor.org/errata/eid4772>.\n\n   [100]      Gont, F., "ICMP Attacks against TCP", RFC 5927,\n              DOI 10.17487/RFC5927, July 2010,\n              <https://www.rfc-editor.org/info/rfc5927>.\n\nAppendix A.  Other Implementation Notes\n\n   This section includes additional notes and references on TCP\n   implementation decisions that are currently not a part of the RFC\n   series or included within the TCP standard.  These items can bb'sensus to\n   include them in the standard.\n\nA.1.  IP Security Compartment and Precedence\n\n   The IPv4 specification [1] includes a precedence value in the (now\n   obsoleted) Type of Service (TOS) field.  It was modified in [20] and\n   then obsoleted by the definition of Differentiated Services\n   (Diffserv) [4].  Setting and conveying TOS between the network layer,\n   TCP implementation, and applications is obsolete and is replaced by\n   Diffserv in the current TCP specification.\n\n   RFC 793 required checking the IP security compartment and precedence\n   on incoming TCP segments for consistency within a connection and with\n   application requests.  Each of these aspects of IP have become\n   outdated, without specific updates to RFC 793.  The issues with\n   precedence were fixed by [25], which is Standards Track, and so this\n   present TCP specification includes those changes.  However, the state\n   of IP security options that may be used by Multi-Level Seb'rrently.\n\n   Resetting connections when incoming packets do not meet expected\n   security compartment or precedence expectations has been recognized\n   as a possible attack vector [63], and there has been discussion about\n   amending the TCP specification to prevent connections from being\n   aborted due to nonmatching IP security compartment and Diffserv\n   codepoint values.\n\nA.1.1.  Precedence\n\n   In Diffserv, the former precedence values are treated as Class\n   Selector codepoints, and methods for compatible treatment are\n   described in the Diffserv architecture.  The RFC TCP specification\n   defined by RFCs 793 and 1122 included logic intending to have\n   connections use the highest precedence requested by either endpoint\n   application, and to keep the precedence consistent throughout a\n   connection.  This logic from the obsolete TOS is not applicable to\n   Diffserv and should not be included in TCP implementations, though\n   changes to Diffserv vab'sion of this, see RFC 7657 (Sections 5.1, 5.3, and 6) [50].\n\n   The obsoleted TOS processing rules in TCP assumed bidirectional (or\n   symmetric) precedence values used on a connection, but the Diffserv\n   architecture is asymmetric.  Problems with the old TCP logic in this\n   regard were described in [25], and the solution described is to\n   ignore IP precedence in TCP.  Since RFC 2873 is a Standards Track\n   document (although not marked as updating RFC 793), current\n   implementations are expected to be robust in these conditions.  Note\n   that the Diffserv field value used in each direction is a part of the\n   interface between TCP and the network layer, and values in use can be\n   indicated both ways between TCP and the application.\n\nA.1.2.  MLS Systems\n\n   The IP Security Option (IPSO) and compartment defined in [1] was\n   refined in RFC 1038, which was later obsoleted by RFC 1108.  The\n   Commercial IP Security Option (CIPSO) is defined in FIPS-188\b'e vendors and\n   operating systems.  RFC 1108 is now Historic, though RFC 791 itself\n   has not been updated to remove the IP Security Option.  For IPv6, a\n   similar option (Common Architecture Label IPv6 Security Option\n   (CALIPSO)) has been defined [36].  RFC 793 includes logic that\n   includes the IP security/compartment information in treatment of TCP\n   segments.  References to the IP "security/compartment" in this\n   document may be relevant for Multi-Level Secure (MLS) system\n   implementers but can be ignored for non-MLS implementations,\n   consistent with running code on the Internet.  See Appendix A.1 for\n   further discussion.  Note that RFC 5570 describes some MLS networking\n   scenarios where IPSO, CIPSO, or CALIPSO may be used.  In these\n   special cases, TCP implementers should see Section 7.3.1 of RFC 5570\n   and follow the guidance in that document.\n\nA.2.  Sequence Number Validation\n\n   There are cases where the TCP sequence number validb'ssed.  This can result in\n   connection issues, as described in [64], which includes descriptions\n   of potential problems in conditions of simultaneous open, self-\n   connects, simultaneous close, and simultaneous window probes.  The\n   document also describes potential changes to the TCP specification to\n   mitigate the issue by expanding the acceptable sequence numbers.\n\n   In Internet usage of TCP, these conditions rarely occur.  Common\n   operating systems include different alternative mitigations, and the\n   standard has not been updated yet to codify one of them, but\n   implementers should consider the problems described in [64].\n\nA.3.  Nagle Modification\n\n   In common operating systems, both the Nagle algorithm and delayed\n   acknowledgments are implemented and enabled by default.  TCP is used\n   by many applications that have a request-response style of\n   communication, where the combination of the Nagle algorithm and\n   delayed acknowledgments b'cation to the Nagle algorithm is described in [68] that\n   improves the situation for these applications.\n\n   This modification is implemented in some common operating systems and\n   does not impact TCP interoperability.  Additionally, many\n   applications simply disable Nagle since this is generally supported\n   by a socket option.  The TCP standard has not been updated to include\n   this Nagle modification, but implementers may find it beneficial to\n   consider.\n\nA.4.  Low Watermark Settings\n\n   Some operating system kernel TCP implementations include socket\n   options that allow specifying the number of bytes in the buffer until\n   the socket layer will pass sent data to TCP (SO_SNDLOWAT) or to the\n   application on receiving (SO_RCVLOWAT).\n\n   In addition, another socket option (TCP_NOTSENT_LOWAT) can be used to\n   control the amount of unsent bytes in the write queue.  This can help\n   a sending TCP application to avoid creating large amounts of bufb'e, this may be useful\n   for applications that are multiplexing data from multiple upper-level\n   streams onto a connection, especially when streams may be a mix of\n   interactive/real-time and bulk data transfer.\n\nAppendix B.  TCP Requirement Summary\n\n   This section is adapted from RFC 1122.\n\n   Note that there is no requirement related to PLPMTUD in this list,\n   but that PLPMTUD is recommended.\n\n    +=================+=========+======+========+=====+========+======+\n    |     Feature     |  ReqID  | MUST | SHOULD | MAY | SHOULD | MUST |\n    |                 |         |      |        |     |  NOT   | NOT  |\n    +=================+=========+======+========+=====+========+======+\n    | PUSH flag                                                       |\n    +=================+=========+======+========+=====+========+======+\n    | Aggregate or    | MAY-16  |      |        |  X  |        |      |\n    | queue un-pushed |         |      |        |     |      b'   |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Sender collapse | SHLD-27 |      |   X    |     |        |      |\n    | successive PSH  |         |      |        |     |        |      |\n    | bits            |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | SEND call can   | MAY-15  |      |        |  X  |        |      |\n    | specify PUSH    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  If cannot:   | MUST-60 |      |        |     |        |  X   |\n    |    sender       |         |      |        |     |        |      |\n    |    buffer       |         |      |        |     |        |      |\n    |    indefinitely |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Ib'  |      |\n    |    PSH last     |         |      |        |     |        |      |\n    |    segment      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Notify          | MAY-17  |      |        |  X  |        |      |\n    | receiving ALP^1 |         |      |        |     |        |      |\n    | of PSH          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Send max size   | SHLD-28 |      |   X    |     |        |      |\n    | segment when    |         |      |        |     |        |      |\n    | possible        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Window                                                          |\n    +=================+=========+======+========+=====+========+======+\n    | Treat as        | MUb' unsigned number |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Handle as       | REC-1   |      |   X    |     |        |      |\n    | 32-bit number   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Shrink window   | SHLD-14 |      |        |     |   X    |      |\n    | from right      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Send new     | SHLD-15 |      |        |     |   X    |      |\n    |    data when    |         |      |        |     |        |      |\n    |    window       |         |      |        |     |        |      |\n    |    shrinks      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Retransmit   | SHLD-16 |      |   b" |         |      |        |     |        |      |\n    |    data within  |         |      |        |     |        |      |\n    |    window       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Time out     | SHLD-17 |      |        |     |   X    |      |\n    |    conn for     |         |      |        |     |        |      |\n    |    data past    |         |      |        |     |        |      |\n    |    right edge   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Robust against  | MUST-34 |  X   |        |     |        |      |\n    | shrinking       |         |      |        |     |        |      |\n    | window          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receiver's      | MAY-8   |      |        |  X  |    b'  |        |     |        |      |\n    | indefinitely    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Use standard    | MUST-35 |  X   |        |     |        |      |\n    | probing logic   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Sender probe    | MUST-36 |  X   |        |     |        |      |\n    | zero window     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  First probe  | SHLD-29 |      |   X    |     |        |      |\n    |    after RTO    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Exponential  | SHLD-30 |      |   X    |     |        |      |\n    |    backoff      |         |      |        |     |        |      |\n  b'-+--------+------+\n    | Allow window    | MUST-37 |  X   |        |     |        |      |\n    | stay zero       |         |      |        |     |        |      |\n    | indefinitely    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Retransmit old  | MAY-7   |      |        |  X  |        |      |\n    | data beyond     |         |      |        |     |        |      |\n    | SND.UNA+SND.WND |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Process RST and | MUST-66 |  X   |        |     |        |      |\n    | URG even with   |         |      |        |     |        |      |\n    | zero window     |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Urgent Data                                                     |\n    +=============b'=+\n    | Include support | MUST-30 |  X   |        |     |        |      |\n    | for urgent      |         |      |        |     |        |      |\n    | pointer         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Pointer         | MUST-62 |  X   |        |     |        |      |\n    | indicates first |         |      |        |     |        |      |\n    | non-urgent      |         |      |        |     |        |      |\n    | octet           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Arbitrary       | MUST-31 |  X   |        |     |        |      |\n    | length urgent   |         |      |        |     |        |      |\n    | data sequence   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Inform ALP^1    | MUST-32 | b"onously  |         |      |        |     |        |      |\n    | of urgent data  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP^1 can learn | MUST-33 |  X   |        |     |        |      |\n    | if/how much     |         |      |        |     |        |      |\n    | urgent data Q'd |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP employ the  | SHLD-13 |      |        |     |   X    |      |\n    | urgent          |         |      |        |     |        |      |\n    | mechanism       |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | TCP Options                                                     |\n    +=================+=========+======+========+=====+========+======+\n    | Support the     | MUST-4  |  X   |        |  b'   |      |        |     |        |      |\n    | option set      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receive TCP     | MUST-5  |  X   |        |     |        |      |\n    | Option in any   |         |      |        |     |        |      |\n    | segment         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Ignore          | MUST-6  |  X   |        |     |        |      |\n    | unsupported     |         |      |        |     |        |      |\n    | options         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Include length  | MUST-68 |  X   |        |     |        |      |\n    | for all options |         |      |        |     |        |      |\n    | except EOL+NOP  |         |      |        |     |        |   b'---+-----+--------+------+\n    | Cope with       | MUST-7  |  X   |        |     |        |      |\n    | illegal option  |         |      |        |     |        |      |\n    | length          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Process options | MUST-64 |  X   |        |     |        |      |\n    | regardless of   |         |      |        |     |        |      |\n    | word alignment  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Implement       | MUST-14 |  X   |        |     |        |      |\n    | sending &       |         |      |        |     |        |      |\n    | receiving MSS   |         |      |        |     |        |      |\n    | Option          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv4b'  |      |\n    | Option unless   |         |      |        |     |        |      |\n    | 536             |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv6 Send MSS   | SHLD-5  |      |   X    |     |        |      |\n    | Option unless   |         |      |        |     |        |      |\n    | 1220            |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Send MSS Option | MAY-3   |      |        |  X  |        |      |\n    | always          |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv4 Send-MSS   | MUST-15 |  X   |        |     |        |      |\n    | default is 536  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | IPv6 Send-MSS   | MUb' default is 1220 |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Calculate       | MUST-16 |  X   |        |     |        |      |\n    | effective send  |         |      |        |     |        |      |\n    | seg size        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | MSS accounts    | SHLD-6  |      |   X    |     |        |      |\n    | for varying MTU |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | MSS not sent on | MUST-65 |      |        |     |        |  X   |\n    | non-SYN         |         |      |        |     |        |      |\n    | segments        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | MSS value based | MUST-67 |  X   |   b' |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Pad with zero   | MUST-69 |  X   |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | TCP Checksums                                                   |\n    +=================+=========+======+========+=====+========+======+\n    | Sender compute  | MUST-2  |  X   |        |     |        |      |\n    | checksum        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receiver check  | MUST-3  |  X   |        |     |        |      |\n    | checksum        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | ISN Selection                                                   |\n    +=================+=========+======+========+=====+====b'  |        |     |        |      |\n    | clock-driven    |         |      |        |     |        |      |\n    | ISN generator   |         |      |        |     |        |      |\n    | component       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Secure ISN      | SHLD-1  |      |   X    |     |        |      |\n    | generator with  |         |      |        |     |        |      |\n    | a PRF component |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | PRF computable  | MUST-9  |      |        |     |        |  X   |\n    | from outside    |         |      |        |     |        |      |\n    | the host        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Opening Connections                                             |\n  b'=+========+======+\n    | Support         | MUST-10 |  X   |        |     |        |      |\n    | simultaneous    |         |      |        |     |        |      |\n    | open attempts   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | SYN-RECEIVED    | MUST-11 |  X   |        |     |        |      |\n    | remembers last  |         |      |        |     |        |      |\n    | state           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Passive OPEN    | MUST-41 |      |        |     |        |  X   |\n    | call interfere  |         |      |        |     |        |      |\n    | with others     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Function:       | MUST-42 |  X   |        |     |        |      |\n    | simultaneousb' |\n    | LISTENs for     |         |      |        |     |        |      |\n    | same port       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Ask IP for src  | MUST-44 |  X   |        |     |        |      |\n    | address for SYN |         |      |        |     |        |      |\n    | if necessary    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Otherwise,   | MUST-45 |  X   |        |     |        |      |\n    |    use local    |         |      |        |     |        |      |\n    |    addr of      |         |      |        |     |        |      |\n    |    connection   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | OPEN to         | MUST-46 |      |        |     |        |  X   |\n    | broadcast/      |         | b'st IP    |         |      |        |     |        |      |\n    | address         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Silently        | MUST-57 |  X   |        |     |        |      |\n    | discard seg to  |         |      |        |     |        |      |\n    | bcast/mcast     |         |      |        |     |        |      |\n    | addr            |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Closing Connections                                             |\n    +=================+=========+======+========+=====+========+======+\n    | RST can contain | SHLD-2  |      |   X    |     |        |      |\n    | data            |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Inform          | MUST-12 |  X   |        |  b'   |      |        |     |        |      |\n    | aborted conn    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Half-duplex     | MAY-1   |      |        |  X  |        |      |\n    | close           |         |      |        |     |        |      |\n    | connections     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Send RST to  | SHLD-3  |      |   X    |     |        |      |\n    |    indicate     |         |      |        |     |        |      |\n    |    data lost    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | In TIME-WAIT    | MUST-13 |  X   |        |     |        |      |\n    | state for 2MSL  |         |      |        |     |        |      |\n    | seconds         |         |      |        |     |        |   b'---+-----+--------+------+\n    | *  Accept SYN   | MAY-2   |      |        |  X  |        |      |\n    |    from TIME-   |         |      |        |     |        |      |\n    |    WAIT state   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Use          | SHLD-4  |      |   X    |     |        |      |\n    |    Timestamps   |         |      |        |     |        |      |\n    |    to reduce    |         |      |        |     |        |      |\n    |    TIME-WAIT    |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Retransmissions                                                 |\n    +=================+=========+======+========+=====+========+======+\n    | Implement       | MUST-19 |  X   |        |     |        |      |\n    | exponential     |         |      |        |     |        |      |\n    | backb"  |      |\n    | start, and      |         |      |        |     |        |      |\n    | congestion      |         |      |        |     |        |      |\n    | avoidance       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Retransmit with | MAY-4   |      |        |  X  |        |      |\n    | same IP         |         |      |        |     |        |      |\n    | identity        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Karn's          | MUST-18 |  X   |        |     |        |      |\n    | algorithm       |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Generating ACKs                                                 |\n    +=================+=========+======+========+=====+========+======+\n    | Aggregate       | MUb" whenever        |         |      |        |     |        |      |\n    | possible        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Queue out-of-   | SHLD-31 |      |   X    |     |        |      |\n    | order segments  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Process all Q'd | MUST-59 |  X   |        |     |        |      |\n    | before send ACK |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Send ACK for    | MAY-13  |      |        |  X  |        |      |\n    | out-of-order    |         |      |        |     |        |      |\n    | segment         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Delayed ACKs    | SHLD-18 |      |   b"-+---------+------+--------+-----+--------+------+\n    | *  Delay < 0.5  | MUST-40 |  X   |        |     |        |      |\n    |    seconds      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Every 2nd    | SHLD-19 |      |   X    |     |        |      |\n    |    full-sized   |         |      |        |     |        |      |\n    |    segment or   |         |      |        |     |        |      |\n    |    2*RMSS ACK'd |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Receiver SWS-   | MUST-39 |  X   |        |     |        |      |\n    | Avoidance       |         |      |        |     |        |      |\n    | Algorithm       |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Sending Data                                         b'==+========+=====+========+======+\n    | Configurable    | MUST-49 |  X   |        |     |        |      |\n    | TTL             |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Sender SWS-     | MUST-38 |  X   |        |     |        |      |\n    | Avoidance       |         |      |        |     |        |      |\n    | Algorithm       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Nagle algorithm | SHLD-7  |      |   X    |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Application  | MUST-17 |  X   |        |     |        |      |\n    |    can disable  |         |      |        |     |        |      |\n    |    Nagle        |         |      |        |     |        |      |\n    |    algorithm    |         |      |        |     |        |      |\n  b'=+========+======+\n    | Connection Failures                                             |\n    +=================+=========+======+========+=====+========+======+\n    | Negative advice | MUST-20 |  X   |        |     |        |      |\n    | to IP on R1     |         |      |        |     |        |      |\n    | retransmissions |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Close           | MUST-20 |  X   |        |     |        |      |\n    | connection on   |         |      |        |     |        |      |\n    | R2              |         |      |        |     |        |      |\n    | retransmissions |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP^1 can set   | MUST-21 |  X   |        |     |        |      |\n    | R2              |         |      |        |     |        |      |\n    +-------------b'-+\n    | Inform ALP of   | SHLD-9  |      |   X    |     |        |      |\n    | R1<=retxs<R2    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Recommended     | SHLD-10 |      |   X    |     |        |      |\n    | value for R1    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Recommended     | SHLD-11 |      |   X    |     |        |      |\n    | value for R2    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Same mechanism  | MUST-22 |  X   |        |     |        |      |\n    | for SYNs        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  R2 at least  | MUST-23 |  X   |        |     |        |      |\n    |    3 minutes    |         | b'SYN      |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Send Keep-alive Packets                                         |\n    +=================+=========+======+========+=====+========+======+\n    | Send Keep-alive | MAY-5   |      |   X    |     |        |      |\n    | Packets:        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Application  | MUST-24 |  X   |        |     |        |      |\n    |    can request  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Default is   | MUST-25 |  X   |        |     |        |      |\n    |    "off"        |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Only send if | MUST-26 |  X   |        |  b'   |      |        |     |        |      |\n    |    interval     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Interval     | MUST-27 |  X   |        |     |        |      |\n    |    configurable |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Default at   | MUST-28 |  X   |        |     |        |      |\n    |    least 2 hrs. |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Tolerant of  | MUST-29 |  X   |        |     |        |      |\n    |    lost ACKs    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Send with no | SHLD-12 |      |   X    |     |        |      |\n    |    data         |         |      |        |     |        |   b"---+-----+--------+------+\n    | *  Configurable | MAY-6   |      |        |  X  |        |      |\n    |    to send      |         |      |        |     |        |      |\n    |    garbage      |         |      |        |     |        |      |\n    |    octet        |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | IP Options                                                      |\n    +=================+=========+======+========+=====+========+======+\n    | Ignore options  | MUST-50 |  X   |        |     |        |      |\n    | TCP doesn't     |         |      |        |     |        |      |\n    | understand      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Timestamp       | MAY-10  |      |   X    |     |        |      |\n    | support         |         |      |        |     |        |      |\n    +-----b'--+------+\n    | Record Route    | MAY-11  |      |   X    |     |        |      |\n    | support         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Source Route:   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  ALP^1 can    | MUST-51 |  X   |        |     |        |      |\n    |    specify      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *     Overrides | MUST-52 |  X   |        |     |        |      |\n    |       src route |         |      |        |     |        |      |\n    |       in        |         |      |        |     |        |      |\n    |       datagram  |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Build return | MUb'    route from   |         |      |        |     |        |      |\n    |    src route    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Later src    | SHLD-24 |      |   X    |     |        |      |\n    |    route        |         |      |        |     |        |      |\n    |    overrides    |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Receiving ICMP Messages from IP                                 |\n    +=================+=========+======+========+=====+========+======+\n    | Receiving ICMP  | MUST-54 |  X   |        |     |        |      |\n    | messages from   |         |      |        |     |        |      |\n    | IP              |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Dest Unreach | SHLD-25 |  X   |   b' |         |      |        |     |        |      |\n    |    inform ALP   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Abort on     | MUST-56 |      |        |     |        |  X   |\n    |    Dest Unreach |         |      |        |     |        |      |\n    |    (0,1,5)      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Dest Unreach | SHLD-26 |      |   X    |     |        |      |\n    |    (2-4) =>     |         |      |        |     |        |      |\n    |    abort conn   |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Source       | MUST-55 |  X   |        |     |        |      |\n    |    Quench =>    |         |      |        |     |        |      |\n    |    silent       |         |      |        |     |    b'  |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Abort on     | MUST-56 |      |        |     |        |  X   |\n    |    Time         |         |      |        |     |        |      |\n    |    Exceeded     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Abort on     | MUST-56 |      |        |     |        |  X   |\n    |    Param        |         |      |        |     |        |      |\n    |    Problem      |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Address Validation                                              |\n    +=================+=========+======+========+=====+========+======+\n    | Reject OPEN     | MUST-46 |  X   |        |     |        |      |\n    | call to invalid |         |      |        |     |        |      |\n  b' |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Reject SYN from | MUST-63 |  X   |        |     |        |      |\n    | invalid IP      |         |      |        |     |        |      |\n    | address         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Silently        | MUST-57 |  X   |        |     |        |      |\n    | discard SYN to  |         |      |        |     |        |      |\n    | bcast/mcast     |         |      |        |     |        |      |\n    | addr            |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | TCP/ALP Interface Services                                      |\n    +=================+=========+======+========+=====+========+======+\n    | Error Report    | MUST-47 |  X   |        |     |        |      |\n    | mechanism   b' |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP can disable | SHLD-20 |      |   X    |     |        |      |\n    | Error Report    |         |      |        |     |        |      |\n    | Routine         |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP can specify | MUST-48 |  X   |        |     |        |      |\n    | Diffserv field  |         |      |        |     |        |      |\n    | for sending     |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | *  Passed       | SHLD-22 |      |   X    |     |        |      |\n    |    unchanged to |         |      |        |     |        |      |\n    |    IP           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP can change  | SHLD-21 | b'v field  |         |      |        |     |        |      |\n    | during          |         |      |        |     |        |      |\n    | connection      |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | ALP generally   | SHLD-23 |      |        |     |   X    |      |\n    | changing        |         |      |        |     |        |      |\n    | Diffserv during |         |      |        |     |        |      |\n    | conn.           |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | Pass received   | MAY-9   |      |        |  X  |        |      |\n    | Diffserv field  |         |      |        |     |        |      |\n    | up to ALP       |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n    | FLUSH call      | MAY-14  |      |        |  b'---+------+--------+-----+--------+------+\n    | Optional local  | MUST-43 |  X   |        |     |        |      |\n    | IP addr param   |         |      |        |     |        |      |\n    | in OPEN         |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | RFC 5961 Support                                                |\n    +=================+=========+======+========+=====+========+======+\n    | Implement data  | MAY-12  |      |        |  X  |        |      |\n    | injection       |         |      |        |     |        |      |\n    | protection      |         |      |        |     |        |      |\n    +=================+=========+======+========+=====+========+======+\n    | Explicit Congestion Notification                                |\n    +=================+=========+======+========+=====+========+======+\n    | Support ECN     | SHLD-8  |      |   X    |     |        |   b'===+=====+========+======+\n    | Alternative Congestion Control                                  |\n    +=================+=========+======+========+=====+========+======+\n    | Implement       | MAY-18  |      |        |  X  |        |      |\n    | alternative     |         |      |        |     |        |      |\n    | conformant      |         |      |        |     |        |      |\n    | algorithm(s)    |         |      |        |     |        |      |\n    +-----------------+---------+------+--------+-----+--------+------+\n\n                     Table 8: TCP Requirements Summary\n\n   FOOTNOTES: (1) "ALP" means Application-Layer Program.\n\nAcknowledgments\n\n   This document is largely a revision of RFC 793, of which Jon Postel\n   was the editor.  Due to his excellent work, it was able to last for\n   three decades before we felt the need to revise it.\n\n   Andre Oppermann was a contributor and helped to edit the first\n   revision of this document.\n\n   We ab'up\n   chairs over the course of work on this document:\n\n   Michael Scharf\n\n\n   Yoshifumi Nishida\n\n\n   Pasi Sarolahti\n\n\n   Michael T\xc3\xbcxen\n\n\n   During the discussions of this work on the TCPM mailing list, in\n   working group meetings, and via area reviews, helpful comments,\n   critiques, and reviews were received from (listed alphabetically by\n   last name): Praveen Balasubramanian, David Borman, Mohamed Boucadair,\n   Bob Briscoe, Neal Cardwell, Yuchung Cheng, Martin Duke, Francis\n   Dupont, Ted Faber, Gorry Fairhurst, Fernando Gont, Rodney Grimes, Yi\n   Huang, Rahul Jadhav, Markku Kojo, Mike Kosek, Juhamatti Kuusisaari,\n   Kevin Lahey, Kevin Mason, Matt Mathis, Stephen McQuistin, Jonathan\n   Morton, Matt Olson, Tommy Pauly, Tom Petch, Hagen Paul Pfeifer, Kyle\n   Rose, Anthony Sabatini, Michael Scharf, Greg Skinner, Joe Touch,\n   Michael T\xc3\xbcxen, Reji Varghese, Bernie Volz, Tim Wicinski, Lloyd Wood,\n   and Alex Zimmermann.\n\n   Joe Toucb"arameters and PMTUD/PLPMTUD recommendations.  Markku\n   Kojo helped put together the text in the section on TCP Congestion\n   Control.\n\n   This document includes content from errata that were reported by\n   (listed chronologically): Yin Shuming, Bob Braden, Morris M. Keesan,\n   Pei-chun Cheng, Constantin Hagemeier, Vishwas Manral, Mykyta\n   Yevstifeyev, EungJun Yi, Botong Huang, Charles Deng, Merlin Buge.\n\nAuthor's Address\n\n   Wesley M. Eddy (editor)\n   MTI Systems\n   United States of America\n   Email: wes@mti-systems.com\n"b'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'eled\n   and referenced in Appendix B, which summarizes implementation\n   requirements.\n\n   Sentences using "MUST" are labeled as "MUST-X" with X being a numeric\n   identifier enabling the requirement to be located easily when\n   referenced from Appendix B.\n\n   Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY"\n   with "MAY-X", and "RECOMMENDED" with "REC-X".\n\n   For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are\n   labeled the same as "SHOULD" and "MUST" instances.\n\n2.2.  Key TCP Concepts\n\n   TCP provides a reliable, in-order, byte-stream service to\n   applications.\n\n   The application byte-stream is conveyed over the network via TCP\n   segments, with each TCP segment sent as an Internet Protocol (IP)\n   datagram.\n\n   TCP reliability consists of detecting packet losses (via sequence\n   numbers) and errors (via per-segment checksums), as well as\n   correction via retransmission.\n\n   TCP supports unicast delivery ofb' use TCP without modifications,\n   though there is some risk of instability due to changes of lower-\n   layer forwarding behavior [46].\n\n   TCP is connection oriented, though it does not inherently include a\n   liveness detection capability.\n\n   Data flow is supported bidirectionally over TCP connections, though\n   applications are free to send data only unidirectionally, if they so\n   choose.\n\n   TCP uses port numbers to identify application services and to\n   multiplex distinct flows between hosts.\n\n   A more detailed description of TCP features compared to other\n   transport protocols can be found in Section 3.1 of [52].  Further\n   description of the motivations for developing TCP and its role in the\n   Internet protocol stack can be found in Section 2 of [16] and earlier\n   versions of the TCP specification.\n\n3.  Functional Specification\n\n3.1.  Header Format\n\n   TCP segments are sent as internet datagrams.  The Internet Protocol\n   (IP) header b'nd destination host addresses [1] [13].  A TCP header follows the IP\n   headers, supplying information specific to TCP.  This division allows\n   for the existence of host-level protocols other than TCP.  In the\n   early development of the Internet suite of protocols, the IP header\n   fields had been a part of TCP.\n\n   This document describes TCP, which uses TCP headers.\n\n   A TCP header, followed by any user data in the segment, is formatted\n   as follows, using the style from [66]:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |          Source Port          |       Destination Port        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                        Sequence Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-b'dgment Number                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |  Data |       |C|E|U|A|P|R|S|F|                               |\n      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |\n      |       |       |R|E|G|K|H|T|N|N|                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Checksum            |         Urgent Pointer        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                           [Options]                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               :\n      :                             Data                              :\n      :                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\b'e bit position.\n\n                        Figure 1: TCP Header Format\n\n   where:\n\n   Source Port:  16 bits\n\n     The source port number.\n\n   Destination Port:  16 bits\n\n     The destination port number.\n\n   Sequence Number:  32 bits\n\n     The sequence number of the first data octet in this segment (except\n     when the SYN flag is set).  If SYN is set, the sequence number is\n     the initial sequence number (ISN) and the first data octet is\n     ISN+1.\n\n   Acknowledgment Number:  32 bits\n\n     If the ACK control bit is set, this field contains the value of the\n     next sequence number the sender of the segment is expecting to\n     receive.  Once a connection is established, this is always sent.\n\n   Data Offset (DOffset):  4 bits\n\n     The number of 32-bit words in the TCP header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integer multiple of 32 bits long.\n\n   Reserved (Rsrvd):  4 bits\b'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'\xef\xbb\xbf\n\n\n\nInternet Engineering Task Force (IETF)                      W. Eddy, Ed.\nSTD: 7                                                       MTI Systems\nRequest for Comments: 9293                                   August 2022\nObsoletes: 793, 879, 2873, 6093, 6429, 6528,                            \n           6691                                                         \nUpdates: 1011, 1122, 5961                                               \nCategory: Standards Track                                               \nISSN: 2070-1721\n\n\n                  Transmission Control Protocol (TCP)\n\nAbstract\n\n   This document specifies the Transmission Control Protocol (TCP).  TCP\n   is an important transport-layer protocol in the Internet protocol\n   stack, and it has continuously evolved over decades of use and growth\n   of the Internet.  Over this time, a number of changes have been made\n   to TCP as it was specified in RFC 793, though these have only been\n  b'brings\n   those changes together with the protocol specification from RFC 793.\n   This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093,\n   6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs\n   1011 and 1122, and it should be considered as a replacement for the\n   portions of those documents dealing with TCP requirements.  It also\n   updates RFC 5961 by adding a small clarification in reset handling\n   while in the SYN-RECEIVED state.  The TCP header control bits from\n   RFC 793 have also been updated based on RFC 3168.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 7841.\nb"ent, any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc9293.\n\nCopyright Notice\n\n   Copyright (c) 2022 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Revised BSD License text as described in Section 4.e of the\n   Trust Legal Provisions and are provided without warranty as described\n   in the Revised BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(sb'may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\nTable of Contents\n\n   1.  Purpose and Scope\n   2.  Introduction\n     2.1.  Requirements Language\n     2.2.  Key TCP Concepts\n   3.  Functional Specification\n     3.1.  Header Format\n     3.2.  Specific Option Definitions\n       3.2.1.  Other Common Options\n       3.2.2.  Experimental TCP Options\n     3.3.  TCP Terminology Overview\n       3.3.1.  Key Connection State Variables\n       3.3.2.  State Machine Overview\n     3.4.  Sequence Numbers\n       3.4.1.  Initialb'eep Quiet\n       3.4.3.  The TCP Quiet Time Concept\n     3.5.  Establishing a Connection\n       3.5.1.  Half-Open Connections and Other Anomalies\n       3.5.2.  Reset Generation\n       3.5.3.  Reset Processing\n     3.6.  Closing a Connection\n       3.6.1.  Half-Closed Connections\n     3.7.  Segmentation\n       3.7.1.  Maximum Segment Size Option\n       3.7.2.  Path MTU Discovery\n       3.7.3.  Interfaces with Variable MTU Values\n       3.7.4.  Nagle Algorithm\n       3.7.5.  IPv6 Jumbograms\n     3.8.  Data Communication\n       3.8.1.  Retransmission Timeout\n       3.8.2.  TCP Congestion Control\n       3.8.3.  TCP Connection Failures\n       3.8.4.  TCP Keep-Alives\n       3.8.5.  The Communication of Urgent Information\n       3.8.6.  Managing the Window\n     3.9.  Interfaces\n       3.9.1.  User/TCP Interface\n       3.9.2.  TCP/Lower-Level Interface\n     3.10. Event Processing\n       3.10.1.  OPEN Call\n       3.10.2.  SEND Call\n       3.10.3.  RECEIVE b"    3.10.6.  STATUS Call\n       3.10.7.  SEGMENT ARRIVES\n       3.10.8.  Timeouts\n   4.  Glossary\n   5.  Changes from RFC 793\n   6.  IANA Considerations\n   7.  Security and Privacy Considerations\n   8.  References\n     8.1.  Normative References\n     8.2.  Informative References\n   Appendix A.  Other Implementation Notes\n     A.1.  IP Security Compartment and Precedence\n       A.1.1.  Precedence\n       A.1.2.  MLS Systems\n     A.2.  Sequence Number Validation\n     A.3.  Nagle Modification\n     A.4.  Low Watermark Settings\n   Appendix B.  TCP Requirement Summary\n   Acknowledgments\n   Author's Address\n\n1.  Purpose and Scope\n\n   In 1981, RFC 793 [16] was released, documenting the Transmission\n   Control Protocol (TCP) and replacing earlier published specifications\n   for TCP.\n\n   Since then, TCP has been widely implemented, and it has been used as\n   a transport protocol for numerous applications on the Internet.\n\n   For several decades, RFC 793 plb'ore specification for TCP [49].  Over time,\n   a number of errata have been filed against RFC 793.  There have also\n   been deficiencies found and resolved in security, performance, and\n   many other aspects.  The number of enhancements has grown over time\n   across many separate documents.  These were never accumulated\n   together into a comprehensive update to the base specification.\n\n   The purpose of this document is to bring together all of the IETF\n   Standards Track changes and other clarifications that have been made\n   to the base TCP functional specification (RFC 793) and to unify them\n   into an updated version of the specification.\n\n   Some companion documents are referenced for important algorithms that\n   are used by TCP (e.g., for congestion control) but have not been\n   completely included in this document.  This is a conscious choice, as\n   this base specification can be used with multiple additional\n   algorithms that are developed and incorb'e common basis that all TCP implementations\n   must support in order to interoperate.  Since some additional TCP\n   features have become quite complicated themselves (e.g., advanced\n   loss recovery and congestion control), future companion documents may\n   attempt to similarly bring these together.\n\n   In addition to the protocol specification that describes the TCP\n   segment format, generation, and processing rules that are to be\n   implemented in code, RFC 793 and other updates also contain\n   informative and descriptive text for readers to understand aspects of\n   the protocol design and operation.  This document does not attempt to\n   alter or update this informative text and is focused only on updating\n   the normative protocol specification.  This document preserves\n   references to the documentation containing the important explanations\n   and rationale, where appropriate.\n\n   This document is intended to be useful both in checking existing TCP\n   ib'in writing new\n   implementations.\n\n2.  Introduction\n\n   RFC 793 contains a discussion of the TCP design goals and provides\n   examples of its operation, including examples of connection\n   establishment, connection termination, and packet retransmission to\n   repair losses.\n\n   This document describes the basic functionality expected in modern\n   TCP implementations and replaces the protocol specification in RFC\n   793.  It does not replicate or attempt to update the introduction and\n   philosophy content in Sections 1 and 2 of RFC 793.  Other documents\n   are referenced to provide explanations of the theory of operation,\n   rationale, and detailed discussion of design decisions.  This\n   document only focuses on the normative behavior of the protocol.\n\n   The "TCP Roadmap" [49] provides a more extensive guide to the RFCs\n   that define TCP and describe various important algorithms.  The TCP\n   Roadmap contains sections on strongly encouraged enhancementb'beyond the basic\n   operation specified in this document.  As one example, implementing\n   congestion control (e.g., [8]) is a TCP requirement, but it is a\n   complex topic on its own and not described in detail in this\n   document, as there are many options and possibilities that do not\n   impact basic interoperability.  Similarly, most TCP implementations\n   today include the high-performance extensions in [47], but these are\n   not strictly required or discussed in this document.  Multipath\n   considerations for TCP are also specified separately in [59].\n\n   A list of changes from RFC 793 is contained in Section 5.\n\n2.1.  Requirements Language\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and\n   "OPTIONAL" in this document are to be interpreted as described in\n   BCP 14 [3] [12] when, and only when, they appear in all capitals, as\n   shown here.\n\n   Each use ob'eled\n   and referenced in Appendix B, which summarizes implementation\n   requirements.\n\n   Sentences using "MUST" are labeled as "MUST-X" with X being a numeric\n   identifier enabling the requirement to be located easily when\n   referenced from Appendix B.\n\n   Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY"\n   with "MAY-X", and "RECOMMENDED" with "REC-X".\n\n   For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are\n   labeled the same as "SHOULD" and "MUST" instances.\n\n2.2.  Key TCP Concepts\n\n   TCP provides a reliable, in-order, byte-stream service to\n   applications.\n\n   The application byte-stream is conveyed over the network via TCP\n   segments, with each TCP segment sent as an Internet Protocol (IP)\n   datagram.\n\n   TCP reliability consists of detecting packet losses (via sequence\n   numbers) and errors (via per-segment checksums), as well as\n   correction via retransmission.\n\n   TCP supports unicast delivery ofb' use TCP without modifications,\n   though there is some risk of instability due to changes of lower-\n   layer forwarding behavior [46].\n\n   TCP is connection oriented, though it does not inherently include a\n   liveness detection capability.\n\n   Data flow is supported bidirectionally over TCP connections, though\n   applications are free to send data only unidirectionally, if they so\n   choose.\n\n   TCP uses port numbers to identify application services and to\n   multiplex distinct flows between hosts.\n\n   A more detailed description of TCP features compared to other\n   transport protocols can be found in Section 3.1 of [52].  Further\n   description of the motivations for developing TCP and its role in the\n   Internet protocol stack can be found in Section 2 of [16] and earlier\n   versions of the TCP specification.\n\n3.  Functional Specification\n\n3.1.  Header Format\n\n   TCP segments are sent as internet datagrams.  The Internet Protocol\n   (IP) header b'nd destination host addresses [1] [13].  A TCP header follows the IP\n   headers, supplying information specific to TCP.  This division allows\n   for the existence of host-level protocols other than TCP.  In the\n   early development of the Internet suite of protocols, the IP header\n   fields had been a part of TCP.\n\n   This document describes TCP, which uses TCP headers.\n\n   A TCP header, followed by any user data in the segment, is formatted\n   as follows, using the style from [66]:\n\n       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |          Source Port          |       Destination Port        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                        Sequence Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-b'dgment Number                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |  Data |       |C|E|U|A|P|R|S|F|                               |\n      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |\n      |       |       |R|E|G|K|H|T|N|N|                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Checksum            |         Urgent Pointer        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                           [Options]                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               :\n      :                             Data                              :\n      :                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\b'e bit position.\n\n                        Figure 1: TCP Header Format\n\n   where:\n\n   Source Port:  16 bits\n\n     The source port number.\n\n   Destination Port:  16 bits\n\n     The destination port number.\n\n   Sequence Number:  32 bits\n\n     The sequence number of the first data octet in this segment (except\n     when the SYN flag is set).  If SYN is set, the sequence number is\n     the initial sequence number (ISN) and the first data octet is\n     ISN+1.\n\n   Acknowledgment Number:  32 bits\n\n     If the ACK control bit is set, this field contains the value of the\n     next sequence number the sender of the segment is expecting to\n     receive.  Once a connection is established, this is always sent.\n\n   Data Offset (DOffset):  4 bits\n\n     The number of 32-bit words in the TCP header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integer multiple of 32 bits long.\n\n   Reserved (Rsrvd):  4 bits\